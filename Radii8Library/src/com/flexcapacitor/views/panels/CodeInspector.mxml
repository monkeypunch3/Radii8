<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 xmlns:c="com.flexcapacitor.controls.*"
		 xmlns:handlers="com.flexcapacitor.handlers.*" 
		 xmlns:clipboard="com.flexcapacitor.effects.clipboard.*" 
		 xmlns:core="com.flexcapacitor.effects.core.*" 
		 xmlns:flexcapacitor="flexcapacitor.*" 
		 xmlns:flexiframe="com.google.code.flexiframe.*"
		 xmlns:controls="com.riaspace.controls.*"
		 xmlns:ns="http://www.flexcapacitor.com/flex/2015" 
		 
		 minWidth="200" 
		 minHeight="100"
		 implements="com.flexcapacitor.views.IInspector" 
		 >
	
	
	<fx:Script>
		<![CDATA[
			import com.flexcapacitor.controller.Radiate;
			import com.flexcapacitor.controls.AceEditor;
			import com.flexcapacitor.events.RadiateEvent;
			import com.flexcapacitor.managers.CodeManager;
			import com.flexcapacitor.managers.HistoryManager;
			import com.flexcapacitor.model.ExportOptions;
			import com.flexcapacitor.model.HTMLExportOptions;
			import com.flexcapacitor.model.IDocument;
			import com.flexcapacitor.model.IProject;
			import com.flexcapacitor.model.Settings;
			import com.flexcapacitor.model.SourceData;
			import com.flexcapacitor.model.TranscoderDescription;
			import com.flexcapacitor.utils.DisplayObjectUtils;
			import com.flexcapacitor.utils.MXMLDocumentConstants;
			import com.flexcapacitor.utils.XMLUtils;
			import com.flexcapacitor.utils.supportClasses.ComponentDescription;
			import com.flexcapacitor.utils.supportClasses.XMLValidationInfo;
			import com.google.code.flexiframe.IFrame;
			
			import mx.core.IVisualElement;
			import mx.core.IVisualElementContainer;
			import mx.core.UIComponent;
			import mx.events.ItemClickEvent;
			import mx.utils.Platform;
			import mx.validators.IValidator;
			
			import spark.events.IndexChangeEvent;
			import spark.layouts.BasicLayout;
			
			public static const HTML_RENDER:String = "htmlRender";
			public static const HTML_COMPLETE:String = "complete";
			
			public static const DESKTOP:String = "desktop";
			public static const BROWSER:String = "browser";
			
			/**
			 * Reference to Radiate
			 * */
			public var radiate:Radiate;
			
			/**
			 * Last target
			 * */
			public var lastTarget:Object;
			
			/**
			 * Last target parent instance
			 * */
			public var lastParentInstance:Object;
			
			/**
			 * Basic HTML template
			 * */
			public var basicTemplate:String;
			
			/**
			 * Indicates when the user has typed in the text area
			 * */
			[Bindable]
			public var isCodeModifiedByUser:Boolean;
			
			/**
			 * Show borders around HTML elements
			 * */
			public var showBorders:Boolean;
			
			/**
			 * Use SVG button class
			 * */
			public var useSVGButtonClass:Boolean = true;
			
			/**
			 * Show full HTML page source
			 * */
			public var showFullHTMLPageSource:Boolean = true;
			
			/**
			 * Create screen shot and add as background image of HTML page 
			 * */
			public var showBackgroundImage:Boolean = false;
			
			/**
			 * Indicates if XML is invalid
			 * */
			public var isValid:Boolean;
			
			[Bindable]
			public var editorMargin:String = "28px 0 8px 0px";
			
			public var settingEditorText:Boolean;
			public var editingTemplate:Boolean;
			
			
			private var options:ExportOptions;
			
			[Bindable]
			public var isHTML:Boolean;
			[Bindable]
			public var isMXML:Boolean;
			
			public var htmlRenderHandled:Boolean;
			public var htmlCompleteHandled:Boolean;
			public var htmlStartRenderTime:int;
			public var htmlRenderTime:int;
			public var htmlStartCompleteTime:int;
			public var htmlCompleteTime:int;
			
			/**
			 * Last source data
			 * */
			[Bindable]
			public var sourceData:SourceData;
			
			public var lastTextAreaValue:String;
			
			public var aceEditorCreated:Boolean;
			public var aceCSSEditorCreated:Boolean;
			public var aceTemplateEditorCreated:Boolean;
			
			[Bindable]
			public var enableWordWrap:Boolean;
			
			[Bindable]
			public var embedImages:Boolean;
			public var activatedOnce:Boolean;
			
			public function activate():void {
				radiate = Radiate.getInstance();
				
				addListeners();
				
				if (Radiate.isDesktop) {
					currentState = "desktop";
					
					if (aceEditor==null) {
						createEditors();
						
						updateEditorOptions();
					}
				}
				
				if (basicTemplate==null) {
					basicTemplate = new Radii8LibraryTranscodersAssets.basicHTMLDocumentReusable();
				}
				
				if (showChildDescriptors) {
					showChildDescriptors.selected = true;
				}
				
				if (radiate.isDocumentPreviewOpen(radiate.selectedDocument)) {
					languageTypeButtons.selectedItem = CodeManager.HTML;
					isHTML = true;
				}
				
				isMXML = languageTypeButtons.selectedItem==CodeManager.MXML;
				
				var settings:Settings = Radiate.settings;
				
				if (activatedOnce==false) {
					enableWordWrap = settings.enableWordWrap;
					embedImages = settings.embedImages;
					activatedOnce = true;
				}
				
				if (radiate.target) {
					updateCodeEditors();
				}
				
				if (Platform.isBrowser) {
					editorMargin = "0";
				}
				if (aceEditor) {
					aceEditor.visible = true;
				}
				if (aceCSSEditor) {
					aceCSSEditor.visible = true;
				}
				if (templateEditor) {
					templateEditor.visible = true;
				}
			}
			
			public function deactivate():void {
				removeListeners();
				if (aceEditor) {
					aceEditor.visible = false;
				}
				if (aceCSSEditor) {
					aceCSSEditor.visible = false;
				}
				if (templateEditor) {
					templateEditor.visible = false;
				}
			}
			
			public function addListeners():void {
				radiate.addEventListener(RadiateEvent.TARGET_CHANGE, handleTargetChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.PROPERTY_CHANGED, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.MOVE_ITEM, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.ADD_ITEM, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.REMOVE_ITEM, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.HISTORY_CHANGE, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.DOCUMENT_CHANGE, handleDocumentChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.DOCUMENT_CLOSE, handleDocumentClosed, false, 0, true);
				radiate.addEventListener(RadiateEvent.UNCAUGHT_EXCEPTION_EVENT, uncaughtExceptionEvent, false, 0, true);
			}
			
			public function removeListeners():void {
				if (radiate) {
					radiate.removeEventListener(RadiateEvent.TARGET_CHANGE, handleTargetChange);
					radiate.removeEventListener(RadiateEvent.PROPERTY_CHANGED, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.MOVE_ITEM, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.ADD_ITEM, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.REMOVE_ITEM, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.HISTORY_CHANGE, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.DOCUMENT_CHANGE, handleDocumentChange);
					radiate.removeEventListener(RadiateEvent.DOCUMENT_CLOSE, handleDocumentClosed);
					radiate.removeEventListener(RadiateEvent.UNCAUGHT_EXCEPTION_EVENT, uncaughtExceptionEvent);
				}
			}
			
			/**
			 * Generate the code for the provided target component. 
			 * */
			public function updateTarget(target:Object):void {
				var iDocument:IDocument = radiate.selectedDocument;
				var targetDescription:ComponentDescription;
				var language:String = getSelectedLanguage();
				var output:String = "";
				var xml:XML;
				
				if (target==null && iDocument) {
					target = iDocument.instance;
				}
				
				if (editingTemplate && iDocument) {
					iDocument.template = templateEditor.text;
				}
				
				if (iDocument!=null) {
					targetDescription = DisplayObjectUtils.getTargetInComponentDisplayList(target, iDocument.componentDescription);
				}
				
				if (language==null || targetDescription==null || iDocument==null) {
					sourceData = null;
					radiate.editorSource = null;
					setEditorText(null);
					return;
				}
				
				
				if (language == CodeManager.HTML) {
					//if (!htmlOptions) {
					var htmlOptions:HTMLExportOptions;
					htmlOptions = CodeManager.getExportOptions(language) as HTMLExportOptions;
					//}
					
					//htmlOptions.template = html5boilerplate;
					//htmlOptions.bordersCSS = bordersCSS;
					htmlOptions.showBorders = showBorders;
					//htmlOptions.useBorderBox = useBoderBox;
					htmlOptions.useInlineStyles = setStylesInline.selected;
					htmlOptions.template = iDocument.template;
					htmlOptions.disableTabs = true;
					htmlOptions.useExternalStylesheet = false;
					htmlOptions.exportChildDescriptors = showChildDescriptors.selected;
					htmlOptions.reverseInitialCSS = true;
					htmlOptions.embedImages = embedImagesButton.selected;
					
					if (updateCodeLive.selected && isCodeModifiedByUser) {
						htmlOptions.useCustomMarkup = true;
						htmlOptions.markup = aceEditor.text;
						htmlOptions.styles = aceCSSEditor.text;
					}
					else {
						htmlOptions.useCustomMarkup = false;
						htmlOptions.markup = "";
						htmlOptions.styles = "";
					}
					
					options = htmlOptions;
				}
				else if (language == CodeManager.MXML) {
					options = CodeManager.getExportOptions(language) as ExportOptions;
					options.template = "";
					options.exportChildDescriptors = showChildDescriptors.selected;
					options.embedImages = embedImagesButton.selected;
					//options = null;
				}
				else if (language == CodeManager.ANDROID) {
					options = CodeManager.getExportOptions(language) as ExportOptions;
					options.template = "";
					options.embedImages = embedImagesButton.selected;
					//options = null;
				}
				
				sourceData = CodeManager.getSourceData(target, iDocument, language, options);
				
				output = sourceData.source;
				radiate.editorSource = sourceData;
				iDocument.errors = sourceData.errors;
				iDocument.warnings = sourceData.warnings;
				
				//if (radiate.isPreviewDocumentVisible() && updateCodeLive.selected && isCodeModifiedByUser) {
				if (updateCodeLive.selected && isCodeModifiedByUser) {
					if (language==CodeManager.HTML) {
						updateHTMLPreview();
					}
				}
				else {
					setEditorText(sourceData);
					
					if (radiate.isPreviewDocumentVisible() && language==CodeManager.HTML) {
						updateHTMLPreview();
					}
				}
				
				radiate.dispatchPreviewEvent(sourceData, language);
			}
			
			/**
			 * Handle target change
			 * */
			protected function handleTargetChange(event:RadiateEvent):void {

				// if code is not modified by the user 
				// and show selection 
				// we only want to update the view on selection change when we are 
				// paying attention when we have show selected component code option enabled
				if (!isCodeModifiedByUser) {
					updateCodeEditors();
				}
				else if (updateCodeLive.selected && radiate.isPreviewDocumentVisible()) {
					updateCodeEditors(true);
					updateHTMLPreview();
				}
				
				if (updateCodeLive.selected) {var language:String = getSelectedLanguage();
					radiate.dispatchCodeUpdatedEvent(sourceData, language);
				}
			}
			
			/**
			 * Updates the code when the document changes. 
			 * */
			protected function handleDocumentChange(event:RadiateEvent):void {
				var selectedDocument:IDocument = IDocument(event.selectedItem);
				
				
				if (radiate.isPreviewDocumentVisible()) {
					//return;
				}
				
				if (!isCodeModifiedByUser) {
					updateCodeEditors(true);
				}
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML);
				}
			}
			
			/**
			 * Updates the code when a property change happens. 
			 * If the text has been modified by the user then we don't update the code.
			 * They have to press the resync button. 
			 * */
			protected function handlePropertyChange(event:RadiateEvent):void {
				
				if (!isCodeModifiedByUser) {
					updateCodeEditors(true);
				}
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML);
				}
			}
			
			/**
			 * Updates the code to reflect the selected language 
			 * */
			protected function languageType_changeHandler(event:IndexChangeEvent):void {
				var selectedLanguage:Object;
				
				isCodeModifiedByUser = false;
				updateCodeLive.selected = false;
				updateCodeEditors(true);
				
				selectedLanguage = getSelectedLanguage();
				
				// if HTML preview is visible then dispatch an event to 
				// so that preview can be changed else where
				// needs refactoring
				if (radiate.isPreviewDocumentVisible() && String(selectedLanguage)!=CodeManager.HTML) {
					radiate.dispatchPreviewEvent(sourceData, String(selectedLanguage));
					radiate.openDocument(radiate.selectedDocument);
					radiate.closeDocument(radiate.selectedDocument, true);
				}
				
				isHTML = selectedLanguage==CodeManager.HTML;
				isMXML = selectedLanguage==CodeManager.MXML;
			}
			
			/**
			 * Template editor change handler
			 * */
			private function templateEditorChangeHandler(event:Object = null):void {
				if (settingEditorText) return;
				
				var selectedItem:Object = getSelectedLanguage();
				
				if (selectedItem == CodeManager.HTML) {
					isCodeModifiedByUser = true;
				}
				else {
					isCodeModifiedByUser = false;
				}
				
				updatePreviewDocument();
				
			}
			
			/**
			 * Editor change handler
			 * */
			private function editorChangeHandler(event:Object = null):void {
				if (settingEditorText) return;
				
				var selectedLanguage:String = getSelectedLanguage();
				var code:String;
				
				if (selectedLanguage == CodeManager.HTML) {
					isCodeModifiedByUser = true;
					updatePreviewDocument();
				}
				else if (selectedLanguage == CodeManager.MXML) {
					code = aceEditor.text;
					isCodeModifiedByUser = true;
					importSource(code);
				}
				else {
					isCodeModifiedByUser = false;
				}
				
				
			}
			
			/**
			 * Handle updating preview and set if code is modified by user
			 * */
			public function updatePreviewDocument():void {
				var previewDocument:Object;
				
				if (Radiate.isDesktop) {
					if (updateCodeLive.selected) {
						
						if (radiate.isPreviewDocumentVisible()) {
							//previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
							
							updateTarget(radiate.selectedDocument.instance);
							
							if (previewDocument is UIComponent) {
								//previewDocument.htmlText = wrapInPreview(getTextAreaCode());
							}
							
							//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
						}
						//radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
					}
				}
				else {
					if (updateCodeLive.selected) {
						
						if (radiate.isPreviewDocumentVisible()) {
							previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
							
							if (previewDocument is IFrame) {
								previewDocument.content = sourceData;
							}
							
							//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
						}
						//radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
					}
				}
				
			}
			
			
			/**
			 * 
			 * */
			protected function resyncButton_clickHandler(event:MouseEvent):void {
				isCodeModifiedByUser = false;
				updateCodeEditors(true); // reset the contents of the editors
				
				if (updateCodeLive.selected && radiate.isPreviewDocumentVisible()) {
					updateHTMLPreview();
				}
			}
			
			/**
			 * Updates the code to show the selected item or document
			 * */
			public function updateCodeEditors(dispatchCodeUpdatedEvent:Boolean = false):void {
				var previewDocument:Object;
				var selectedLanguage:String = getSelectedLanguage();
				
				//radiate = Radiate.getInstance();
				
				if (!radiate.target && !radiate.selectedDocument) {
					updateTarget(null);
					return;
				}
				
				
				updateTarget(radiate.target);
				//updateTarget(radiate.selectedDocument.instance);
				
				if (dispatchCodeUpdatedEvent) {
					
					//if (radiate.isPreviewDocumentVisible()) {
					previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
					
					if (previewDocument is IFrame) {
						previewDocument.content = sourceData;
					}
					
					else if (previewDocument is UIComponent) {
						//previewDocument.htmlText = wrapInPreview(sourceData);
					}
						
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					//}
					
					//radiate.dispatchCodeUpdatedEvent(sourceData, HTML, openInSeparateWindow.selected);
					radiate.dispatchCodeUpdatedEvent(sourceData, selectedLanguage, false);
				}
				
				return;
				
			}
			
			/**
			 * Enable or disable live updating as on target change, property change and
			 * user code changes. 
			 * 
			 * If user unchecks and is modified then do not update. 
			 * Resync button will visible for them to update themselves. 
			 * */
			protected function updateCodeLive_changeHandler(event:Event = null):void {
				clearTimeLabel();
				var language:String;
			
				if (updateCodeLive.selected) {
					aceEditor.addEventListener(Event.CHANGE, editorChangeHandler);
					aceCSSEditor.addEventListener(Event.CHANGE, editorChangeHandler);
					templateEditor.addEventListener(Event.CHANGE, templateEditorChangeHandler);
					isCodeModifiedByUser = true;
					updateCodeEditors(true);
					language = getSelectedLanguage();
					radiate.dispatchCodeUpdatedEvent(sourceData, language);
					
					if (language==CodeManager.MXML && aceEditor) {
						importSource(aceEditor.text);
					}
				}
				else {
					aceEditor.removeEventListener(Event.CHANGE, editorChangeHandler);
					aceCSSEditor.removeEventListener(Event.CHANGE, editorChangeHandler);
					templateEditor.addEventListener(Event.CHANGE, templateEditorChangeHandler);
					isCodeModifiedByUser = false;
					updateCodeEditors(true);
					language = getSelectedLanguage();
					radiate.dispatchCodeUpdatedEvent(sourceData, language);
				}
			}
			
			public function getTextAreaCode():String {
				
				return aceEditor.text;	
				
			}
			
			/**
			 * Put the generated code into a text area
			 * */
			public function setEditorText(sourceData:SourceData):void {
				var createEditor:String = "createEditor";
				var result:Object;
			
				settingEditorText = true;
				
				if (aceEditor) {
					
					if (sourceData==null) {
						aceEditor.text = "";
						aceCSSEditor.text = "";
					}
					
					if (setStylesInline.selected) {
						aceEditor.text = sourceData ? sourceData.markup : "";
						aceCSSEditor.text = "";
					}
					else {
						aceEditor.text = sourceData ? sourceData.markup : "";
						aceCSSEditor.text = sourceData ? sourceData.styles : "";
					}
					
					if (templateEditor) {
						templateEditor.validateNow();
						templateEditor.resetUndoHistory();
					}
					
					aceEditor.validateNow();
					aceCSSEditor.validateNow();
					aceEditor.resetUndoHistory();
					aceCSSEditor.resetUndoHistory();
				}
				settingEditorText = false;
				
			}
			
			protected function editorType_changeHandler(event:IndexChangeEvent):void {
				currentState = event.currentTarget.selectedItem.name;
				setEditorText(null);
			}
			
			public function editorChange(value:String = ""):void {
				if (settingEditorText || value==sourceData.source) return;
				updatePreviewDocument();
			}
			
			public function cursorChange(value:String = ""):void {
				//trace("cursor change:" + getTimer());
			}
			
			protected function showBorders_clickHandler(event:MouseEvent):void {
				showBorders = showBordersButton.selected;
				updateCodeEditors(true);
				return;
				
				if (showBorders) {
					showBorderOutline(1);
				}
				else {
					showBorderOutline(0);
				}
			}
			
			public function showBorderOutline(outlineWidth:int):void {
				var previewDocument:Object;
				var borderStyleNode:Object;
				var domWindow:Object;
				
				if (Radiate.isDesktop && radiate.isPreviewDocumentVisible()) {
					previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
					
					if (previewDocument && "domWindow" in previewDocument) {
						domWindow = previewDocument.domWindow;
						borderStyleNode = domWindow.document.borderStyleNode;
					}
					
					if (!borderStyleNode) {
						borderStyleNode = domWindow.document.createElement("style");
						domWindow.document.body.appendChild(borderStyleNode);
					}
					
					borderStyleNode.innerHTML = "*, *:before, *:after { outline:" + outlineWidth + "px dotted red; }";
				}
			}
			
			protected function useSVGButtonClassCheckbox_changeHandler(event:Event):void {
				//useSVGButtonClass = useSVGButtonClassCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function showFullHTMLCheckbox_clickHandler(event:MouseEvent):void {
				//showFullHTMLPageSource = showFullHTMLCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function setStylesInline_clickHandler(event:MouseEvent):void {
				updateCodeEditors(true);
			}
			
			protected function setZoom_clickHandler(event:MouseEvent):void {
				updateCodeEditors(true);
			}
			
			protected function showStyles_clickHandler(event:MouseEvent):void {
				//showStyles = showStylesCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function showBackgroundImageCheckbox_clickHandler(event:MouseEvent):void {
				showBackgroundImage = showBackgroundImageCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function showOriginalSourceLabel_clickHandler(event:MouseEvent):void {
				var selectedDocument:IDocument = radiate.selectedDocument as IDocument;
				
				if (selectedDocument) {
					Radiate.info(selectedDocument.originalSource);
				}
				else {
					Radiate.info("Please select a document");
				}
			}
			
			protected function showProjectSourceLabel_clickHandler(event:MouseEvent):void {
				var selectedProject:IProject = radiate.selectedProject as IProject;
				
				if (selectedProject) {
					Radiate.info(selectedProject.source);
				}
				else {
					Radiate.info("Please select a project");
				}
			}
			
			/**
			 * Get the document code and dispatch a preview event.
			 * 
			 * Got this error: 
			 * WARNING: For content targeting Flash Player version 14 or higher, 
			 * ExternalInterface escapes strings using JSON conventions. To maintain compatibility, 
			 * content published to earlier Flash Player versions continues to use the legacy escaping behavior.
			 * 
			 * Don't know what to do with it but gonna leave it for now. 
			 * */
			protected function previewButton_clickHandler(event:MouseEvent):void {
				var previewDocument:Object;
				
				if (!radiate.selectedDocument) return;
				/*
				if (!isCodeModifiedByUser) {
					var code:String = getDocumentCode(); // puts document code into text area
				}*/
				
				updateHTMLPreview();
			}
			
			public var lastVerticalScrollPosition:int;
			
			public function updateHTMLPreview():void {
				var previewDocument:Object;
				var domWindow:Object;
				var htmlLoader:Object;
				
				if (Radiate.isDesktop) {
					// allow to swap between preview and non preview
					if (!radiate.isPreviewDocumentVisible()) {
						radiate.openDocumentPreview(radiate.selectedDocument, true);
					}
					
					previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
					
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					/*else {
						radiate.openDocument(radiate.selectedDocument);
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, "");
					}*/
					
					/*
					if (previewDocument && "domWindow" in previewDocument && previewDocument.domWindow) {
						domWindow = previewDocument.domWindow;
						
						if (domWindow.document && domWindow.document.body) {
							lastVerticalScrollPosition = domWindow.document.body.scrollTop;
						}
					}*/
					
					// get the vertical scroll position to retain previous position
					if (previewDocument && "htmlLoader" in previewDocument && previewDocument.htmlLoader) {
						htmlLoader = previewDocument.htmlLoader;
						
						lastVerticalScrollPosition = htmlLoader.scrollV;
					}
					
					if (previewDocument is UIComponent && sourceData) {
						//previewDocument.htmlText = wrapInPreview(sourceData.source);
						htmlStartCompleteTime = htmlStartRenderTime = getTimer();
						htmlRenderHandled = htmlCompleteHandled = false;
						
						previewDocument.addEventListener(HTML_RENDER, htmlRenderHandler, false, 0, true);
						previewDocument.addEventListener(HTML_COMPLETE, htmlRenderHandler, false, 0, true);
						
						if (lastVerticalScrollPosition!=0) {
							callLater(updateScrollPositionHandler);
						}
						
						previewDocument.htmlText = sourceData.source;
						
						
						if (previewDocument is IValidator) {
							previewDocument.validateNow(); // prevent editor change event
						}
					}
					
					//updateCodeLive.selected = true;
					//updateCodeLive_changeHandler();
				}
				else {
					// allow to swap between preview and non preview
					if (!radiate.isPreviewDocumentVisible()) {
						radiate.openDocumentPreview(radiate.selectedDocument, true);
						previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
						
						if (previewDocument is IFrame) {
							previewDocument.content = sourceData.source;
						}
						
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					}
					else {
						radiate.openDocument(radiate.selectedDocument);
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, "");
					}
				}
			}
			
			/**
			 * Retain the vertical scroll bar position when updating HTML preview
			 * */
			protected function htmlRenderHandler(event:Event):void {
				var previewDocument:Object;
				var domWindow:Object;
				var htmlLoader:Object;
				var type:String = event.type;
				
				
				if (lastVerticalScrollPosition!=0) {
					updateScrollPositionHandler();
				}
				
				if (type==HTML_RENDER) {
					htmlRenderTime = getTimer()-htmlStartRenderTime;
					htmlRenderHandled = true;
				}
				
				if (type==HTML_COMPLETE) {
					htmlCompleteTime = getTimer()-htmlStartCompleteTime;
					htmlCompleteHandled = true;
				}
				
				previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
				
				if (previewDocument) {
					previewDocument.removeEventListener(event.type, updateScrollPositionHandler);
				}
				
				if (htmlRenderHandled && htmlCompleteHandled) {
					renderTime.text = htmlCompleteTime + "ms, " + htmlRenderTime + "ms  ";
					renderTime.toolTip = htmlCompleteTime + "ms HTML Complete, " + htmlRenderTime + "ms HTML Render";
					//Radiate.callAfter(3000, clearTimeLabel);
				}
			}
			
			/**
			 * Clears the time text
			 * */
			public function clearTimeLabel():void {
				if (htmlRenderHandled && htmlCompleteHandled) {
					renderTime.text = "";
				}
			}
			
			/**
			 * Retain the vertical scroll bar position when updating HTML preview
			 * */
			protected function updateScrollPositionHandler(event:Event = null):void {
				var previewDocument:Object;
				var domWindow:Object;
				var htmlLoader:Object;
				
				previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
				
				if (previewDocument && "htmlLoader" in previewDocument && previewDocument.htmlLoader) {
					//previewDocument.removeEventListener("complete", updateScrollPositionHandler);
					previewDocument.htmlLoader.scrollV = lastVerticalScrollPosition;
				}
				
			}
			
			protected function editorViewOptionButtons_clickHandler(event:MouseEvent):void
			{
				var selectedItem:Object = editorViewOptionButtons.selectedItem;
				var view:String = selectedItem ? selectedItem.value.toLowerCase() : "markup";
				//editorViewOptionButtons.selectedIndex = 0;
				//editorViewOptionButtons.validateNow();
				//editorViewOptionButtons.selectedIndex = event.index;
				editorViewOptionButtons.invalidateProperties();
				
				updateEditorOptions(view);
			}
			
			protected function editorOptionsLinkBarHandler(event:ItemClickEvent):void
			{
				var selectedItem:Object = event.item;
				var view:String = selectedItem ? selectedItem.value.toLowerCase() : "markup";
				//editorViewOptionButtons.selectedIndex = 0;
				//editorViewOptionButtons.validateNow();
				//editorViewOptionButtons.selectedIndex = event.index;
				editorViewOptionButtons.invalidateProperties();
				//editorViewOptionButtons.styleChanged(null);
				updateEditorOptions(view);
			}
			
			protected function updateEditorOptions(view:String ="markup"):void {
				
				// markup 
				if (view=="markup") {
					aceEditor.includeInLayout = aceEditor.visible = true;
					aceCSSEditor.includeInLayout = aceCSSEditor.visible = false;
				}
				else if (view=="css") {
					aceEditor.includeInLayout = aceEditor.visible = false;
					aceCSSEditor.includeInLayout = aceCSSEditor.visible = true;
				}
				else {
					aceEditor.includeInLayout = aceEditor.visible = true;
					aceCSSEditor.includeInLayout = aceCSSEditor.visible = true;
				}
			}
			
			private function getSelectedLanguage():String
			{
				return languageTypeButtons.selectedItem;
			}
			/*
			private function languageTypeLinkBar_changeHandler():void {
				var tempSelectedIndex:Number = languageTypeButtons.selectedIndex;
				
				for (var i:int; i<languageTypes.length;i++) {
					languageTypeButtons.selectedIndex = i;
					languageTypeButtons.validateNow();
				}
				
				languageTypeButtons.selectedIndex = tempSelectedIndex;
			}*/
			
			protected function resetTemplateButton_clickHandler(event:MouseEvent):void {
				var iDocument:IDocument = radiate.selectedDocument;
				var showTemplate:Boolean = editTemplateButton.selected;
				
				if (iDocument) {
					Radiate.revertDocumentTemplate(iDocument);
				}
					
				if (templateEditor && iDocument) {
					templateEditor.text = iDocument.template;
				}
			}
			
			protected function editTemplateButton_clickHandler(event:MouseEvent):void {
				var iDocument:IDocument = radiate.selectedDocument;
				var showTemplate:Boolean = editTemplateButton.selected;
				
				if (iDocument==null) {
					return;
				}
				
				if (templateEditor && showTemplate) {
					editingTemplate = true;
					templateEditor.text = iDocument.template ? iDocument.template : basicTemplate;
					templateEditor.visible = showTemplate;
					templateEditor.includeInLayout = showTemplate;
				}
				else {
					editingTemplate = false;
					iDocument.template = templateEditor.text;
					templateEditor.visible = showTemplate;
					templateEditor.includeInLayout = showTemplate;
				}
			}
			
			protected function uncaughtExceptionEvent(event:RadiateEvent):void
			{
				//trace("Uncaught Exception Event: " + event);
			}
			
			public var FIND:String = "find";
			
			private function createEditors():void {
				enableWordWrapButton.selected = enableWordWrap;
				embedImagesButton.selected = embedImages;
				
				// 1067: Implicit coercion of a value of type com.flexcapacitor.controls:AceEditor to an unrelated type Object
				
				aceEditorCreated = true;
				aceCSSEditorCreated = true;
				aceTemplateEditorCreated = true;
				
			}
			
			private var lastFocusedEditor:Object;
			
			private function editorFocusInHandler(event:FocusEvent):void
			{
				lastFocusedEditor = event.currentTarget;
				searchInput.aceEditor = lastFocusedEditor;
				
				if (enableWordWrapButton) {
					enableWordWrapButton.selected = lastFocusedEditor.useWordWrap;
				}
			}
			
			private function editorFindHandler(event:Event):void
			{
				lastFocusedEditor = event.currentTarget;
				searchInput.aceEditor = lastFocusedEditor;
				lastFocusedEditor.blur();
				searchInput.setFocus();
				
			}
			
			
			protected function embedImageButton_clickHandler(event:MouseEvent):void {
				var language:String = getSelectedLanguage();
				var exporter:TranscoderDescription = CodeManager.getExporter(language);
				
				if ("embedImages" in exporter.exporter) {
					// we set it when we generate code
					//Object(exporter.exporter).embedImages = embedImagesButton.selected;
				}
			}
			
			protected function wordwrapButton_clickHandler(event:MouseEvent):void
			{
				if (lastFocusedEditor) {
					lastFocusedEditor.useWordWrap = enableWordWrapButton.selected;
				}
				else if (aceEditor) {
					aceEditor.useWordWrap = enableWordWrapButton.selected;
				}
			}
			
			protected function showChildDescriptors_clickHandler(event:MouseEvent):void
			{
				updateCodeEditors(true);
			}
			
			protected function handleDocumentClosed(event:Event):void
			{
				
			}
			protected function importButton_clickHandler(event:MouseEvent):void {
				var code:String = aceEditor.text;
				
				importSource(code);
			}
			
			protected function importSource(code:String):void {
				var sourceData:SourceData;
				var validationInfo:XMLValidationInfo;
				var selectedDocument:IDocument = radiate.selectedDocument;
				var selectedProject:IProject = radiate.selectedProject;
				var container:Object;
				var importedTargets:Array;
				var currentTarget:Object;				
				var componentDescription:ComponentDescription;
				var parentComponentDescription:ComponentDescription;
				var currentIndex:int = -1;
				var dropIndex:int;
				var parentInstance:Object;
				var namespaces:Object;
				var namespacesString:String;
				var xml:XML;
				var errorLocation:String;
				var isValid:Boolean;
				var message:String;
				var rootString:String;
				var rootNodeName:String = MXMLDocumentConstants.ROOT_NODE_NAME;
				var updatedCode:String;
				var error:Object;
				var stringMethod:Boolean = true;
				var mxmlRenderTime:int;
				
				// NOTE: 
				// this is importing on the fly and then removing a reference to the last target
				// this may be expensive not sure 
				// 
				// in time it would be better to check for attributes that have changed 
				// and only apply those
				// we would have to keep an updated XML reference
				// then we could use compare to find the attributes or child nodes on the selected 
				// node that have changed
				// see the LiveMXMLEditor for some initial work
				
				if (selectedDocument==null || selectedProject==null) {
					Radiate.warn("Please open a document before importing");
					return;
				}
				
				/*
				results = XMLUtils.getXMLFromStringWithNamespaces(code, MXMLDocumentConstants.getNamespaces());
				validationInfo = results as XMLValidationInfo;
				xml = results as XML;*/

				
				mxmlRenderTime = getTimer();
				isValid = XMLUtils.isValidXML(code);
				var browserErrorMessage:String;
				//error = XMLUtils.validationError;
				
				if (!isValid && code!="") {
					validationInfo = XMLUtils.validateXML(code, true);
					error = validationInfo.error;
					browserErrorMessage = validationInfo.browserErrorMessage;
					
					if (error is TypeError && error.errorID==1083 || namespaceError==browserErrorMessage) {
						
						if (stringMethod) {
							namespaces = MXMLDocumentConstants.getNamespaces();
							updatedCode = XMLUtils.addNamespacesToXMLString(code, namespaces);
						}
						else {
							namespacesString = MXMLDocumentConstants.getDefaultNamespaceDeclarations();
							//updatedCode = XMLUtils.getXMLFromStringWithNamespaces(code, namespacesString);
							
							rootString = '<'+rootNodeName + " " + namespacesString +'>';
							updatedCode = rootString + code + "</"+rootNodeName+">";
						}
						
						isValid = XMLUtils.isValidXML(updatedCode);
						
						if (isValid) {
							hideMessage();
						}
					}
					
					if (!isValid) {
						message = XMLUtils.validationError ? "" +  validationInfo.internalErrorMessage : warningMessage;
						if (message==null && validationInfo.browserErrorMessage!==null) {
							message = validationInfo.browserErrorMessage;
						}
						errorLocation = "At line " + (validationInfo.row) + " column " + validationInfo.column+ ":";
						showMessage(errorLocation, message, validationInfo.row-1, validationInfo.column);
						
						renderTime.text = "";
						renderTime.toolTip = "";
						return;
					}
				}
				else {
					hideMessage();
				}
				
				
				lastTarget = radiate.target;
				componentDescription = selectedDocument.getItemDescription(lastTarget);
				parentComponentDescription = componentDescription ? componentDescription.parent: null;
				
				if (parentComponentDescription && parentComponentDescription.instance) {
					parentInstance = parentComponentDescription.instance as IVisualElementContainer;
					currentIndex = parentComponentDescription.children.getItemIndex(componentDescription);
					
					if (currentIndex<parentComponentDescription.children.length-1) {
						
						if ("layout" in parentInstance && parentInstance.layout is BasicLayout) { 
							dropIndex = currentIndex + 1;
						}
						else {
							dropIndex = currentIndex + 2;
						}
					}
					
					//currentIndex = Math.max(0, currentIndex-1);
				}
				
				if (lastTarget) {
					Radiate.removeElement(lastTarget);
				}
				
				try {
					sourceData = radiate.importMXMLDocument(selectedProject, selectedDocument, code, parentInstance as IVisualElement, currentIndex);
				}
				catch (importError:Error) {
					HistoryManager.undo(selectedDocument);
					message = importError.toString();
					showMessage(errorLocation, message);
				}
				
				if (sourceData) {
					// move to correct location
					/*
					HistoryManager.disableHistoryManagement = true;
					for (var i:int = 0; i < importedTargets.length; i++) {
						currentTarget = importedTargets[i];
						
						Radiate.moveElement2(currentTarget, parentInstance, null, 
							null, RadiateEvent.MOVE_ITEM, AddItems.LAST, null, dropIndex);
						
					}
					
					HistoryManager.disableHistoryManagement = false;*/
					parentInstance = null;
					lastTarget = null;
					
					HistoryManager.mergeLastHistoryEvent(selectedDocument, "Updated source");
					Radiate.setTargets(sourceData.targets);
					hideMessage();
				}
				else {
					validationInfo = XMLUtils.validateXML(code);
					error = validationInfo.error;
					
					if (error is TypeError && error.errorID==1083) {
						namespaces = MXMLDocumentConstants.getNamespaces();
						namespacesString = MXMLDocumentConstants.getDefaultNamespaceDeclarations();
						
						if (stringMethod) {
							updatedCode = XMLUtils.addNamespacesToXMLString(code, namespaces);
						}
						else {
							rootString = '<'+rootNodeName + " " + namespacesString +'>';
							updatedCode = rootString + code + "</"+rootNodeName+">";
						}
						
						isValid = XMLUtils.isValidXML(updatedCode);
						
						if (isValid) {
							hideMessage();
						}
					}
					
					message = XMLUtils.validationError ? "" +  validationInfo.internalErrorMessage : warningMessage;
					
					
					errorLocation = "At line " + (validationInfo.row) + " column " + validationInfo.column+ ":";
					showMessage(errorLocation, message, validationInfo.row-1, validationInfo.column);
				
					renderTime.text = "";
					renderTime.toolTip = "";
				}
				
				mxmlRenderTime = getTimer()-mxmlRenderTime;
				
				if (sourceData) {
					renderTime.text = mxmlRenderTime + "ms";
					renderTime.toolTip = mxmlRenderTime + "ms";
				}
				else {
					renderTime.text = "";
					renderTime.toolTip = "";
				}
			}
			
			
			public var warningMessage:String = "Warning: XML is invalid and may not import correctly.";

			public var namespaceError:String = "XML Parsing Error: prefix not bound to a namespace";
			
			public function showMessage(firstMessage:String, secondMessage:String = null, row:int = -1, column:int = 0):void {
				lineError.text = firstMessage;
				warningLabel.text = secondMessage;
				errorGroup.visible = true;
				errorGroup.includeInLayout = true;
				aceEditor.clearAnnotations();
				aceEditor.setAnnotation(row, column, secondMessage, "error");
				editorGroup.bottom = 20;
			}
			
			public function hideMessage():void {
				errorGroup.visible = false;
				errorGroup.includeInLayout = false;
				lineError.text = "";
				warningLabel.text = "";
				
				if (aceEditor.aceFound) {
					aceEditor.clearAnnotations();
				}
				editorGroup.bottom = 0;
			}
		]]>
	</fx:Script>
	
	<fx:Declarations>
		
		<handlers:EventHandler eventName="click" target="{copyIcon}" setTriggerEvent="true">
			
			<core:GetDataFromTarget target="{sourceData}" targetPropertyName="source"/> 
			<core:CopyPreviousToNext />
			<clipboard:CopyToClipboard targetAncestor="{this}" 
									   allowNullData="true" 
									   success="Radiate.info('Code copied to the clipboard')"
									   noData="Radiate.info('Nothing to copy to the clipboard')"
									   error="Radiate.info('An error occurred while attempting to copy to the clipboard')"
									   >
			</clipboard:CopyToClipboard>
			
		</handlers:EventHandler>
		
		<!--- 
		adds zoom css for replicating preview
		-->
		<fx:String id="zoomCSS">
			<![CDATA[
IFRAME_ID {
    zoom: ZOOM_VALUE;
    -moz-transform: scale(ZOOM_VALUE);
    -moz-transform-origin: 0 0;
    -o-transform: scale(ZOOM_VALUE);
    -o-transform-origin: 0 0;
    -webkit-transform: scale(ZOOM_VALUE);
    -webkit-transform-origin: 0 0;
}
]]>
		</fx:String>
		
		
		<!-- If you use .button it causes sizing issues where the size of the button is 0 
		Firefox: 
		Paste the following code into the editor after all other html code (from style tag to style tag).
		And the class of the HTML button is set to class="button"
		
		Fix: 
		Rename "button" to "buttonSkin" and set class="buttonSkin". In time this will point to actual skins and defined styles.
		Look at buttonCSS2. 
		-->
		<fx:String id="buttonCSS">
			<![CDATA[
.button {
	position: absolute;
	background: url(assets/svg/button_skin_up.svg) 0 0 no-repeat;
	border: 0px;
}

.button:hover {
	background: url(assets/svg/button_skin_over.svg) 0 0 no-repeat;
}

.button:active {
	background: url(assets/svg/button_skin_down.svg) 0 0 no-repeat;
}
]]>
		</fx:String>
		
		
		<fx:String id="buttonCSS2">
			<![CDATA[
.buttonSkin {
	background: url(assets/svg/button_skin_up.svg) 0 0 no-repeat;
	border: 0px;
}

.buttonSkin:hover {
	background: url(assets/svg/button_skin_over.svg) 0 0 no-repeat;
	border: 0px;
}

.buttonSkin:active {
	background: url(assets/svg/button_skin_down.svg) 0 0 no-repeat;
	border: 0px;
}
]]>
		</fx:String>
		
		<s:ArrayList id="editorViewOptions">
			<fx:Array>
				<fx:Object label="Markup" value="markup"/>
				<fx:Object label="CSS" value="css"/>
				<fx:Object label="Markup+CSS" value="markupcss"/>
			</fx:Array>
		</s:ArrayList>
		
		<s:ArrayList id="languageTypes">
			<fx:String>{CodeManager.MXML}</fx:String>
			<fx:String>{CodeManager.HTML}</fx:String>
			<fx:String>{CodeManager.ANDROID}</fx:String>
		</s:ArrayList>
	</fx:Declarations>
	
	<s:states>
		<s:State name="normal"/>
	</s:states>
	
	
	<mx:HDividedBox id="editorGroup" 
					top="30" 
					width="100%" 
					height="100%" 
					liveDragging="true">
		
		<c:AceEditor id="templateEditor" 
					 width="100%" 
					 height="100%"
					 mode="ace/mode/html" 
					 showFoldWidgets="true" 
					 margin="{editorMargin}"
					 focusIn="editorFocusInHandler(event)"
					 find="editorFindHandler(event)"
					 scrollSpeed=".5"
					 useWordWrap="{enableWordWrap}"
					 visible="false"
					 includeInLayout="false"
					 />
		
		<c:AceEditor id="aceEditor" 
					 width="100%" 
					 height="100%"
					 mode="ace/mode/xml" 
					 showFoldWidgets="true" 
					 margin="{editorMargin}"
					 focusIn="editorFocusInHandler(event)"
					 find="editorFindHandler(event)"
					 scrollSpeed=".5"
					 useWordWrap="{enableWordWrap}"
					 />
		
		<c:AceEditor id="aceCSSEditor" 
					 width="100%" 
					 height="100%"
					 mode="ace/mode/css" 
					 showFoldWidgets="true" 
					 margin="{editorMargin}"
					 focusIn="editorFocusInHandler(event)"
					 find="editorFindHandler(event)"
					 scrollSpeed=".5"
					 useWordWrap="{enableWordWrap}"
					 visible="false"
					 includeInLayout="false"
					 />
		
	</mx:HDividedBox>
	
	
	<!-- FIRST ROW -->
	<s:HGroup left="0" right="0" 
			  width="100%"
			  clipAndEnableScrolling="true" 
			  paddingLeft="6" 
			  paddingRight="10"
			  verticalAlign="middle"
			  fontSize="9"
			  >
		
		<c:BeveledImageButton id="resetTemplateButton"
							  source="{Radii8LibraryAssets.refresh}"
							  toolTip="Reset template code"
							  click="resetTemplateButton_clickHandler(event)"
							  visible="{editTemplateButton.selected}"
							  includeInLayout="{editTemplateButton.selected}"
							  />
		
		<c:SolidFillButtonBar id="editorViewOptionButtons" 
					 requireSelection="true"
					 labelField="label"
					 toolTip="Select the code editors to view"
					 dataProvider="{editorViewOptions}"
					 click="editorViewOptionButtons_clickHandler(event)">
		</c:SolidFillButtonBar>
		
		<c:SolidFillButtonBar id="languageTypeButtons" 
					 selectedIndex="0"
					 toolTip="Select the language to generate"
					 click="languageType_changeHandler(null)"
					 dataProvider="{languageTypes}">
		</c:SolidFillButtonBar>
		
		<c:SolidFillToggleButton id="editTemplateButton" 
								 label="Edit Template" 
								 toolTip="Edit the webpage template"
								 visible="{isHTML}"
								 includeInLayout="{isHTML}"
								 click="editTemplateButton_clickHandler(event)"/>
		
		<!--<mx:LinkBar id="languageTypeLinkButtons"
					itemClick="languageTypeLinkBar_changeHandler()"
					selectionColor="0xFF0000"
					disabledColor="0x00FF00"
					dataProvider="{languageTypes}">
		</mx:LinkBar>-->
		
		<c:BeveledImageButton id="importButton"
							  source="{Radii8LibraryAssets.importInto}"
							  toolTip="Import MXML"
							  click="importButton_clickHandler(event)"
							  visible="{isMXML}"
							  includeInLayout="{isMXML}"
							  />
		
		
		<c:BeveledImageButton id="openDocumentInInternalWebIcon" 
							  source="{Radii8LibraryAssets.documentPlayIcon}" 
							  toolTip="View document inline with internal web browser"
							  smoothingQuality="high"
							  smooth="true"
							  width="18"
							  height="10"
							  visible="{isHTML}"
							  includeInLayout="{isHTML}"
							  click="previewButton_clickHandler(event)" 
							  />
		
		<!--<c:BeveledImageButton id="previewButton"
							  source="{Radii8LibraryToolAssets.Launch}"
							  toolTip="Preview in a browser"
							  enabled="{isHTML}" 
							  visible="{isHTML}"
							  includeInLayout="{isHTML}"
							  click="previewButton_clickHandler(event)"
							  />-->
		
		<c:BeveledImageToggleButton id="enableWordWrapButton"
							  source="{Radii8LibraryAssets.wordWrap}"
							  toolTip="Word wrap"
							  width="20"
							  height="16"
							  scaleMode="letterbox"
							  click="wordwrapButton_clickHandler(event)"
							  showBackgroundWhenSelected="true"
							  />
		
		<c:BeveledImageToggleButton id="embedImagesButton"
							  source="{Radii8LibraryAssets.image}"
							  toolTip="Embed image bitmap data"
							  width="20"
							  height="16"
							  scaleMode="letterbox"
							  click="embedImageButton_clickHandler(event)"
							  showBackgroundWhenSelected="true"
							  visible="false"
							  includeInLayout="false"
							  />
		
		
		<c:BeveledImageToggleButton id="showChildDescriptors"
									source="{Radii8LibraryAssets.treeViewOpen}"
									toolTip="Show nested elements"
									click="showChildDescriptors_clickHandler(event)"
									width="20"
									height="16"
									scaleMode="letterbox"
									showBackgroundWhenSelected="true"/>
		
		<c:BeveledImageButton id="resyncButton"
							  source="{Radii8LibraryAssets.refresh}"
							  toolTip="Revert to original code"
							  click="resyncButton_clickHandler(event)"
							  visible="{isHTML}"
							  includeInLayout="{isHTML}"
							  />
		
		<s:CheckBox id="updateCodeLive" 
					selected="false"
					label="Live"
					toolTip="Edit code live (experimental)"
					visible="{isHTML || isMXML}"
					includeInLayout="{isHTML || isMXML}"
					change="updateCodeLive_changeHandler(event)"/>
		
		<!-- enabled="{isCodeModifiedByUser}" -->
		<!-- enabled="{isCodeModifiedByUser}" -->
		
		<s:CheckBox id="showBackgroundImageCheckbox" 
					selected="false"
					label="Background Image"
					toolTip="Show a background screenshot image in the preview for comparison (experimental)"
					visible="{false}"
					includeInLayout="{false}"
					click="showBackgroundImageCheckbox_clickHandler(event)"/>
		
		<s:CheckBox id="setStylesInline" 
					selected="false"
					label="Styles inline"
					toolTip="Define styles in the markup"
					visible="{isHTML}"
					includeInLayout="{isHTML}"
					click="setStylesInline_clickHandler(event)"/>
		
		<s:CheckBox id="showBordersButton" 
					selected="false"
					label="Borders"
					toolTip="Show borders around elements"
					visible="{isHTML}"
					includeInLayout="{isHTML}"
					click="showBorders_clickHandler(event)"/>
		
		<s:Label id="renderTime" paddingTop="4" />
		
		<!--
		<s:Group id="redrawButton" 
				 click="showBorders_clickHandler(event)"
				 >
			<s:Rect id="fill" width="20" height="20" >
				<s:fill>
					<s:SolidColor color="#585858"/>
				</s:fill>
				<s:stroke>
					<s:SolidColorStroke id="strokeColor" color="#585858" weight="2"/>
				</s:stroke>
			</s:Rect>
			<s:Rect id="stroke" top="2" left="2" right="2" bottom="2">
				<s:stroke>
					<s:SolidColorStroke color="#FFFFFF" />
				</s:stroke>
			</s:Rect>
		</s:Group>-->
		
		<s:Spacer width="100%"/>
		
		<c:AceSearchTextInput id="searchInput" 
						   prompt="Search" 
						   minWidth="100"
						   width="100%"
						   focusAlpha="0"/>
		
		<c:BeveledImageButton id="copyIcon" 
					   source="{Radii8LibraryAssets.copy}" 
					   toolTip="Copy the code to the Clipboard"
					   verticalAlign="middle"
					   useHandCursor="true"
					   />
	</s:HGroup>
	
	
	<s:HGroup id="errorGroup" width="100%" verticalAlign="middle" 
			  bottom="5" left="5"
			  includeInLayout="false" visible="false">
		<s:Label id="lineError" 
				 x="15" y="15" 
				 text="" 
				 fontWeight="bold" 
				 color="red"/>
		
		<s:Label id="warningLabel" 
				 x="15" y="15" 
				 text="" 
				 fontWeight="bold" 
				 color="red"
				 width="100%"
				 maxDisplayedLines="1"/>
	</s:HGroup>
	
	
</s:Group>