<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 xmlns:c="com.flexcapacitor.controls.*"
		 xmlns:handlers="com.flexcapacitor.handlers.*" 
		 xmlns:clipboard="com.flexcapacitor.effects.clipboard.*" 
		 xmlns:core="com.flexcapacitor.effects.core.*" 
		 xmlns:status="com.flexcapacitor.effects.status.*" 
		 xmlns:flexiframe="com.google.code.flexiframe.*"
		 xmlns:controls="com.riaspace.controls.*"
		 xmlns:ns="http://www.flexcapacitor.com/flex/2015" 
		 
		 minWidth="200" 
		 minHeight="100"
		 implements="com.flexcapacitor.views.IInspector" 
		 >
	
	
	<fx:Script>
		<![CDATA[
			import com.flexcapacitor.controller.Radiate;
			import com.flexcapacitor.events.RadiateEvent;
			import com.flexcapacitor.managers.CodeManager;
			import com.flexcapacitor.model.ExportOptions;
			import com.flexcapacitor.model.HTMLExportOptions;
			import com.flexcapacitor.model.IDocument;
			import com.flexcapacitor.model.IProject;
			import com.flexcapacitor.model.Settings;
			import com.flexcapacitor.model.SourceData;
			import com.flexcapacitor.utils.AceEditorUtils;
			import com.flexcapacitor.utils.DisplayObjectUtils;
			import com.flexcapacitor.utils.supportClasses.ComponentDescription;
			import com.google.code.flexiframe.IFrame;
			
			import mx.core.UIComponent;
			import mx.events.ItemClickEvent;
			import mx.validators.IValidator;
			
			import spark.events.IndexChangeEvent;
			
			/**
			 * Reference to Radiate
			 * */
			public var radiate:Radiate;
			
			/**
			 * Basic HTML template
			 * */
			public var basicTemplate:String;
			
			/**
			 * Indicates when the user has typed in the text area
			 * */
			[Bindable]
			public var isCodeModifiedByUser:Boolean;
			
			/**
			 * Show borders around HTML elements
			 * */
			public var showBorders:Boolean;
			
			/**
			 * Use SVG button class
			 * */
			public var useSVGButtonClass:Boolean = true;
			
			/**
			 * Show full HTML page source
			 * */
			public var showFullHTMLPageSource:Boolean = true;
			
			/**
			 * Create screen shot and add as background image of HTML page 
			 * */
			public var showBackgroundImage:Boolean = false;
			
			/**
			 * Indicates if XML is invalid
			 * */
			public var isValid:Boolean;
			
			public var aceEditor:*;
			public var aceCSSEditor:*;
			public var templateEditor:*;

			public var editorMargin:String = "28px 0 8px 0px";
			
			public var settingEditorText:Boolean;
			public var editingTemplate:Boolean;
			
			
			private var options:ExportOptions;
			
			[Bindable]
			public var isHTML:Boolean;
			
			/**
			 * Last source data
			 * */
			[Bindable]
			public var sourceData:SourceData;
			
			public var lastTextAreaValue:String;
			
			public var aceEditorCreated:Boolean;
			public var aceCSSEditorCreated:Boolean;
			public var aceTemplateEditorCreated:Boolean;
			
			public function activate():void {
				radiate = Radiate.getInstance();
				
				addListeners();
				
				if (Radiate.isDesktop) {
					currentState = "desktop";
					
					if (aceEditor==null) {
						createEditors();
						
						updateEditorOptions();
					}
				}
				
				if (basicTemplate==null) {
					basicTemplate = new Radii8LibraryTranscodersAssets.basicHTMLDocumentReusable();
				}
				
				if (showChildDescriptors) {
					showChildDescriptors.selected = true;
				}
				
				if (radiate.isDocumentPreviewOpen(radiate.selectedDocument)) {
					languageTypeButtons.selectedItem = CodeManager.HTML;
				}
				
				if (radiate.target) {
					updateCodeEditors();
				}
			}
			
			public function deactivate():void {
				removeListeners();
			}
			
			public function addListeners():void {
				radiate.addEventListener(RadiateEvent.TARGET_CHANGE, handleTargetChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.PROPERTY_CHANGED, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.MOVE_ITEM, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.ADD_ITEM, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.REMOVE_ITEM, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.HISTORY_CHANGE, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.DOCUMENT_CHANGE, handleDocumentChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.UNCAUGHT_EXCEPTION_EVENT, uncaughtExceptionEvent, false, 0, true);
			}
			
			public function removeListeners():void {
				if (radiate) {
					radiate.removeEventListener(RadiateEvent.TARGET_CHANGE, handleTargetChange);
					radiate.removeEventListener(RadiateEvent.PROPERTY_CHANGED, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.MOVE_ITEM, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.ADD_ITEM, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.REMOVE_ITEM, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.HISTORY_CHANGE, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.DOCUMENT_CHANGE, handleDocumentChange);
					radiate.removeEventListener(RadiateEvent.UNCAUGHT_EXCEPTION_EVENT, uncaughtExceptionEvent);
				}
			}
			
			/**
			 * Generate the code for the provided target component. 
			 * */
			public function updateTarget(target:Object):void {
				var iDocument:IDocument = radiate.selectedDocument;
				var targetDescription:ComponentDescription;
				var language:String = getSelectedLanguage();
				var output:String = "";
				var xml:XML;
				
				if (target==null) {
					target = iDocument.instance;
				}
				
				if (editingTemplate) {
					iDocument.template = templateEditor.text;
				}
				
				targetDescription = DisplayObjectUtils.getTargetInComponentDisplayList(target, iDocument.componentDescription);
				
				if (language==null || targetDescription==null) {
					sourceData = null;
					radiate.editorSource = null;
					setEditorText(null);
					return;
				}
				
				
				if (language == CodeManager.HTML) {
					//if (!htmlOptions) {
					var htmlOptions:HTMLExportOptions;
					htmlOptions = CodeManager.getExportOptions(language) as HTMLExportOptions;
					//}
					
					//htmlOptions.template = html5boilerplate;
					//htmlOptions.bordersCSS = bordersCSS;
					htmlOptions.showBorders = showBorders;
					//htmlOptions.useBorderBox = useBoderBox;
					htmlOptions.useInlineStyles = setStylesInline.selected;
					htmlOptions.template = iDocument.template;
					htmlOptions.disableTabs = true;
					htmlOptions.useExternalStylesheet = false;
					htmlOptions.exportChildDescriptors = showChildDescriptors.selected;
					htmlOptions.reverseInitialCSS = true;
					
					if (updateCodeLive.selected && isCodeModifiedByUser) {
						htmlOptions.useCustomMarkup = true;
						htmlOptions.markup = aceEditor.text;
						htmlOptions.styles = aceCSSEditor.text;
					}
					else {
						htmlOptions.useCustomMarkup = false;
						htmlOptions.markup = "";
						htmlOptions.styles = "";
					}
					
					options = htmlOptions;
				}
				else if (language == CodeManager.MXML) {
					options = CodeManager.getExportOptions(language) as ExportOptions;
					options.template = "";
					options.exportChildDescriptors = showChildDescriptors.selected;
					//options = null;
				}
				else if (language == CodeManager.ANDROID) {
					options = CodeManager.getExportOptions(language) as ExportOptions;
					options.template = "";
					//options = null;
				}
				
				sourceData = CodeManager.getSourceData(target, iDocument, language, options);
				
				output = sourceData.source;
				radiate.editorSource = sourceData;
				iDocument.errors = sourceData.errors;
				iDocument.warnings = sourceData.warnings;
				
				//if (radiate.isPreviewDocumentVisible() && updateCodeLive.selected && isCodeModifiedByUser) {
				if (updateCodeLive.selected && isCodeModifiedByUser) {
					updateHTMLPreview();
				}
				else {
					setEditorText(sourceData);
					
					if (radiate.isPreviewDocumentVisible()) {
						updateHTMLPreview();
					}
				}
				
				radiate.dispatchPreviewEvent(sourceData, language);
			}
			
			/**
			 * Handle target change
			 * */
			protected function handleTargetChange(event:RadiateEvent):void {

				// if code is not modified by the user 
				// and show selection 
				// we only want to update the view on selection change when we are 
				// paying attention when we have show selected component code option enabled
				if (!isCodeModifiedByUser) {
					updateCodeEditors();
				}
				else if (updateCodeLive.selected && radiate.isPreviewDocumentVisible()) {
					updateCodeEditors(true);
					updateHTMLPreview();
				}
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML);
				}
			}
			
			/**
			 * Updates the code when the document changes. 
			 * */
			protected function handleDocumentChange(event:RadiateEvent):void {
				var selectedDocument:IDocument = IDocument(event.selectedItem);
				
				
				if (radiate.isPreviewDocumentVisible()) {
					//return;
				}
				
				if (!isCodeModifiedByUser) {
					updateCodeEditors(true);
				}
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML);
				}
			}
			
			/**
			 * Updates the code when a property change happens. 
			 * If the text has been modified by the user then we don't update the code.
			 * They have to press the resync button. 
			 * */
			protected function handlePropertyChange(event:RadiateEvent):void {
				
				if (!isCodeModifiedByUser) {
					updateCodeEditors(true);
				}
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML);
				}
			}
			
			/**
			 * Updates the code to reflect the selected language 
			 * */
			protected function languageType_changeHandler(event:IndexChangeEvent):void {
				isCodeModifiedByUser = false;
				updateCodeLive.selected = false;
				updateCodeEditors(true);
				var selectedLanguage:Object = getSelectedLanguage();
				
				// if HTML preview is visible then dispatch an event to 
				// so that preview can be changed else where
				// needs refactoring
				if (radiate.isPreviewDocumentVisible() && String(selectedLanguage)!=CodeManager.HTML) {
					radiate.dispatchPreviewEvent(sourceData, String(selectedLanguage));
					radiate.openDocument(radiate.selectedDocument);
					radiate.closeDocument(radiate.selectedDocument, true);
				}
				
				isHTML = selectedLanguage==CodeManager.HTML;
			}
			
			/**
			 * Template editor change handler
			 * */
			private function templateEditorChangeHandler(event:Object = null):void {
				if (settingEditorText) return;
				
				var selectedItem:Object = getSelectedLanguage();
				
				if (selectedItem == CodeManager.HTML) {
					isCodeModifiedByUser = true;
				}
				else {
					isCodeModifiedByUser = false;
				}
				
				updatePreviewDocument();
				
			}
			
			/**
			 * Editor change handler
			 * */
			private function editorChangeHandler(event:Object = null):void {
				if (settingEditorText) return;
				
				var selectedItem:Object = getSelectedLanguage();
				
				if (selectedItem == CodeManager.HTML) {
					isCodeModifiedByUser = true;
				}
				else {
					isCodeModifiedByUser = false;
				}
				
				updatePreviewDocument();
				
			}
			
			/**
			 * Handle updating preview and set if code is modified by user
			 * */
			public function updatePreviewDocument():void {
				var previewDocument:Object;
				
				if (Radiate.isDesktop) {
					if (updateCodeLive.selected) {
						
						if (radiate.isPreviewDocumentVisible()) {
							//previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
							
							updateTarget(radiate.selectedDocument.instance);
							
							if (previewDocument is UIComponent) {
								//previewDocument.htmlText = wrapInPreview(getTextAreaCode());
							}
							
							//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
						}
						//radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
					}
				}
				else {
					if (updateCodeLive.selected) {
						
						if (radiate.isPreviewDocumentVisible()) {
							previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
							
							if (previewDocument is IFrame) {
								previewDocument.content = sourceData;
							}
							
							//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
						}
						//radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
					}
				}
				
			}
			
			
			/**
			 * 
			 * */
			protected function resyncButton_clickHandler(event:MouseEvent):void {
				isCodeModifiedByUser = false;
				updateCodeEditors(true); // reset the contents of the editors
				
				if (updateCodeLive.selected && radiate.isPreviewDocumentVisible()) {
					updateHTMLPreview();
				}
			}
			
			/**
			 * Updates the code to show the selected item or document
			 * */
			public function updateCodeEditors(dispatchCodeUpdatedEvent:Boolean = false):void {
				var previewDocument:Object;
				
				//radiate = Radiate.getInstance();
				
				if (!radiate.target && !radiate.selectedDocument) return;
				
				
				updateTarget(radiate.target);
				//updateTarget(radiate.selectedDocument.instance);
				
				if (dispatchCodeUpdatedEvent) {
					
					//if (radiate.isPreviewDocumentVisible()) {
					previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
					
					if (previewDocument is IFrame) {
						previewDocument.content = sourceData;
					}
					
					else if (previewDocument is UIComponent) {
						//previewDocument.htmlText = wrapInPreview(sourceData);
					}
						
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					//}
					
					//radiate.dispatchCodeUpdatedEvent(sourceData, HTML, openInSeparateWindow.selected);
					radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML, false);
				}
				
				return;
				
			}
			
			/**
			 * Enable or disable live updating as on target change, property change and
			 * user code changes. 
			 * 
			 * If user unchecks and is modified then do not update. 
			 * Resync button will visible for them to update themselves. 
			 * */
			protected function updateCodeLive_changeHandler(event:Event = null):void {
				
			
				if (updateCodeLive.selected) {
					aceEditor.addEventListener(Event.CHANGE, editorChangeHandler);
					aceCSSEditor.addEventListener(Event.CHANGE, editorChangeHandler);
					templateEditor.addEventListener(Event.CHANGE, templateEditorChangeHandler);
					updateCodeEditors(true);
					radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML);
				}
				else {
					aceEditor.removeEventListener(Event.CHANGE, editorChangeHandler);
					aceCSSEditor.removeEventListener(Event.CHANGE, editorChangeHandler);
					templateEditor.addEventListener(Event.CHANGE, templateEditorChangeHandler);
					isCodeModifiedByUser = false;
					updateCodeEditors(true);
					radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML);
				}
			}
			
			public function getTextAreaCode():String {
				
				if (currentState=="desktop") {
					return aceEditor.text;
				}
				else if (currentState=="editor") {
					var result:String = ExternalInterface.call("getEditorText");
					return result;
				}
				
				return null;
			}
			
			/**
			 * Put the generated code into a text area
			 * */
			public function setEditorText(sourceData:SourceData):void {
				var createEditor:String = "createEditor";
				var result:Object;
				
				if (currentState=="desktop") {
					
					settingEditorText = true;
					if (aceEditor) {
						
						if (sourceData==null) {
							aceEditor.text = "";
							aceCSSEditor.text = "";
						}
						
						if (setStylesInline.selected) {
							aceEditor.text = sourceData ? sourceData.markup : "";
							aceCSSEditor.text = "";
						}
						else {
							aceEditor.text = sourceData ? sourceData.markup : "";
							aceCSSEditor.text = sourceData ? sourceData.styles : "";
						}
						
						aceEditor.validateNow();
						aceCSSEditor.validateNow();
					}
					settingEditorText = false;
					
				}
				else if (currentState=="editor") {
					
					if (!aceEditorCreated) {
						//editor.content = "<div id='editor' style='display:block;position:absolute;top:0px;left:0px;right:0px;bottom:0px;height:100%;width:100%'></div>";
						//editor.content = " ";
						editor.validateNow();
						result = ExternalInterface.call(createEditor, "editor", ExternalInterface.objectID);
						ExternalInterface.addCallback("editorChange", editorChange);
						ExternalInterface.addCallback("cursorChange", cursorChange);
	                	aceEditorCreated = true;
					}
					
					settingEditorText = true;
					result = ExternalInterface.call("setEditorText", sourceData);
					settingEditorText = false;
					
				}
				
			}
			
			protected function editorType_changeHandler(event:IndexChangeEvent):void {
				currentState = event.currentTarget.selectedItem.name;
				setEditorText(null);
			}
			
			public function editorChange(value:String = ""):void {
				if (settingEditorText || value==sourceData.source) return;
				updatePreviewDocument();
			}
			
			public function cursorChange(value:String = ""):void {
				//trace("cursor change:" + getTimer());
			}
			
			protected function showBorders_clickHandler(event:MouseEvent):void {
				showBorders = showBordersButton.selected;
				updateCodeEditors(true);
				return;
				
				if (showBorders) {
					showBorderOutline(1);
				}
				else {
					showBorderOutline(0);
				}
			}
			
			public function showBorderOutline(outlineWidth:int):void {
				var previewDocument:Object;
				var borderStyleNode:Object;
				var domWindow:Object;
				
				if (Radiate.isDesktop && radiate.isPreviewDocumentVisible()) {
					previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
					
					if (previewDocument && "domWindow" in previewDocument) {
						domWindow = previewDocument.domWindow;
						borderStyleNode = domWindow.document.borderStyleNode;
					}
					
					if (!borderStyleNode) {
						borderStyleNode = domWindow.document.createElement("style");
						domWindow.document.body.appendChild(borderStyleNode);
					}
					
					borderStyleNode.innerHTML = "*, *:before, *:after { outline:" + outlineWidth + "px dotted red; }";
				}
			}
			
			protected function useSVGButtonClassCheckbox_changeHandler(event:Event):void {
				//useSVGButtonClass = useSVGButtonClassCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function showFullHTMLCheckbox_clickHandler(event:MouseEvent):void {
				//showFullHTMLPageSource = showFullHTMLCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function setStylesInline_clickHandler(event:MouseEvent):void {
				updateCodeEditors(true);
			}
			
			protected function setZoom_clickHandler(event:MouseEvent):void {
				updateCodeEditors(true);
			}
			
			protected function showStyles_clickHandler(event:MouseEvent):void {
				//showStyles = showStylesCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function showBackgroundImageCheckbox_clickHandler(event:MouseEvent):void {
				showBackgroundImage = showBackgroundImageCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function showOriginalSourceLabel_clickHandler(event:MouseEvent):void {
				var selectedDocument:IDocument = radiate.selectedDocument as IDocument;
				
				if (selectedDocument) {
					Radiate.info(selectedDocument.originalSource);
				}
				else {
					Radiate.info("Please select a document");
				}
			}
			
			protected function showProjectSourceLabel_clickHandler(event:MouseEvent):void {
				var selectedProject:IProject = radiate.selectedProject as IProject;
				
				if (selectedProject) {
					Radiate.info(selectedProject.source);
				}
				else {
					Radiate.info("Please select a project");
				}
			}
			
			/**
			 * Get the document code and dispatch a preview event.
			 * 
			 * Got this error: 
			 * WARNING: For content targeting Flash Player version 14 or higher, 
			 * ExternalInterface escapes strings using JSON conventions. To maintain compatibility, 
			 * content published to earlier Flash Player versions continues to use the legacy escaping behavior.
			 * 
			 * Don't know what to do with it but gonna leave it for now. 
			 * */
			protected function previewButton_clickHandler(event:MouseEvent):void {
				var previewDocument:Object;
				
				if (!radiate.selectedDocument) return;
				/*
				if (!isCodeModifiedByUser) {
					var code:String = getDocumentCode(); // puts document code into text area
				}*/
				
				updateHTMLPreview();
			}
			
			public function updateHTMLPreview():void {
				var previewDocument:Object;
				
				if (Radiate.isDesktop) {
					// allow to swap between preview and non preview
					if (!radiate.isPreviewDocumentVisible()) {
						radiate.openDocumentPreview(radiate.selectedDocument, true);
					}
					
					previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
					
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					/*else {
						radiate.openDocument(radiate.selectedDocument);
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, "");
					}*/
					
					if (previewDocument is UIComponent && sourceData) {
						//previewDocument.htmlText = wrapInPreview(sourceData.source);
						previewDocument.htmlText = sourceData.source;
						if (previewDocument is IValidator) {
							previewDocument.validateNow(); // prevent editor change event
						}
					}
					
					//updateCodeLive.selected = true;
					//updateCodeLive_changeHandler();
				}
				else {
					// allow to swap between preview and non preview
					if (!radiate.isPreviewDocumentVisible()) {
						radiate.openDocumentPreview(radiate.selectedDocument, true);
						previewDocument = radiate.getDocumentPreview(radiate.selectedDocument);
						
						if (previewDocument is IFrame) {
							previewDocument.content = sourceData.source;
						}
						
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					}
					else {
						radiate.openDocument(radiate.selectedDocument);
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, "");
					}
				}
			}
			
			protected function editorViewOptionButtons_clickHandler(event:MouseEvent):void
			{
				var selectedItem:Object = editorViewOptionButtons.selectedItem;
				var view:String = selectedItem ? selectedItem.value.toLowerCase() : "markup";
				//editorViewOptionButtons.selectedIndex = 0;
				//editorViewOptionButtons.validateNow();
				//editorViewOptionButtons.selectedIndex = event.index;
				editorViewOptionButtons.invalidateProperties();
				
				updateEditorOptions(view);
			}
			
			protected function editorOptionsLinkBarHandler(event:ItemClickEvent):void
			{
				var selectedItem:Object = event.item;
				var view:String = selectedItem ? selectedItem.value.toLowerCase() : "markup";
				//editorViewOptionButtons.selectedIndex = 0;
				//editorViewOptionButtons.validateNow();
				//editorViewOptionButtons.selectedIndex = event.index;
				editorViewOptionButtons.invalidateProperties();
				//editorViewOptionButtons.styleChanged(null);
				updateEditorOptions(view);
			}
			
			protected function updateEditorOptions(view:String ="markup"):void {
				
				// markup 
				if (view=="markup") {
					aceEditor.includeInLayout = aceEditor.visible = true;
					aceCSSEditor.includeInLayout = aceCSSEditor.visible = false;
				}
				else if (view=="css") {
					aceEditor.includeInLayout = aceEditor.visible = false;
					aceCSSEditor.includeInLayout = aceCSSEditor.visible = true;
				}
				else {
					aceEditor.includeInLayout = aceEditor.visible = true;
					aceCSSEditor.includeInLayout = aceCSSEditor.visible = true;
				}
			}
			
			private function getSelectedLanguage():String
			{
				return languageTypeButtons.selectedItem;
			}
			/*
			private function languageTypeLinkBar_changeHandler():void {
				var tempSelectedIndex:Number = languageTypeButtons.selectedIndex;
				
				for (var i:int; i<languageTypes.length;i++) {
					languageTypeButtons.selectedIndex = i;
					languageTypeButtons.validateNow();
				}
				
				languageTypeButtons.selectedIndex = tempSelectedIndex;
			}*/
			
			protected function resetTemplateButton_clickHandler(event:MouseEvent):void {
				var iDocument:IDocument = radiate.selectedDocument;
				var showTemplate:Boolean = editTemplateButton.selected;
				
				if (iDocument) {
					Radiate.revertDocumentTemplate(iDocument);
				}
					
				if (templateEditor && iDocument) {
					templateEditor.text = iDocument.template;
				}
			}
			
			protected function editTemplateButton_clickHandler(event:MouseEvent):void {
				var iDocument:IDocument = radiate.selectedDocument;
				var showTemplate:Boolean = editTemplateButton.selected;
				
				if (templateEditor && showTemplate) {
					editingTemplate = true;
					templateEditor.text = iDocument.template ? iDocument.template : basicTemplate;
					templateEditor.visible = showTemplate;
					templateEditor.includeInLayout = showTemplate;
				}
				else {
					editingTemplate = false;
					iDocument.template = templateEditor.text;
					templateEditor.visible = showTemplate;
					templateEditor.includeInLayout = showTemplate;
				}
			}
			
			protected function uncaughtExceptionEvent(event:RadiateEvent):void
			{
				trace("Uncaught Exception Event: " + event);
			}
			public var FIND:String = "find";
			private function createEditors():void {
				var settings:Settings = Radiate.settings;
				var enableWordWrap:Boolean = settings.enableWordWrap;
				enableWordWrapButton.selected = enableWordWrap;
				
				// 1067: Implicit coercion of a value of type com.flexcapacitor.controls:AceEditor to an unrelated type Object
				
				aceEditor = AceEditorUtils.createInstance();
				UIComponent(aceEditor).percentWidth = 100;
				UIComponent(aceEditor).percentHeight = 100;
				aceEditor.top = 0;
				aceEditor.left = 0;
				editorGroup.addElementAt(aceEditor, 0);
				aceEditor.mode = "ace/mode/xml";
				aceEditor.showFoldWidgets = false;
				aceEditor.margin = editorMargin;
				aceEditor.addEventListener(FocusEvent.FOCUS_IN, editorFocusInHandler, false, 0, true);
				aceEditor.addEventListener(FIND, editorFindHandler, false, 0, true);
				aceEditorCreated = true;
				aceEditor.scrollSpeed = .5;
				aceEditor.useWordWrap = enableWordWrap;
				
				aceCSSEditor = AceEditorUtils.createInstance();
				UIComponent(aceCSSEditor).percentWidth = 100;
				UIComponent(aceCSSEditor).percentHeight = 100;
				aceCSSEditor.top = 0;
				aceCSSEditor.left = 0;
				editorGroup.addElementAt(aceCSSEditor, 1);
				aceCSSEditor.mode = "ace/mode/css";
				aceCSSEditor.showFoldWidgets = false;
				aceCSSEditor.margin = editorMargin;
				aceCSSEditor.addEventListener(FocusEvent.FOCUS_IN, editorFocusInHandler, false, 0, true);
				aceCSSEditor.addEventListener(FIND, editorFindHandler, false, 0, true);
				aceCSSEditorCreated = true;
				aceCSSEditor.scrollSpeed = .5;
				aceCSSEditor.useWordWrap = enableWordWrap;
				
				templateEditor = AceEditorUtils.createInstance();
				UIComponent(templateEditor).percentWidth = 100;
				UIComponent(templateEditor).percentHeight = 100;
				templateEditor.top = 0;
				templateEditor.left = 0;
				editorGroup.addElementAt(templateEditor, 0);
				templateEditor.mode = "ace/mode/html";
				templateEditor.showFoldWidgets = false;
				aceTemplateEditorCreated = true;
				templateEditor.margin = editorMargin;
				templateEditor.scrollSpeed = .5;
				templateEditor.visible = false;
				templateEditor.includeInLayout = false;
				templateEditor.addEventListener(FocusEvent.FOCUS_IN, editorFocusInHandler, false, 0, true);
				templateEditor.addEventListener(FIND, editorFindHandler, false, 0, true);
				templateEditor.useWordWrap = enableWordWrap;
				
				
			}
			
			private var lastFocusedEditor:Object;
			
			private function editorFocusInHandler(event:FocusEvent):void
			{
				lastFocusedEditor = event.currentTarget;
				searchInput.aceEditor = lastFocusedEditor;
				
				if (enableWordWrapButton) {
					enableWordWrapButton.selected = lastFocusedEditor.useWordWrap;
				}
			}
			
			private function editorFindHandler(event:FocusEvent):void
			{
				lastFocusedEditor = event.currentTarget;
				searchInput.aceEditor = lastFocusedEditor;
				lastFocusedEditor.blur();
				searchInput.setFocus();
				
			}
			
			
			protected function wordwrapButton_clickHandler(event:MouseEvent):void
			{
				if (lastFocusedEditor) {
					lastFocusedEditor.useWordWrap = enableWordWrapButton.selected;
				}
				else if (aceEditor) {
					aceEditor.useWordWrap = enableWordWrapButton.selected;
				}
			}
			
			protected function showChildDescriptors_clickHandler(event:MouseEvent):void
			{
				updateCodeEditors(true);
			}
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		
		<handlers:EventHandler eventName="click" target="{copyIcon}" setTriggerEvent="true">
			
			<core:GetDataFromTarget target="{sourceData}" targetPropertyName="source"/> 
			<core:CopyPreviousToNext />
			<clipboard:CopyToClipboard targetAncestor="{this}" 
									   allowNullData="true" 
									   success="Radiate.info('Code copied to the clipboard')"
									   noData="Radiate.info('Nothing to copy to the clipboard')"
									   error="Radiate.info('An error occurred while attempting to copy to the clipboard')"
									   >
			</clipboard:CopyToClipboard>
			
		</handlers:EventHandler>
		
		<!--- 
		adds zoom css for replicating preview
		-->
		<fx:String id="zoomCSS">
			<![CDATA[
IFRAME_ID {
    zoom: ZOOM_VALUE;
    -moz-transform: scale(ZOOM_VALUE);
    -moz-transform-origin: 0 0;
    -o-transform: scale(ZOOM_VALUE);
    -o-transform-origin: 0 0;
    -webkit-transform: scale(ZOOM_VALUE);
    -webkit-transform-origin: 0 0;
}
]]>
		</fx:String>
		
		
		<!-- If you use .button it causes sizing issues where the size of the button is 0 
		Firefox: 
		Paste the following code into the editor after all other html code (from style tag to style tag).
		And the class of the HTML button is set to class="button"
		
		Fix: 
		Rename "button" to "buttonSkin" and set class="buttonSkin". In time this will point to actual skins and defined styles.
		Look at buttonCSS2. 
		-->
		<fx:String id="buttonCSS">
			<![CDATA[
.button {
	position: absolute;
	background: url(assets/svg/button_skin_up.svg) 0 0 no-repeat;
	border: 0px;
}

.button:hover {
	background: url(assets/svg/button_skin_over.svg) 0 0 no-repeat;
}

.button:active {
	background: url(assets/svg/button_skin_down.svg) 0 0 no-repeat;
}
]]>
		</fx:String>
		
		
		<fx:String id="buttonCSS2">
			<![CDATA[
.buttonSkin {
	background: url(assets/svg/button_skin_up.svg) 0 0 no-repeat;
	border: 0px;
}

.buttonSkin:hover {
	background: url(assets/svg/button_skin_over.svg) 0 0 no-repeat;
	border: 0px;
}

.buttonSkin:active {
	background: url(assets/svg/button_skin_down.svg) 0 0 no-repeat;
	border: 0px;
}
]]>
		</fx:String>
		
		<s:ArrayList id="editorViewOptions">
			<fx:Array>
				<fx:Object label="Markup" value="markup"/>
				<fx:Object label="CSS" value="css"/>
				<fx:Object label="Markup+CSS" value="markupcss"/>
			</fx:Array>
		</s:ArrayList>
		
		<s:ArrayList id="languageTypes">
			<fx:String>{CodeManager.MXML}</fx:String>
			<fx:String>{CodeManager.HTML}</fx:String>
			<fx:String>{CodeManager.ANDROID}</fx:String>
		</s:ArrayList>
	</fx:Declarations>
	
	<s:states>
		<s:State name="normal"/>
		<s:State name="editor"/>
		<s:State name="desktop"/>
	</s:states>
	
	<mx:HDividedBox id="editorGroup" top="0" width="100%" height="100%" >
		
		
		<flexiframe:IFrame id="editor" 
						   top="50" left="0"
						   width="100%" height="100%" 
						   includeIn="editor"
						   overlayDetection="true"
						   >
		</flexiframe:IFrame>
		
	</mx:HDividedBox>
	
	
	<!-- FIRST ROW -->
	<s:HGroup left="0" right="0" 
			  width="100%"
			  clipAndEnableScrolling="true" 
			  paddingLeft="6" 
			  paddingRight="10"
			  verticalAlign="middle"
			  fontSize="9"
			  >
		
		<c:SolidFillToggleButton id="editTemplateButton" 
						label="Edit Template" 
						toolTip="Edit the webpage template"
						visible="{isHTML}"
						includeInLayout="{isHTML}"
						click="editTemplateButton_clickHandler(event)"/>
		
		<c:BeveledImageButton id="resetTemplateButton"
							  source="{Radii8LibraryAssets.refresh}"
							  toolTip="Reset template code"
							  click="resetTemplateButton_clickHandler(event)"
							  visible="{editTemplateButton.selected}"
							  includeInLayout="{editTemplateButton.selected}"
							  />
		
		<c:SolidFillButtonBar id="editorViewOptionButtons" 
					 requireSelection="true"
					 labelField="label"
					 toolTip="Select the code editors to view"
					 dataProvider="{editorViewOptions}"
					 click="editorViewOptionButtons_clickHandler(event)">
		</c:SolidFillButtonBar>
		
		<c:SolidFillButtonBar id="languageTypeButtons" 
					 selectedIndex="0"
					 toolTip="Select the language to generate"
					 click="languageType_changeHandler(null)"
					 dataProvider="{languageTypes}">
		</c:SolidFillButtonBar>
		
		<!--<mx:LinkBar id="languageTypeLinkButtons"
					itemClick="languageTypeLinkBar_changeHandler()"
					selectionColor="0xFF0000"
					disabledColor="0x00FF00"
					dataProvider="{languageTypes}">
		</mx:LinkBar>-->
		
		
		<c:BeveledImageButton id="openDocumentInInternalWebIcon" 
							  source="{Radii8LibraryAssets.documentPlayIcon}" 
							  toolTip="View document inline with internal web browser (it's currently an old browser)"
							  smoothingQuality="high"
							  smooth="true"
							  width="18"
							  height="10"
							  visible="{isHTML}"
							  includeInLayout="{isHTML}"
							  click="previewButton_clickHandler(event)" 
							  />
		
		<!--<c:BeveledImageButton id="previewButton"
							  source="{Radii8LibraryToolAssets.Launch}"
							  toolTip="Preview in a browser"
							  enabled="{isHTML}" 
							  visible="{isHTML}"
							  includeInLayout="{isHTML}"
							  click="previewButton_clickHandler(event)"
							  />-->
		
		<c:BeveledImageToggleButton id="enableWordWrapButton"
							  source="{Radii8LibraryAssets.wordWrap}"
							  toolTip="Word wrap"
							  width="20"
							  height="16"
							  scaleMode="letterbox"
							  click="wordwrapButton_clickHandler(event)"
							  showBackgroundWhenSelected="true"
							  />
		
		
		<s:CheckBox id="showChildDescriptors"
					label="Nested Elements"
					toolTip="Show nested elements"
					click="showChildDescriptors_clickHandler(event)"
					/>
		
		<c:BeveledImageButton id="resyncButton"
							  source="{Radii8LibraryAssets.refresh}"
							  toolTip="Revert code"
							  click="resyncButton_clickHandler(event)"
							  visible="{isHTML}"
							  includeInLayout="{isHTML}"
							  />
		
		<s:CheckBox id="updateCodeLive" 
					selected="false"
					label="Live"
					toolTip="Edit code live (experimental)"
					visible="{isHTML}"
					includeInLayout="{isHTML}"
					change="updateCodeLive_changeHandler(event)"/>
		
		<!-- enabled="{isCodeModifiedByUser}" -->
		<!-- enabled="{isCodeModifiedByUser}" -->
		
		<s:CheckBox id="showBackgroundImageCheckbox" 
					selected="false"
					label="Background Image"
					toolTip="Show a background screenshot image in the preview for comparison (experimental)"
					visible="{false}"
					includeInLayout="{false}"
					click="showBackgroundImageCheckbox_clickHandler(event)"/>
		
		<s:CheckBox id="setStylesInline" 
					selected="false"
					label="Styles inline"
					toolTip="Define styles in the markup"
					visible="{isHTML}"
					includeInLayout="{isHTML}"
					click="setStylesInline_clickHandler(event)"/>
		
		<s:CheckBox id="showBordersButton" 
					selected="false"
					label="Borders"
					toolTip="Show borders around elements"
					visible="{isHTML}"
					includeInLayout="{isHTML}"
					click="showBorders_clickHandler(event)"/>
		<!--
		<s:Group id="redrawButton" 
				 click="showBorders_clickHandler(event)"
				 >
			<s:Rect id="fill" width="20" height="20" >
				<s:fill>
					<s:SolidColor color="#585858"/>
				</s:fill>
				<s:stroke>
					<s:SolidColorStroke id="strokeColor" color="#585858" weight="2"/>
				</s:stroke>
			</s:Rect>
			<s:Rect id="stroke" top="2" left="2" right="2" bottom="2">
				<s:stroke>
					<s:SolidColorStroke color="#FFFFFF" />
				</s:stroke>
			</s:Rect>
		</s:Group>-->
		
		<s:Spacer width="100%"/>
		
		<c:AceSearchTextInput id="searchInput" 
						   prompt="Search" 
						   minWidth="100"
						   width="100%"
						   focusAlpha="0"/>
		
		<c:BeveledImageButton id="copyIcon" 
					   source="{Radii8LibraryAssets.copy}" 
					   toolTip="Copy the code to the Clipboard"
					   verticalAlign="middle"
					   useHandCursor="true"
					   />
	</s:HGroup>
	

	
	
</s:Group>