<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 xmlns:c="com.flexcapacitor.controls.*"
		 xmlns:handlers="com.flexcapacitor.handlers.*" 
		 xmlns:clipboard="com.flexcapacitor.effects.clipboard.*" 
		 xmlns:core="com.flexcapacitor.effects.core.*" 
		 xmlns:flexcapacitor="flexcapacitor.*" 
		 xmlns:flexiframe="com.google.code.flexiframe.*"
		 xmlns:controls="com.riaspace.controls.*"
		 xmlns:ns="http://www.flexcapacitor.com/flex/2015" 
		 
		 minWidth="200" 
		 minHeight="0"
		 implements="com.flexcapacitor.views.IInspector" 
		 >
	
	
	<fx:Script>
		<![CDATA[
			import com.flexcapacitor.controller.Radiate;
			import com.flexcapacitor.controls.supportClasses.AceCommand;
			import com.flexcapacitor.controls.supportClasses.AutoCompleteObject;
			import com.flexcapacitor.controls.supportClasses.TokenInformation;
			import com.flexcapacitor.events.AceEvent;
			import com.flexcapacitor.events.RadiateEvent;
			import com.flexcapacitor.managers.ClipboardManager;
			import com.flexcapacitor.managers.CodeManager;
			import com.flexcapacitor.managers.ComponentManager;
			import com.flexcapacitor.managers.DocumentManager;
			import com.flexcapacitor.managers.HistoryManager;
			import com.flexcapacitor.managers.ImportManager;
			import com.flexcapacitor.managers.RunManager;
			import com.flexcapacitor.managers.SettingsManager;
			import com.flexcapacitor.model.ExportOptions;
			import com.flexcapacitor.model.HTMLExportOptions;
			import com.flexcapacitor.model.IDocument;
			import com.flexcapacitor.model.IProject;
			import com.flexcapacitor.model.MXMLImportOptions;
			import com.flexcapacitor.model.Settings;
			import com.flexcapacitor.model.SourceData;
			import com.flexcapacitor.model.TranscoderDescription;
			import com.flexcapacitor.utils.AceEditorUtils;
			import com.flexcapacitor.utils.ClassLoader;
			import com.flexcapacitor.utils.ClassRegistry;
			import com.flexcapacitor.utils.DisplayObjectUtils;
			import com.flexcapacitor.utils.MXMLDocumentConstants;
			import com.flexcapacitor.utils.XMLUtils;
			import com.flexcapacitor.utils.supportClasses.ComponentDescription;
			import com.flexcapacitor.utils.supportClasses.XMLValidationInfo;
			import com.google.code.flexiframe.IFrame;
			
			import mx.core.IVisualElement;
			import mx.core.IVisualElementContainer;
			import mx.core.UIComponent;
			import mx.events.ItemClickEvent;
			import mx.events.ToolTipEvent;
			import mx.utils.Platform;
			import mx.validators.IValidator;
			
			import spark.components.Application;
			import spark.events.IndexChangeEvent;
			import spark.layouts.BasicLayout;
			
			import flashx.textLayout.conversion.ITextImporter;
			
			public static const HTML_RENDER:String = "htmlRender";
			public static const HTML_COMPLETE:String = "complete";
			
			public static const DESKTOP:String = "desktop";
			public static const BROWSER:String = "browser";
			
			public static var debug:Boolean;
			
			/**
			 * Reference to Radiate
			 * */
			public var radiate:Radiate;
			
			/**
			 * Last target
			 * */
			public var lastTarget:Object;
			
			/**
			 * Last target parent instance
			 * */
			public var lastParentInstance:Object;
			
			/**
			 * Basic HTML template
			 * */
			public var basicTemplate:String;
			
			/**
			 * Indicates when the user has typed in the text area
			 * */
			[Bindable]
			public var isCodeModifiedByUser:Boolean;
			
			/**
			 * Show borders around HTML elements
			 * */
			public var showBorders:Boolean;
			
			
			public var embedPlaceholderImageDataHTML:Boolean = false;
			
			/**
			 * Use SVG button class
			 * */
			public var useSVGButtonClass:Boolean = true;
			
			/**
			 * Show full HTML page source
			 * */
			public var showFullHTMLPageSource:Boolean = true;
			
			/**
			 * Create screen shot and add as background image of HTML page 
			 * */
			public var showBackgroundImage:Boolean = false;
			
			/**
			 * Indicates if XML is invalid
			 * */
			public var isValid:Boolean;
			
			[Bindable]
			public var editorMargin:String = "28px 0 8px 0px";
			
			public var settingEditorText:Boolean;
			public var settingTargets:Boolean;
			public var editingTemplate:Boolean;
			
			public var languageTypesArrayList:ArrayList;
			private var options:ExportOptions;
			
			[Bindable]
			public var isHTML:Boolean;
			[Bindable]
			public var isMXML:Boolean;
			
			public var htmlRenderHandled:Boolean;
			public var htmlCompleteHandled:Boolean;
			public var htmlStartRenderTime:int;
			public var htmlRenderTime:int;
			public var htmlStartCompleteTime:int;
			public var htmlCompleteTime:int;
			
			/**
			 * Last source data
			 * */
			[Bindable]
			public var sourceData:SourceData;
			
			public var lastTextAreaValue:String;
			
			public var aceEditorCreated:Boolean;
			public var aceCSSEditorCreated:Boolean;
			public var aceTemplateEditorCreated:Boolean;
			
			[Bindable]
			public var enableWordWrap:Boolean;
			
			[Bindable]
			public var embedImages:Boolean;
			public var activatedOnce:Boolean;
			
			public function activate(selectedTarget:Object = null):void {
				radiate = Radiate.instance;
				
				addListeners();
				
				createEditors();
				
				updateEditorOptions();
				
				if (basicTemplate==null) {
					basicTemplate = new Radii8LibraryTranscodersAssets.basicHTMLDocumentReusable();
				}
				
				if (showChildDescriptors) {
					showChildDescriptors.selected = true;
				}
				
				if (languageTypesArrayList==null) {
					var languageTypesArray:Array = [];
					languageTypesArray.push({label:"", value:CodeManager.MXML, icon:Radii8LibraryAssets.mxmlDocument});
					languageTypesArray.push({label:"", value:CodeManager.HTML, icon:Radii8LibraryAssets.htmlDocument});
					languageTypesArray.push({label:"", value:CodeManager.ANDROID, icon:Radii8LibraryAssets.androidDocument});
					languageTypesArrayList = new ArrayList(languageTypesArray);
					languageTypeButtons.dataProvider = languageTypesArrayList;
					languageTypeButtons.selectedIndex = 0;
				}
				
				if (DocumentManager.isDocumentPreviewOpen(Radiate.selectedDocument)) {
					setSelectedLanguage(CodeManager.HTML);
					isHTML = true;
				}
				
				isMXML = isSelectedLanguage(CodeManager.MXML);
				
				var settings:Settings = SettingsManager.settings;
				
				if (activatedOnce==false) {
					enableWordWrap = settings.enableWordWrap;
					embedImages = settings.embedImages;
					enableWordWrapButton.selected = enableWordWrap;
					activatedOnce = true;
				}
				
				if (radiate.target) {
					updateCodeEditors();
				}
				
				if (Platform.isBrowser) {
					editorMargin = "0";
				}
				editorMargin = "0";
				
				if (aceEditor) {
					aceEditor.visible = true;
				}
				if (aceCSSEditor) {
					aceCSSEditor.visible = true;
				}
				if (templateEditor) {
					templateEditor.visible = true;
				}
				
				if (aceEditor.aceFound==false) {
					callLater(setupCodeComplete);
				}
				else {
					setupCodeComplete();
				}
				
			}
			
			public function deactivate():void {
				removeListeners();
				if (aceEditor) {
					aceEditor.visible = false;
				}
				if (aceCSSEditor) {
					aceCSSEditor.visible = false;
				}
				if (templateEditor) {
					templateEditor.visible = false;
				}
			}
			
			public function addListeners():void {
				radiate.addEventListener(RadiateEvent.TARGET_CHANGE, handleTargetChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.PROPERTY_CHANGED, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.MOVE_ITEM, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.ADD_ITEM, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.REMOVE_ITEM, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.HISTORY_CHANGE, handlePropertyChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.DOCUMENT_CHANGE, handleDocumentChange, false, 0, true);
				radiate.addEventListener(RadiateEvent.DOCUMENT_CLOSE, handleDocumentClosed, false, 0, true);
				radiate.addEventListener(RadiateEvent.UNCAUGHT_EXCEPTION_EVENT, uncaughtExceptionEvent, false, 0, true);
			}
			
			public function removeListeners():void {
				if (radiate) {
					radiate.removeEventListener(RadiateEvent.TARGET_CHANGE, handleTargetChange);
					radiate.removeEventListener(RadiateEvent.PROPERTY_CHANGED, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.MOVE_ITEM, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.ADD_ITEM, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.REMOVE_ITEM, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.HISTORY_CHANGE, handlePropertyChange);
					radiate.removeEventListener(RadiateEvent.DOCUMENT_CHANGE, handleDocumentChange);
					radiate.removeEventListener(RadiateEvent.DOCUMENT_CLOSE, handleDocumentClosed);
					radiate.removeEventListener(RadiateEvent.UNCAUGHT_EXCEPTION_EVENT, uncaughtExceptionEvent);
				}
			}
			
			public var classRegistry:ClassRegistry = ClassRegistry.getInstance();
			
			public var classLoader:ClassLoader;
			
			/**
			 * Generate the code for the provided target component. 
			 * */
			public function updateTarget(target:Object):void {
				var iDocument:IDocument = Radiate.selectedDocument;
				var targetDescription:ComponentDescription;
				var language:String = getSelectedLanguage();
				var output:String = "";
				var xml:XML;
				
				if (target==null && iDocument) {
					target = iDocument.instance;
				}
				
				if (editingTemplate && iDocument) {
					iDocument.template = templateEditor.text;
				}
				
				if (iDocument!=null) {
					targetDescription = DisplayObjectUtils.getTargetInComponentDisplayList(target, iDocument.componentDescription);
				}
				
				if (language==null || targetDescription==null || iDocument==null) {
					sourceData = null;
					radiate.editorSource = null;
					setEditorText(null);
					return;
				}
				
				
				if (language == CodeManager.HTML) {
					//if (!htmlOptions) {
					var htmlOptions:HTMLExportOptions;
					htmlOptions = CodeManager.getExportOptions(language) as HTMLExportOptions;
					//}
					
					//htmlOptions.template = html5boilerplate;
					//htmlOptions.bordersCSS = bordersCSS;
					htmlOptions.showBorders = showBorders;
					//htmlOptions.useBorderBox = useBoderBox;
					htmlOptions.useInlineStyles = setStylesInline.selected;
					htmlOptions.template = iDocument.template;
					htmlOptions.disableTabs = true;
					htmlOptions.useExternalStylesheet = false;
					htmlOptions.exportChildDescriptors = showChildDescriptors.selected;
					htmlOptions.reverseInitialCSS = true;
					
					if (updateCodeLive.selected && isCodeModifiedByUser) {
						htmlOptions.useCustomMarkup = true;
						htmlOptions.markup = aceEditor.text;
						htmlOptions.styles = aceCSSEditor.text;
					}
					else {
						htmlOptions.useCustomMarkup = false;
						htmlOptions.markup = "";
						htmlOptions.styles = "";
					}
					
					if (DocumentManager.isPreviewDocumentVisible()) {
						htmlOptions.exportFullDocument = true;
						htmlOptions.embedPlaceholderImageData = false;
					}
					else {
						htmlOptions.exportFullDocument = false;
						//htmlOptions.embedImages = embedImagesButton.selected;
						htmlOptions.embedPlaceholderImageData = embedPlaceholderImageDataHTML;
					}
					
					options = htmlOptions;
				}
				else if (language == CodeManager.MXML) {
					options = CodeManager.getExportOptions(language) as ExportOptions;
					options.template = "";
					options.exportChildDescriptors = showChildDescriptors.selected;
					options.embedImages = embedImagesButton.selected;
					//options = null;
				}
				else if (language == CodeManager.ANDROID) {
					options = CodeManager.getExportOptions(language) as ExportOptions;
					options.template = "";
					options.embedImages = embedImagesButton.selected;
					//options = null;
				}
				
				sourceData = CodeManager.getSourceData(target, iDocument, language, options);
				
				output = sourceData.source;
				radiate.editorSource = sourceData;
				iDocument.errors = sourceData.errors;
				iDocument.warnings = sourceData.warnings;
				
				//if (DocumentManager.isPreviewDocumentVisible() && updateCodeLive.selected && isCodeModifiedByUser) {
				if (updateCodeLive.selected && isCodeModifiedByUser) {
					if (language==CodeManager.HTML) {
						updateHTMLPreview();
					}
				}
				else {
					hideMessage();
					setEditorText(sourceData);
					
					if (DocumentManager.isPreviewDocumentVisible() && language==CodeManager.HTML) {
						updateHTMLPreview();
					}
				}
				
				Radiate.dispatchPreviewEvent(sourceData, language);
			}
			
			/**
			 * Handle target change
			 * */
			protected function handleTargetChange(event:RadiateEvent):void {
				var language:String;
				
				if (settingTargets) return;
				
				language = getSelectedLanguage();

				// if code is not modified by the user 
				// and show selection 
				// we only want to update the view on selection change when we are 
				// paying attention when we have show selected component code option enabled
				if (language==CodeManager.HTML) {
					if (!isCodeModifiedByUser) {
						updateCodeEditors();
					}
					else if (updateCodeLive.selected && DocumentManager.isPreviewDocumentVisible()) {
						updateCodeEditors(true);
						updateHTMLPreview();
					}
				}
				
				if (language==CodeManager.MXML) {
					if (!isCodeModifiedByUser) {
						updateCodeEditors();
					}
				}
				
				if (updateCodeLive.selected) {
					Radiate.dispatchCodeUpdatedEvent(sourceData, language);
				}
			}
			
			/**
			 * Updates the code when the document changes. 
			 * */
			protected function handleDocumentChange(event:RadiateEvent):void {
				var selectedDocument:IDocument = IDocument(event.selectedItem);
				
				
				if (DocumentManager.isPreviewDocumentVisible()) {
					//return;
				}
				
				if (!isCodeModifiedByUser) {
					updateCodeEditors(true);
				}
				
				if (updateCodeLive.selected) {
					Radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML);
				}
			}
			
			/**
			 * Updates the code when a property change happens. 
			 * If the text has been modified by the user then we don't update the code.
			 * They have to press the resync button. 
			 * */
			protected function handlePropertyChange(event:RadiateEvent):void {
				
				if (!isCodeModifiedByUser) {
					updateCodeEditors(true);
				}
				
				if (updateCodeLive.selected) {
					Radiate.dispatchCodeUpdatedEvent(sourceData, CodeManager.HTML);
				}
			}
			
			/**
			 * Updates the code to reflect the selected language 
			 * */
			protected function languageType_changeHandler(event:IndexChangeEvent):void {
				var selectedLanguage:Object;
				
				isCodeModifiedByUser = false;
				updateCodeLive.selected = false;
				
				selectedLanguage = getSelectedLanguage();
				
				isHTML = selectedLanguage==CodeManager.HTML;
				isMXML = selectedLanguage==CodeManager.MXML;
				
				updateCodeEditors(true);
				
				// if HTML preview is visible then dispatch an event to 
				// so that preview can be changed else where
				// needs refactoring
				if (DocumentManager.isPreviewDocumentVisible() && String(selectedLanguage)!=CodeManager.HTML) {
					Radiate.dispatchPreviewEvent(sourceData, String(selectedLanguage));
					DocumentManager.openDocument(Radiate.selectedDocument);
					DocumentManager.closeDocument(Radiate.selectedDocument, true);
				}
				
				if (!isHTML && editTemplateButton.visible && editTemplateButton.selected) {
					editTemplateButton.selected = false;
					editTemplateButton_clickHandler();
				}
			}
			
			/**
			 * Template editor change handler
			 * */
			private function templateEditorChangeHandler(event:Object = null):void {
				if (settingEditorText) return;
				
				var selectedItem:Object = getSelectedLanguage();
				
				if (selectedItem == CodeManager.HTML) {
					isCodeModifiedByUser = true;
				}
				else {
					isCodeModifiedByUser = false;
				}
				
				updatePreviewDocument();
				
			}
			
			/**
			 * Editor change handler
			 * */
			private function editorChangeHandler(event:Object = null):void {
				if (settingEditorText) return;
				
				var selectedLanguage:String = getSelectedLanguage();
				var code:String;
				
				if (selectedLanguage == CodeManager.HTML) {
					isCodeModifiedByUser = true;
					updatePreviewDocument();
				}
				else if (selectedLanguage == CodeManager.MXML) {
					code = aceEditor.text;
					isCodeModifiedByUser = true;
					importMXMLSource(code);
				}
				else {
					isCodeModifiedByUser = false;
				}
				
				
			}
			
			/**
			 * Handle updating preview and set if code is modified by user
			 * */
			public function updatePreviewDocument():void {
				var previewDocument:Object;
				
				if (Radiate.isDesktop) {
					if (updateCodeLive.selected) {
						
						if (DocumentManager.isPreviewDocumentVisible()) {
							//previewDocument = DocumentManager.getDocumentPreview(Radiate.selectedDocument);
							
							updateTarget(Radiate.selectedDocument.instance);
							
							if (previewDocument is UIComponent) {
								//previewDocument.htmlText = wrapInPreview(getTextAreaCode());
							}
							
							//Radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
						}
						//Radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
					}
				}
				else {
					if (updateCodeLive.selected) {
						
						if (DocumentManager.isPreviewDocumentVisible()) {
							previewDocument = DocumentManager.getDocumentPreview(Radiate.selectedDocument);
							
							updateTarget(Radiate.selectedDocument.instance);
							
							if (previewDocument is IFrame) {
								previewDocument.content = sourceData.source;
							}
							
							//Radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
						}
						//Radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
					}
				}
				
			}
			
			
			/**
			 * 
			 * */
			protected function resyncButton_clickHandler(event:MouseEvent):void {
				isCodeModifiedByUser = false;
				updateCodeEditors(true); // reset the contents of the editors
				
				if (updateCodeLive.selected && DocumentManager.isPreviewDocumentVisible()) {
					updateHTMLPreview();
				}
			}
			
			/**
			 * Updates the code to show the selected item or document
			 * */
			public function updateCodeEditors(dispatchCodeUpdatedEvent:Boolean = false):void {
				var previewDocument:Object;
				var selectedLanguage:String = getSelectedLanguage();
				
				//radiate = Radiate.instance;
				
				if (!radiate.target && !Radiate.selectedDocument) {
					updateTarget(null);
					hideMessage();
					return;
				}
				
				
				updateTarget(radiate.target);
				//updateTarget(Radiate.selectedDocument.instance);
				
				if (dispatchCodeUpdatedEvent) {
					
					//if (DocumentManager.isPreviewDocumentVisible()) {
					previewDocument = DocumentManager.getDocumentPreview(Radiate.selectedDocument);
					
					if (previewDocument is IFrame && sourceData) {
						previewDocument.content = sourceData.source;
					}
					
					else if (previewDocument is UIComponent) {
						//previewDocument.htmlText = wrapInPreview(sourceData);
					}
						
						//Radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					//}
					
					//Radiate.dispatchCodeUpdatedEvent(sourceData, HTML, openInSeparateWindow.selected);
					Radiate.dispatchCodeUpdatedEvent(sourceData, selectedLanguage, false);
				}
				
				return;
				
			}
			
			/**
			 * Enable or disable live updating as on target change, property change and
			 * user code changes. 
			 * 
			 * If user unchecks and is modified then do not update. 
			 * Resync button will visible for them to update themselves. 
			 * */
			protected function updateCodeLive_changeHandler(event:Event = null):void {
				clearTimeLabel();
				var language:String;
				
				language = getSelectedLanguage();
			
				if (updateCodeLive.selected) {
					aceEditor.addEventListener(Event.CHANGE, editorChangeHandler);
					aceCSSEditor.addEventListener(Event.CHANGE, editorChangeHandler);
					templateEditor.addEventListener(Event.CHANGE, templateEditorChangeHandler);
					isCodeModifiedByUser = true;
					updateCodeEditors(true);
					Radiate.dispatchCodeUpdatedEvent(sourceData, language);
					
					if (language==CodeManager.MXML && aceEditor) {
						importMXMLSource(aceEditor.text);
					}
				}
				else {
					aceEditor.removeEventListener(Event.CHANGE, editorChangeHandler);
					aceCSSEditor.removeEventListener(Event.CHANGE, editorChangeHandler);
					templateEditor.removeEventListener(Event.CHANGE, templateEditorChangeHandler);
					isCodeModifiedByUser = false;
					updateCodeEditors(true);
					Radiate.dispatchCodeUpdatedEvent(sourceData, language);
				}
			}
			
			public function getTextAreaCode():String {
				
				return aceEditor.text;	
				
			}
			
			/**
			 * Put the generated code into a text area
			 * */
			public function setEditorText(sourceData:SourceData):void {
				//var createEditor:String = "createEditor";
				var result:Object;
			
				settingEditorText = true;
				
				if (aceEditor) {
					
					if (sourceData==null) {
						aceEditor.text = "";
						aceCSSEditor.text = "";
					}
					
					if (setStylesInline.selected) {
						aceEditor.text = sourceData ? sourceData.markup : "";
						aceCSSEditor.text = "";
					}
					else {
						aceEditor.text = sourceData ? sourceData.markup : "";
						aceCSSEditor.text = sourceData ? sourceData.styles : "";
					}
					
					if (templateEditor) {
						templateEditor.validateNow();
						templateEditor.resetUndoHistory();
					}
					
					aceEditor.validateNow();
					aceCSSEditor.validateNow();
					
					aceEditor.resetUndoHistory();
					aceCSSEditor.resetUndoHistory();
					
					if (aceEditor.session) {
						aceEditor.clearAnnotations();
						aceCSSEditor.clearAnnotations();
					}
				}
				
				var object:Object = XMLUtils.getValidationXML(aceEditor.text);
				
				if (object.isValid) {
					//var namespaces:Array = object.xml.namespaceDeclarations();
					classRegistry.addNamespaces(object.xml);
				}
				
				settingEditorText = false;
				
			}
			
			protected function editorType_changeHandler(event:IndexChangeEvent):void {
				currentState = event.currentTarget.selectedItem.name;
				setEditorText(null);
			}
			
			public function editorChange(value:String = ""):void {
				if (settingEditorText || value==sourceData.source) return;
				updatePreviewDocument();
			}
			
			protected function showBorders_clickHandler(event:MouseEvent):void {
				//showBorders = showBordersButton.selected;
				//updateCodeEditors(true);
				//return;
				
				if (showBordersButton.selected) {
					showBorderOutline(true, 1);
				}
				else {
					showBorderOutline(false);
				}
			}
			
			public var outlineStyleSheets:Object;
			
			public function showBorderOutline(enabled:Boolean, outlineWidth:int = 1):void {
				var previewDocument:Object;
				var borderStyleNode:Object;
				var window:Object;
				var elementID:String;
				var rule:String;
				var outlineStyleNode:Object;
				var outlineStyleSheet:Object;
				var results:Object;
				
				if (DocumentManager.isPreviewDocumentVisible()) {
					previewDocument = DocumentManager.getDocumentPreview(Radiate.selectedDocument);
					rule = "{ outline:" + outlineWidth + "px dotted red; }";
					
					if (ExternalInterface.available) {
						elementID = "#" + Object(previewDocument).frameId;
						rule = elementID + " *, " + elementID + " *:before, " + elementID + " *:after " + rule;
						
						results = ExternalInterface.call(borderString, Object(previewDocument).frameId, rule, enabled);
					}
					else if (Radiate.isDesktop) {
						
						if (previewDocument && "domWindow" in previewDocument) {
							window = previewDocument.domWindow;
						}
						
						if (outlineStyleSheets==null) {
							outlineStyleSheets = new Dictionary(true);
						}
						
						rule = "*, *:before, *:after " + rule;
						
						outlineStyleSheet = outlineStyleSheets[previewDocument];
						
						if (outlineStyleSheet==null) {
							outlineStyleNode = window.document.createElement("style");
							window.document.body.appendChild(outlineStyleNode);
							outlineStyleSheet = outlineStyleNode.sheet;
							outlineStyleSheets[previewDocument] = outlineStyleSheet;
							outlineStyleSheet.insertRule(rule, 0);
						}
						
						//Error: Error #3210: The application attempted to reference a JavaScript object in a HTML page that is no longer loaded.
						//	at __HTMLScriptObject/throwJSObjectDead()
						// if the object exists it may still be invalid. if it's invalid it has no properties except a timer
						if (outlineStyleSheet && "disabled" in outlineStyleSheet) {
							outlineStyleSheet.disabled = !enabled;
						}
					}
					else {
						
					}
				}
			}
			
			protected function useSVGButtonClassCheckbox_changeHandler(event:Event):void {
				//useSVGButtonClass = useSVGButtonClassCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function showFullHTMLCheckbox_clickHandler(event:MouseEvent):void {
				//showFullHTMLPageSource = showFullHTMLCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function setStylesInline_clickHandler(event:MouseEvent):void {
				updateCodeEditors(true);
			}
			
			protected function setZoom_clickHandler(event:MouseEvent):void {
				updateCodeEditors(true);
			}
			
			protected function showStyles_clickHandler(event:MouseEvent):void {
				//showStyles = showStylesCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function showBackgroundImageCheckbox_clickHandler(event:MouseEvent):void {
				showBackgroundImage = showBackgroundImageCheckbox.selected;
				updateCodeEditors(true);
			}
			
			protected function showOriginalSourceLabel_clickHandler(event:MouseEvent):void {
				var selectedDocument:IDocument = Radiate.selectedDocument as IDocument;
				
				if (selectedDocument) {
					Radiate.info(selectedDocument.originalSource);
				}
				else {
					Radiate.info("Please select a document");
				}
			}
			
			protected function showProjectSourceLabel_clickHandler(event:MouseEvent):void {
				var selectedProject:IProject = Radiate.selectedProject as IProject;
				
				if (selectedProject) {
					Radiate.info(selectedProject.source);
				}
				else {
					Radiate.info("Please select a project");
				}
			}
			
			/**
			 * Get the document code and dispatch a preview event.
			 * */
			protected function previewButton_clickHandler(event:MouseEvent):void {
				var iDocument:IDocument = Radiate.selectedDocument;
				
				if (iDocument) {
					settingTargets = true;
					RunManager.openDocumentInInternalWeb(Radiate.selectedDocument);
					settingTargets = false;
				}
				else {
					Radiate.info("Please select a document before previewing in the internal browser");
				}
				
			}
			
			public var lastVerticalScrollPosition:int;
			
			public function updateHTMLPreview():void {
				var previewDocument:Object;
				var domWindow:Object;
				var htmlLoader:Object;
				
				if (Radiate.isDesktop) {
					// allow to swap between preview and non preview
					if (!DocumentManager.isPreviewDocumentVisible()) {
						DocumentManager.openDocumentPreview(Radiate.selectedDocument, true);
					}
					
					previewDocument = DocumentManager.getDocumentPreview(Radiate.selectedDocument);
					
						//Radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					/*else {
						DocumentManager.openDocument(Radiate.selectedDocument);
						//Radiate.dispatchPreviewEvent(codeModelTextArea.text, "");
					}*/
					
					/*
					if (previewDocument && "domWindow" in previewDocument && previewDocument.domWindow) {
						domWindow = previewDocument.domWindow;
						
						if (domWindow.document && domWindow.document.body) {
							lastVerticalScrollPosition = domWindow.document.body.scrollTop;
						}
					}*/
					
					// get the vertical scroll position to retain previous position
					if (previewDocument && "htmlLoader" in previewDocument && previewDocument.htmlLoader) {
						htmlLoader = previewDocument.htmlLoader;
						
						lastVerticalScrollPosition = htmlLoader.scrollV;
					}
					
					if (previewDocument is UIComponent && sourceData) {
						//previewDocument.htmlText = wrapInPreview(sourceData.source);
						htmlStartCompleteTime = htmlStartRenderTime = getTimer();
						htmlRenderHandled = htmlCompleteHandled = false;
						
						// render is being fired on mouse wheel scroll and scroll bar change so disabling for now
						//previewDocument.addEventListener(HTML_RENDER, htmlRenderHandler, false, 0, true);
						previewDocument.addEventListener(HTML_COMPLETE, htmlRenderHandler, false, 0, true);
						
						if (lastVerticalScrollPosition!=0) {
							callLater(updateScrollPositionHandler);
						}
						
						previewDocument.htmlText = sourceData.source;
						
						
						if (previewDocument is IValidator) {
							previewDocument.validateNow(); // prevent editor change event
						}
					}
					
					//updateCodeLive.selected = true;
					//updateCodeLive_changeHandler();
				}
				else {
					// allow to swap between preview and non preview
					if (!DocumentManager.isPreviewDocumentVisible()) {
						DocumentManager.openDocumentPreview(Radiate.selectedDocument, true, false);
						previewDocument = DocumentManager.getDocumentPreview(Radiate.selectedDocument);
						
						if (previewDocument is IFrame) {
							previewDocument.content = sourceData.source;
						}
						
						//Radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					}
					else {
						//DocumentManager.openDocument(Radiate.selectedDocument);
						//Radiate.dispatchPreviewEvent(codeModelTextArea.text, "");
					}
				}
			}
			
			/**
			 * Retain the vertical scroll bar position when updating HTML preview
			 * */
			protected function htmlRenderHandler(event:Event):void {
				var previewDocument:Object;
				var domWindow:Object;
				var htmlLoader:Object;
				var type:String = event.type;
				
				
				if (lastVerticalScrollPosition!=0) {
					updateScrollPositionHandler();
				}
				
				if (type==HTML_RENDER) {
					htmlRenderTime = getTimer()-htmlStartRenderTime;
					htmlRenderHandled = true;
				}
				
				if (type==HTML_COMPLETE) {
					htmlCompleteTime = getTimer()-htmlStartCompleteTime;
					htmlCompleteHandled = true;
				}
				
				previewDocument = DocumentManager.getDocumentPreview(Radiate.selectedDocument);
				
				if (previewDocument) {
					previewDocument.removeEventListener(event.type, updateScrollPositionHandler);
				}
				
				if (htmlRenderHandled && htmlCompleteHandled) {
					renderTime.text = htmlCompleteTime + "ms, " + htmlRenderTime + "ms  ";
					renderTime.toolTip = htmlCompleteTime + "ms HTML Complete, " + htmlRenderTime + "ms HTML Render";
					//DeferManager.callAfter(3000, clearTimeLabel);
				}
			}
			
			/**
			 * Clears the time text
			 * */
			public function clearTimeLabel():void {
				if (htmlRenderHandled && htmlCompleteHandled) {
					renderTime.text = "";
				}
			}
			
			/**
			 * Retain the vertical scroll bar position when updating HTML preview
			 * */
			protected function updateScrollPositionHandler(event:Event = null):void {
				var previewDocument:Object;
				var domWindow:Object;
				var htmlLoader:Object;
				
				previewDocument = DocumentManager.getDocumentPreview(Radiate.selectedDocument);
				
				if (previewDocument && "htmlLoader" in previewDocument && previewDocument.htmlLoader) {
					//previewDocument.removeEventListener("complete", updateScrollPositionHandler);
					previewDocument.htmlLoader.scrollV = lastVerticalScrollPosition;
				}
				
			}
			
			protected function editorViewOptionButtons_clickHandler(event:MouseEvent):void
			{
				var selectedItem:Object = editorViewOptionButtons.selectedItem;
				var view:String = selectedItem ? selectedItem.value.toLowerCase() : "markup";
				//editorViewOptionButtons.selectedIndex = 0;
				//editorViewOptionButtons.validateNow();
				//editorViewOptionButtons.selectedIndex = event.index;
				editorViewOptionButtons.invalidateProperties();
				
				updateEditorOptions(view);
			}
			
			protected function editorOptionsLinkBarHandler(event:ItemClickEvent):void
			{
				var selectedItem:Object = event.item;
				var view:String = selectedItem ? selectedItem.value.toLowerCase() : "markup";
				//editorViewOptionButtons.selectedIndex = 0;
				//editorViewOptionButtons.validateNow();
				//editorViewOptionButtons.selectedIndex = event.index;
				editorViewOptionButtons.invalidateProperties();
				//editorViewOptionButtons.styleChanged(null);
				updateEditorOptions(view);
			}
			
			protected function updateEditorOptions(view:String ="markup"):void {
				
				// markup 
				if (view=="markup") {
					aceEditor.includeInLayout = aceEditor.visible = true;
					aceCSSEditor.includeInLayout = aceCSSEditor.visible = false;
				}
				else if (view=="css") {
					aceEditor.includeInLayout = aceEditor.visible = false;
					aceCSSEditor.includeInLayout = aceCSSEditor.visible = true;
				}
				else {
					aceEditor.includeInLayout = aceEditor.visible = true;
					aceCSSEditor.includeInLayout = aceCSSEditor.visible = true;
				}
			}
			
			private function getSelectedLanguage():String {
				var object:Object = languageTypeButtons.selectedItem;
				if (object) {
					return object.value;
				}
				return null;
			}
			
			private function setSelectedLanguage(language:String):void {
				var languageObject:Object;
				
				for (var i:int = 0; i < languageTypesArrayList.length; i++)  {
					languageObject = languageTypesArrayList.getItemAt(i);
					
					if (languageObject.value==language) {
						languageTypeButtons.selectedItem = languageObject;
						break;
					}
				}
			}
			
			private function isSelectedLanguage(language:String):Boolean {
				var languageObject:Object;
				languageObject = languageTypeButtons.selectedItem;
					
				if (languageObject && languageObject.value==language) {
					return true;
				}
				
				return false;
			}
			
			/*
			private function languageTypeLinkBar_changeHandler():void {
				var tempSelectedIndex:Number = languageTypeButtons.selectedIndex;
				
				for (var i:int; i<languageTypes.length;i++) {
					languageTypeButtons.selectedIndex = i;
					languageTypeButtons.validateNow();
				}
				
				languageTypeButtons.selectedIndex = tempSelectedIndex;
			}*/
			
			protected function resetTemplateButton_clickHandler(event:MouseEvent):void {
				var iDocument:IDocument = Radiate.selectedDocument;
				var showTemplate:Boolean = editTemplateButton.selected;
				
				if (iDocument) {
					DocumentManager.revertDocumentTemplate(iDocument);
				}
					
				if (templateEditor && iDocument) {
					templateEditor.text = iDocument.template;
				}
			}
			
			protected function editTemplateButton_clickHandler(event:MouseEvent = null):void {
				var iDocument:IDocument = Radiate.selectedDocument;
				var showTemplate:Boolean = editTemplateButton.selected;
				
				if (iDocument==null) {
					return;
				}
				
				if (templateEditor && showTemplate) {
					editingTemplate = true;
					templateEditor.text = iDocument.template ? iDocument.template : basicTemplate;
					templateEditor.visible = showTemplate;
					templateEditor.includeInLayout = showTemplate;
				}
				else {
					editingTemplate = false;
					iDocument.template = templateEditor.text;
					templateEditor.visible = showTemplate;
					templateEditor.includeInLayout = showTemplate;
				}
			}
			
			protected function uncaughtExceptionEvent(event:RadiateEvent):void
			{
				//trace("Uncaught Exception Event: " + event);
			}
			
			public var FIND:String = "find";
			
			private function createEditors():void {
				enableWordWrapButton.selected = enableWordWrap;
				embedImagesButton.selected = embedImages;
				
				// 1067: Implicit coercion of a value of type com.flexcapacitor.controls:AceEditor to an unrelated type Object
				
				aceEditorCreated = true;
				aceCSSEditorCreated = true;
				aceTemplateEditorCreated = true;
				
			}
			
			private var lastFocusedEditor:Object;
			
			/**
			 * Todo: Check why focus in or focus event not dispatched in the browser. 
			 * */
			private function editorFocusInHandler(event:Event):void {
				lastFocusedEditor = event.currentTarget;
				searchInput.aceEditor = lastFocusedEditor;
				
				if (enableWordWrapButton) {
					enableWordWrapButton.selected = lastFocusedEditor.useWordWrap;
				}
			}
			
			private function editorFindHandler(event:Event):void {
				lastFocusedEditor = event.currentTarget;
				searchInput.aceEditor = lastFocusedEditor;
				lastFocusedEditor.blur();
				searchInput.setFocus();
			}
			
			
			protected function embedImageButton_clickHandler(event:MouseEvent):void {
				var language:String = getSelectedLanguage();
				var exporter:TranscoderDescription = CodeManager.getExporter(language);
				
				if ("embedImages" in exporter.exporter) {
					// we set it when we generate code
					//Object(exporter.exporter).embedImages = embedImagesButton.selected;
				}
			}
			
			protected function wordwrapButton_clickHandler(event:MouseEvent):void
			{
				if (lastFocusedEditor) {
					lastFocusedEditor.useWordWrap = enableWordWrapButton.selected;
				}
				else if (aceEditor) {
					aceEditor.useWordWrap = enableWordWrapButton.selected;
				}
			}
			
			protected function showChildDescriptors_clickHandler(event:MouseEvent):void
			{
				updateCodeEditors(true);
			}
			
			protected function handleDocumentClosed(event:Event):void
			{
				
			}
			
			protected function importButton_clickHandler(event:MouseEvent):void {
				var code:String;
				var language:String;
				
				language = getSelectedLanguage();
				
				if (language==CodeManager.MXML) {
					code = aceEditor.text;
					importMXMLSource(code);
				}
			}
			
			protected function importMXMLSource(code:String, dispatchEvents:Boolean = true):void {
				var sourceData:SourceData;
				var validationInfo:XMLValidationInfo;
				var selectedDocument:IDocument = Radiate.selectedDocument;
				var selectedProject:IProject = Radiate.selectedProject;
				var container:Object;
				var importedTargets:Array;
				var currentTarget:Object;				
				var componentDescription:ComponentDescription;
				var parentComponentDescription:ComponentDescription;
				var currentIndex:int = -1;
				var dropIndex:int;
				var parentInstance:Object;
				var namespaces:Object;
				var namespacesString:String;
				var xml:XML;
				var errorLocation:String;
				var isValid:Boolean;
				var message:String;
				var rootString:String;
				var rootNodeName:String = MXMLDocumentConstants.ROOT_NODE_NAME;
				var updatedCode:String;
				var error:Object;
				var stringMethod:Boolean = true;
				var mxmlRenderTime:int;
				var preventDefaultMessages:Boolean;
				var mxmlOptions:MXMLImportOptions;
				
				// NOTE: 
				// this is importing on the fly and then removing a reference to the last target
				// this may be expensive not sure 
				// 
				// in time it would be better to check for attributes that have changed 
				// and only apply those
				// we would have to keep an updated XML reference
				// then we could use compare to find the attributes or child nodes on the selected 
				// node that have changed
				// see the LiveMXMLEditor for some initial work
				
				if (selectedDocument==null || selectedProject==null) {
					Radiate.warn("Please open a document before importing");
					return;
				}
				
				/*
				results = XMLUtils.getXMLFromStringWithNamespaces(code, MXMLDocumentConstants.getNamespaces());
				validationInfo = results as XMLValidationInfo;
				xml = results as XML;*/

				
				mxmlRenderTime = getTimer();
				isValid = XMLUtils.isValidXML(code);
				var browserErrorMessage:String;
				//error = XMLUtils.validationError;
				preventDefaultMessages = Radiate.preventDefaultMessages;
				Radiate.preventDefaultMessages = true;
				
				if (!isValid && code!="") {
					validationInfo = XMLUtils.validateXML(code, true);
					error = validationInfo.error;
					browserErrorMessage = validationInfo.browserErrorMessage;
					
					if (error is TypeError && error.errorID==1083 || namespaceError==browserErrorMessage) {
						
						if (stringMethod) {
							namespaces = MXMLDocumentConstants.getNamespaces();
							updatedCode = XMLUtils.addNamespacesToXMLString(code, namespaces);
						}
						else {
							namespacesString = MXMLDocumentConstants.getDefaultNamespaceDeclarations();
							//updatedCode = XMLUtils.getXMLFromStringWithNamespaces(code, namespacesString);
							
							rootString = '<'+rootNodeName + " " + namespacesString +'>';
							updatedCode = rootString + code + "</"+rootNodeName+">";
						}
						
						isValid = XMLUtils.isValidXML(updatedCode);
						
						if (isValid) {
							hideMessage();
						}
					}
					
					if (!isValid) {
						message = XMLUtils.validationError ? "" +  validationInfo.internalErrorMessage : warningMessage;
						if (message==null && validationInfo.browserErrorMessage!==null) {
							message = validationInfo.browserErrorMessage;
						}
						errorLocation = "At line " + (validationInfo.row) + " column " + validationInfo.column+ ":";
						showMessage(errorLocation, message, validationInfo.row-1, validationInfo.column);
						
						renderTime.text = "";
						renderTime.toolTip = "";
						return;
					}
				}
				else {
					hideMessage();
				}
				
				
				lastTarget = radiate.target;
				componentDescription = selectedDocument.getItemDescription(lastTarget);
				parentComponentDescription = componentDescription ? componentDescription.parent: null;
				
				if (parentComponentDescription && parentComponentDescription.instance) {
					parentInstance = parentComponentDescription.instance as IVisualElementContainer;
					currentIndex = parentComponentDescription.children.getItemIndex(componentDescription);
					
					if (currentIndex<parentComponentDescription.children.length-1) {
						
						if ("layout" in parentInstance && parentInstance.layout is BasicLayout) { 
							dropIndex = currentIndex + 1;
						}
						else {
							dropIndex = currentIndex + 2;
						}
					}
					
					//currentIndex = Math.max(0, currentIndex-1);
				}
				
				if (lastTarget is Application) {
					mxmlOptions = new MXMLImportOptions();
					//mxmlOptions.importChildNodes = false;
					mxmlOptions.removeAllOnImport = true;
					
					// not very efficient if setting an attribute - we need to refactor
					//Application(lastTarget).removeAllElements();
					//ComponentManager.removeElement(lastTarget);
				}
				else {
					if (lastTarget) {
						ComponentManager.removeElement(lastTarget);
					}
				}
				
				try {
					sourceData = ImportManager.importMXMLDocument(selectedProject, selectedDocument, code, parentInstance as IVisualElement, currentIndex, null, mxmlOptions, dispatchEvents, false);
				}
				catch (importError:Error) {
					HistoryManager.undo(selectedDocument);
					message = importError.toString();
					showMessage(errorLocation, message);
				}
				
				if (sourceData) {
					// move to correct location
					/*
					HistoryManager.disableHistoryManagement = true;
					for (var i:int = 0; i < importedTargets.length; i++) {
						currentTarget = importedTargets[i];
						
						ComponentManager.moveElement2(currentTarget, parentInstance, null, 
							null, RadiateEvent.MOVE_ITEM, AddItems.LAST, null, dropIndex);
						
					}
					
					HistoryManager.disableHistoryManagement = false;*/
					parentInstance = null;
					lastTarget = null;
					
					HistoryManager.mergeLastHistoryEvent(selectedDocument, "Updated source");
					if (sourceData.errors.length==0) {
						settingTargets = true;
						if (ComponentManager.lastCreatedComponent) {
							Radiate.setTargets(ComponentManager.lastCreatedComponent);
						}
						else {
							Radiate.setTargets(sourceData.targets);
						}
						settingTargets = false;
					}
					hideMessage();
				}
				else {
					validationInfo = XMLUtils.validateXML(code);
					error = validationInfo.error;
					
					if (error is TypeError && error.errorID==1083) {
						namespaces = MXMLDocumentConstants.getNamespaces();
						namespacesString = MXMLDocumentConstants.getDefaultNamespaceDeclarations();
						
						if (stringMethod) {
							updatedCode = XMLUtils.addNamespacesToXMLString(code, namespaces);
						}
						else {
							rootString = '<'+rootNodeName + " " + namespacesString +'>';
							updatedCode = rootString + code + "</"+rootNodeName+">";
						}
						
						isValid = XMLUtils.isValidXML(updatedCode);
						
						if (isValid) {
							hideMessage();
						}
					}
					
					message = XMLUtils.validationError ? "" +  validationInfo.internalErrorMessage : warningMessage;
					
					
					errorLocation = "At line " + (validationInfo.row) + " column " + validationInfo.column+ ":";
					showMessage(errorLocation, message, validationInfo.row-1, validationInfo.column);
				
					renderTime.text = "";
					renderTime.toolTip = "";
				}
				
				mxmlRenderTime = getTimer()-mxmlRenderTime;
				
				if (sourceData) {
					renderTime.text = mxmlRenderTime + "ms";
					renderTime.toolTip = mxmlRenderTime + "ms";
				}
				else {
					renderTime.text = "";
					renderTime.toolTip = "";
				}
				
				Radiate.preventDefaultMessages = preventDefaultMessages;
			}
			
			
			public var warningMessage:String = "Warning: XML is invalid and may not import correctly.";

			public var namespaceError:String = "XML Parsing Error: prefix not bound to a namespace";
			
			public function showMessage(firstMessage:String, secondMessage:String = null, row:int = -1, column:int = 0):void {
				lineError.text = firstMessage;
				warningLabel.text = secondMessage;
				errorGroup.visible = true;
				errorGroup.includeInLayout = true;
				aceEditor.clearAnnotations();
				aceEditor.setAnnotation(row, column, secondMessage, "error");
				editorGroup.bottom = 20;
			}
			
			public function hideMessage():void {
				errorGroup.visible = false;
				errorGroup.includeInLayout = false;
				lineError.text = "";
				warningLabel.text = "";
				
				if (aceEditor.aceFound) {
					aceEditor.clearAnnotations();
				}
				
				editorGroup.bottom = 0;
			}
			
			private function setupCodeComplete():void {
				var renderCommand:AceCommand;
				var saveCommand:AceCommand;
				var textFlowParser:ITextImporter;
				
				aceEditor.setCompleters([]);//aceEditor.setCompleters(null);
				//aceEditor.addCompleter(codeCompleter, getDocTooltip);
				aceEditor.addCompleter(codeCompleter);
				
				//aceEditor.addCommand(new AceCommand("find", {win: "Ctrl-B", "mac": "Cmd-B"}, findKeyboardHandler));
				
				saveCommand = new AceCommand("save");
				saveCommand.bindKey = {win: "Ctrl-S", "mac": "Cmd-S"};
				saveCommand.exec = saveKeyboardHandler;
				
				aceEditor.addCommand(saveCommand);
				
				renderCommand = new AceCommand("render");
				renderCommand.bindKey = {win: "Ctrl-Enter", "mac": "Cmd-Enter"};
				renderCommand.exec = renderKeyboardHandler;
				
				aceEditor.addCommand(renderCommand);
				
				aceEditor.blur();
				
				if (Platform.isDesktop) {
					cursorLocationLabel.visible = false;
					cursorLocationLabel.includeInLayout = false;
				}

				searchInput.aceEditor = aceEditor;
			}
			
			/**
			 * Appends text to the editor
			 * */
			public function appendEditorText(value:String):void {
				aceEditor.appendText(value);
			}
			
			
			public var cachedClassValues:Dictionary = new Dictionary(true);
			public var jumpingToMatching:Boolean;
			public var tokenInfo:TokenInformation;
			
			public var showToken:Boolean = false;
			public var showEntity:Boolean = false;
			public var showClassFound:Boolean = false;
			
			protected function cursorChangeHandler(event:AceEvent = null):void {
				var cursorString:String;
				var cursor:Object;
				var token:Object;
				var type:String;
				var entity:String = "";
				var output:String;
				var isMultiline:Boolean;
				var isMouseDown:Boolean;
				var tokenText:String = "";
				var entityText:String = "";
				var classFoundText:String = "";
				var count:int;
				var elementID:String;
				var idToken:TokenInformation;
				var searchResults:Object;
				
				//PerformanceMeter.mark("Start", true);
				isMultiline = aceEditor.isSelectionMultiline();
				isMouseDown = aceEditor.isMouseDown();
				
				if (isMultiline && isMouseDown) { return; }
				
				cursor = aceEditor.getCursor();
				token = aceEditor.getTokenAt(cursor.row, cursor.column);
				//PerformanceMeter.mark("After getTokenAt");
				type = token ? token.type : null;
				
				if (cursor.row<0 || cursor.column<0) {
					type = null;
					suggestions = [];
				}
				else {
					//if (hasEmbedded
					// if we have an embedded image then this takes way too much time
					tokenInfo = AceEditorUtils.getTokenInformation(aceEditor);
					suggestions = AceEditorUtils.getSuggestionList(tokenInfo, aceEditor);
					count = suggestions.length; //PerformanceMeter.mark("After getAutoCompleteList");
				}
				
				if (type!=null) {
					cursorString = aceEditor.getCursorString(cursor);
					entity = tokenInfo.entity ? tokenInfo.entity : "none";
					
					if (showToken) {
						tokenText = " Token: " + type;
					}
					
					if (showEntity) {
						entityText = " Entity: " + entity;
					}
					
					if (showClassFound) {
						classFoundText = " Class found: false" ;
					}
					
					if (tokenInfo.classFound==false) {
						output = cursorString + entityText + classFoundText + tokenText;
					}
					else {
						output = cursorString + entityText + tokenText;
					}
					
					if ("statusText" in parentApplication) {
						parentApplication["statusText"].text = output;
					}
					else {
						cursorLocationLabel.text = output;
					}
				}
				else {
					cursorString = aceEditor.getCursorString(cursor);
					cursorLocationLabel.text = cursorString;
				}
				
				if (linkButton.selected && aceCSSEditor.visible) {
					idToken = tokenInfo.idToken;
					elementID = idToken ? idToken.innerValue : null;
					
					if (elementID) {
						aceCSSEditor.moveCursorTo(0, 0);
						searchResults = aceCSSEditor.find("#" + elementID);
						
						if (searchResults) {
							aceCSSEditor.scrollToLine(searchResults.start.row);
							aceCSSEditor.clearSelection();
						}
					}
				}
				
				//PerformanceMeter.mark("After end of cursorChange");
				
			}
			
			public static const SNIPPET:String = "snippet";
			public var mainDocumentSuggestions:Array = [];
			public var suggestions:Array = [];
			
			public function codeCompleter(editor:Object, session:Object, position:Object, prefix:String, callback:Function):void {
				var row:int = position.row;
				var column:int = position.column;
				
				callback(null, suggestions);
			}
			
			public function getDocTooltip(item:AutoCompleteObject):void {
				
				
				if (item.type==SNIPPET && item.docHTML==null) {
					//trace("it's a snippet");
					
					item.docHTML = ["<b>", 
						aceEditor.language.escapeHTML(item.caption), 
						"</b>", 
						"<hr></hr>",
						aceEditor.language.escapeHTML(item.value)
					].join("");
					//ace.language.escapeHTML(item.snippet)
				}
				else if (item.docHTML==null) {
					item.docHTML = ["<b>", 
						aceEditor.language.escapeHTML(item.value), 
						"</b>", 
						"<hr></hr>",
						aceEditor.language.escapeHTML(item.caption)
					].join("");
					//trace("not a snippet");
				}
			}
			
			/**
			 * Handler for find keyboard shortcut
			 * */
			public function saveKeyboardHandler(editor:Object=null, event:Object=null):void {
				//trace("save keyboard event");
				if (debug) trace("saved");
				
				/*
				var iDocument:IDocument = radiate.selectedItem as IDocument;
				
				if (iDocument) {
					
					DeferManager.callAfter(250, saveDocument, iDocument);
					Radiate.info("Saving document '" + iDocument.name + "'");
				}
				else {
					Radiate.warn("No document selected");
				}
				*/
			}
			
			/**
			 * Handler for render view
			 * */
			public function renderKeyboardHandler(editor:Object=null, event:Object=null):void {
				//trace("Keyboard render event");
				//invalidateDesignView();
				var code:String = aceEditor.text;
				var language:String = getSelectedLanguage();
				
				if (language==CodeManager.MXML) {
					isCodeModifiedByUser = true;
					importMXMLSource(code);
					if (!updateCodeLive.selected) {
						isCodeModifiedByUser = false;
					}
				}
			}
			
			protected function cursorLocationLabel_clickHandler(event:MouseEvent):void
			{
				if (showEntity==false) {
					showEntity = true;
					showToken = false;
				}
				else if (showToken && showEntity) {
					showToken = false;
					showEntity = false;
				}
				else if (showEntity==true) {
					showToken = true;
				}
				else {
					showToken = true;
				}
				
				cursorChangeHandler();
			}
			
			protected function markupButton_clickHandler(event:MouseEvent):void {
				var showEditor:Boolean = markupButton.selected;
				
				if (aceEditor) {
					aceEditor.visible = showEditor;
					aceEditor.includeInLayout = showEditor;
				}
			}
			
			protected function stylesButton_clickHandler(event:MouseEvent):void {
				var showEditor:Boolean = stylesButton.selected;
				
				if (aceCSSEditor) {
					aceCSSEditor.visible = showEditor;
					aceCSSEditor.includeInLayout = showEditor;
				}
			}
			
			protected function linkButton_clickHandler(event:MouseEvent):void {
				if (linkButton.selected) {
					cursorChangeHandler();
				}
			}
			
			protected function languageTypeButtons_toolTipShowHandler(event:ToolTipEvent):void
			{
				
			}
			
			protected function copyIcon_clickHandler(event:MouseEvent):void {
				var source:String = sourceData.source;
				var clipboardManager:ClipboardManager = ClipboardManager.getInstance();
				
				clipboardManager.copyToClipboard(source);
				
			}
			
			protected function exportButton_clickHandler(event:MouseEvent):void {

				RunManager.openInCodePen(sourceData);
			}
			
		]]>
	</fx:Script>
	
	<fx:Declarations>

		<fx:String id="borderString">
		<![CDATA[
		function (id, rule, enabled) {
			var outlineStyleNode;
			var outlineStyleSheet;
			
			if (window.outlineStyleSheet==null) {
				window.outlineStyleSheet = {};
			}
			
			outlineStyleSheet = window.outlineStyleSheet[id];
			
			if (outlineStyleSheet==null) {
				outlineStyleNode = document.createElement("style");
				document.body.appendChild(outlineStyleNode);
				outlineStyleSheet = outlineStyleNode.sheet;
				window.outlineStyleSheet[id] = outlineStyleSheet;
				outlineStyleSheet.insertRule(rule, 0);
			}
			
			outlineStyleSheet.disabled = !enabled;
			return true;
		}
		]]>
		</fx:String>
		
		<!--- 
		adds zoom css for replicating preview
		-->
		<fx:String id="zoomCSS">
			<![CDATA[
IFRAME_ID {
    zoom: ZOOM_VALUE;
    -moz-transform: scale(ZOOM_VALUE);
    -moz-transform-origin: 0 0;
    -o-transform: scale(ZOOM_VALUE);
    -o-transform-origin: 0 0;
    -webkit-transform: scale(ZOOM_VALUE);
    -webkit-transform-origin: 0 0;
}
]]>
		</fx:String>
		
		
		<!-- If you use .button it causes sizing issues where the size of the button is 0 
		Firefox: 
		Paste the following code into the editor after all other html code (from style tag to style tag).
		And the class of the HTML button is set to class="button"
		
		Fix: 
		Rename "button" to "buttonSkin" and set class="buttonSkin". In time this will point to actual skins and defined styles.
		Look at buttonCSS2. 
		-->
		<fx:String id="buttonCSS">
			<![CDATA[
.button {
	position: absolute;
	background: url(assets/svg/button_skin_up.svg) 0 0 no-repeat;
	border: 0px;
}

.button:hover {
	background: url(assets/svg/button_skin_over.svg) 0 0 no-repeat;
}

.button:active {
	background: url(assets/svg/button_skin_down.svg) 0 0 no-repeat;
}
]]>
		</fx:String>
		
		
		<fx:String id="buttonCSS2">
			<![CDATA[
.buttonSkin {
	background: url(assets/svg/button_skin_up.svg) 0 0 no-repeat;
	border: 0px;
}

.buttonSkin:hover {
	background: url(assets/svg/button_skin_over.svg) 0 0 no-repeat;
	border: 0px;
}

.buttonSkin:active {
	background: url(assets/svg/button_skin_down.svg) 0 0 no-repeat;
	border: 0px;
}
]]>
		</fx:String>
		
		<s:ArrayList id="editorViewOptions">
			<fx:Array>
				<fx:Object label="Markup" value="markup"/>
				<fx:Object label="CSS" value="css"/>
				<fx:Object label="Markup+CSS" value="markupcss"/>
			</fx:Array>
		</s:ArrayList>
		
	</fx:Declarations>
	
	<s:states>
		<s:State name="normal"/>
	</s:states>
	
	
	<mx:HDividedBox id="editorGroup" 
					top="30" 
					width="100%" 
					height="100%" 
					minHeight="0"
					liveDragging="true">
		
		<c:AceEditor id="aceEditor" 
					 width="100%" 
					 height="100%"
					 mode="ace/mode/xml" 
					 showFoldWidgets="true" 
					 margin="{editorMargin}"
					 focusIn="editorFocusInHandler(event)"
					 focus="editorFocusInHandler(event)"
					 find="editorFindHandler(event)"
					 scrollSpeed=".5"
					 useWordWrap="{enableWordWrap}"
					 changeCursor="cursorChangeHandler(event)"
					 />
		
		<c:AceEditor id="aceCSSEditor" 
					 width="100%" 
					 height="100%"
					 mode="ace/mode/css" 
					 showFoldWidgets="true" 
					 margin="{editorMargin}"
					 focusIn="editorFocusInHandler(event)"
					 focus="editorFocusInHandler(event)"
					 find="editorFindHandler(event)"
					 scrollSpeed=".5"
					 useWordWrap="{enableWordWrap}"
					 visible="true"
					 includeInLayout="true"
					 />
		
		<c:AceEditor id="templateEditor" 
					 width="100%" 
					 height="100%"
					 mode="ace/mode/html" 
					 showFoldWidgets="true" 
					 margin="{editorMargin}"
					 focusIn="editorFocusInHandler(event)"
					 focus="editorFocusInHandler(event)"
					 find="editorFindHandler(event)"
					 scrollSpeed=".5"
					 useWordWrap="{enableWordWrap}"
					 visible="false"
					 includeInLayout="false"
					 />
		
	</mx:HDividedBox>
	
	
	<!-- FIRST ROW -->
	<s:HGroup left="0" right="0" 
			  width="100%"
			  clipAndEnableScrolling="true" 
			  paddingLeft="6" 
			  paddingRight="10"
			  verticalAlign="middle"
			  fontSize="9"
			  >
		
		<c:SolidFillButtonBar id="editorViewOptionButtons" 
							  requireSelection="true"
							  labelField="label"
							  toolTip="Select the code editors to view"
							  dataProvider="{editorViewOptions}"
							  click="editorViewOptionButtons_clickHandler(event)"
							  includeInLayout="false"
							  visible="false">
		</c:SolidFillButtonBar>
		
		<c:SolidFillButtonBar id="languageTypeButtons" 
							  selectedIndex="0"
							  toolTip="Select the language to generate"
							  toolTipShow="languageTypeButtons_toolTipShowHandler(event)"
							  click="languageType_changeHandler(null)">
		</c:SolidFillButtonBar>
		
		<c:BeveledImageToggleButton id="markupButton" 
									toolTip="Show markup editor" 
									selected="true"
									icon="{Radii8LibraryAssets.markup}"
									click="markupButton_clickHandler(event)"
									showBackgroundWhenSelected="true"/>
		
		<c:BeveledImageToggleButton id="stylesButton" 
									toolTip="Show styles editor" 
									selected="false"
									icon="{Radii8LibraryAssets.styles}"
									click="stylesButton_clickHandler(event)"
									showBackgroundWhenSelected="true"/>
		
		<c:BeveledImageToggleButton id="editTemplateButton" 
									icon="{Radii8LibraryAssets.document}"
									toolTip="Show web page template"
									showBackgroundWhenSelected="true"
									visible="{isHTML}"
									includeInLayout="{isHTML}"
									click="editTemplateButton_clickHandler(event)"/>
		
		<c:BeveledImageButton id="resetTemplateButton"
							  source="{Radii8LibraryAssets.refresh}"
							  toolTip="Reset template code"
							  click="resetTemplateButton_clickHandler(event)"
							  visible="{editTemplateButton.selected &amp;&amp; isHTML}"
							  includeInLayout="{editTemplateButton.selected &amp;&amp; isHTML}"
							  />
		
		
		<c:BeveledImageToggleButton id="linkButton" 
									toolTip="Scroll style into view when cursor is placed in component"
									selected="true"
									width="31"
									icon="{Radii8LibraryAssets.linkeditor}"
									click="linkButton_clickHandler(event)"
									showBackgroundWhenSelected="true"/>
		
		<!--<mx:LinkBar id="languageTypeLinkButtons"
					itemClick="languageTypeLinkBar_changeHandler()"
					selectionColor="0xFF0000"
					disabledColor="0x00FF00"
					dataProvider="{languageTypes}">
		</mx:LinkBar>-->
		
		<c:BeveledImageButton id="importButton"
							  source="{Radii8LibraryAssets.importInto}"
							  toolTip="Import MXML"
							  click="importButton_clickHandler(event)"
							  visible="{isMXML}"
							  includeInLayout="{isMXML}"
							  />
		
		
		<c:BeveledImageButton id="openDocumentInInternalWebIcon" 
							  source="{Radii8LibraryAssets.documentPlayIcon}" 
							  toolTip="View document inline with internal web browser"
							  smoothingQuality="high"
							  smooth="true"
							  width="18"
							  height="10"
							  click="previewButton_clickHandler(event)" 
							  />
		
		
		<c:BeveledImageToggleButton id="enableWordWrapButton"
							  source="{Radii8LibraryAssets.wordWrap}"
							  toolTip="Word wrap"
							  width="20"
							  height="16"
							  scaleMode="letterbox"
							  click="wordwrapButton_clickHandler(event)"
							  showBackgroundWhenSelected="true"
							  />
		
		<c:BeveledImageToggleButton id="embedImagesButton"
							  source="{Radii8LibraryAssets.image}"
							  toolTip="Embed local images"
							  width="20"
							  height="16"
							  scaleMode="letterbox"
							  click="embedImageButton_clickHandler(event)"
							  showBackgroundWhenSelected="true"
							  visible="false"
							  includeInLayout="false"
							  />
		
		
		<c:BeveledImageToggleButton id="showChildDescriptors"
									source="{Radii8LibraryAssets.treeViewOpen}"
									toolTip="Show nested elements"
									click="showChildDescriptors_clickHandler(event)"
									width="20"
									height="16"
									scaleMode="letterbox"
									showBackgroundWhenSelected="true"/>
		
		<c:BeveledImageButton id="resyncButton"
							  source="{Radii8LibraryAssets.refresh}"
							  toolTip="Revert to original code"
							  click="resyncButton_clickHandler(event)"
							  visible="{isHTML}"
							  includeInLayout="{isHTML}"
							  />
		
		<s:CheckBox id="updateCodeLive" 
					selected="false"
					label="Live"
					toolTip="Edit code live (experimental)"
					visible="{isHTML || isMXML}"
					includeInLayout="{isHTML || isMXML}"
					change="updateCodeLive_changeHandler(event)"/>
		
		<!-- enabled="{isCodeModifiedByUser}" -->
		<!-- enabled="{isCodeModifiedByUser}" -->
		
		<s:CheckBox id="showBackgroundImageCheckbox" 
					selected="false"
					label="Background Image"
					toolTip="Show a background screenshot image in the preview for comparison (experimental)"
					visible="{false}"
					includeInLayout="{false}"
					click="showBackgroundImageCheckbox_clickHandler(event)"/>
		
		<s:CheckBox id="setStylesInline" 
					selected="false"
					label="Styles inline"
					toolTip="Define styles in the markup"
					visible="{isHTML}"
					includeInLayout="{isHTML}"
					click="setStylesInline_clickHandler(event)"/>
		
		<s:CheckBox id="showBordersButton" 
					selected="false"
					label="Borders"
					toolTip="Show borders around elements"
					visible="{isHTML}"
					includeInLayout="{isHTML}"
					click="showBorders_clickHandler(event)"/>
		<s:Label id="renderTime" paddingTop="4" />
		
		<!--
		<s:Group id="redrawButton" 
				 click="showBorders_clickHandler(event)"
				 >
			<s:Rect id="fill" width="20" height="20" >
				<s:fill>
					<s:SolidColor color="#585858"/>
				</s:fill>
				<s:stroke>
					<s:SolidColorStroke id="strokeColor" color="#585858" weight="2"/>
				</s:stroke>
			</s:Rect>
			<s:Rect id="stroke" top="2" left="2" right="2" bottom="2">
				<s:stroke>
					<s:SolidColorStroke color="#FFFFFF" />
				</s:stroke>
			</s:Rect>
		</s:Group>-->
		
		<s:Spacer width="100%"/>
		
		<c:AceSearchTextInput id="searchInput" 
						   prompt="Search" 
						   minWidth="100"
						   width="100%"
						   focusAlpha="0"/>
		
		<c:BeveledImageButton id="copyIcon" 
					   source="{Radii8LibraryAssets.copy}" 
					   toolTip="Copy the code to the Clipboard"
					   verticalAlign="middle"
					   useHandCursor="true"
					   click="copyIcon_clickHandler(event)"
					   />
		<c:BeveledImageButton id="exportButton" 
							  source="{Radii8LibraryAssets.export}" 
							  toolTip="Export"
							  verticalAlign="middle"
							  useHandCursor="true"
							  visible="{isHTML}"
							  includeInLayout="{isHTML}"
							  click="exportButton_clickHandler(event)"/>
		
	</s:HGroup>
	
	
	<s:HGroup id="errorGroup" width="100%" verticalAlign="middle" 
			  bottom="5" left="5"
			  includeInLayout="false" visible="false">
		<s:Label id="lineError" 
				 x="15" y="15" 
				 text="" 
				 fontWeight="bold" 
				 color="red"/>
		
		<s:Label id="warningLabel" 
				 x="15" y="15" 
				 text="" 
				 fontWeight="bold" 
				 color="red"
				 width="100%"
				 maxDisplayedLines="1"/>
	</s:HGroup>
	
	
	<s:Label id="cursorLocationLabel" text="" bottom="0" right="10"
			 click="cursorLocationLabel_clickHandler(event)"/>
</s:Group>