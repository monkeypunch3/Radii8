<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 xmlns:filters="com.flexcapacitor.filters.*" 
		 xmlns:controls="com.flexcapacitor.controls.*"
		 
		 styleName="radiateInspector"
		 width="100%" 
		 minHeight="20"
		 creationComplete="creationCompleteHandler(event)" 
		 >
	
	<fx:Script>
		<![CDATA[
			import com.flexcapacitor.controller.Radiate;
			import com.flexcapacitor.events.HistoryEvent;
			import com.flexcapacitor.events.RadiateEvent;
			
			import mx.collections.ArrayCollection;
			import mx.events.FlexEvent;
			
			import spark.core.NavigationUnit;
			import spark.events.IndexChangeEvent;
			
			/**
			 * Not used. Possible use store sets of changes between targets
			 * */
			[Bindable]
			public var history:ArrayCollection = new ArrayCollection();
			
			/**
			 * When true removes all the items in the history when the target is null
			 * */
			public var clearOnTargetChange:Boolean = true;
			
			private var radiate:Radiate = Radiate.instance;
			
			private var _target:*;
			
			public function get target():* {
				return _target;
			}
			
			[Bindable]
			public function set target(value:*):void {
				_target = value;
				
				if (value==null) {
					if (clearOnTargetChange) {
						Radiate.removeAllHistory();
					}
				}
			}
			
			protected function creationCompleteHandler(event:FlexEvent):void {
				radiate.addEventListener(RadiateEvent.TARGET_CHANGE, targetChangeHandler, false, 0, true);
				radiate.addEventListener(RadiateEvent.HISTORY_CHANGE, historyChangeHandler, false, 0, true);
				
				scrollToBottom();
			}
			
			/**
			 * 
			 * */
			protected function targetChangeHandler(event:RadiateEvent):void {
				target = event.selectedItem;
			}
			
			/**
			 * 
			 * */
			public function redo():void {
				Radiate.redo();
				var index:int = list.selectedIndex;
				
				if (index>-1) {
					list.ensureIndexIsVisible(index);
				}
				else {
					list.ensureIndexIsVisible(0);
				}
			}
			
			/**
			 * 
			 * */
			public function undo():void {
				Radiate.undo();
				
				var index:int = list.selectedIndex;
				
				if (index>-1) {
					list.ensureIndexIsVisible(index);
				}
				else {
					list.ensureIndexIsVisible(0);
				}
			}
			
			/**
			 * Label for the history item
			 * */
			public function labelFunction(item:Object):String {
				var change:Object = item && item.length ? item[0] : null;
				var historyEvent:HistoryEvent;
				var label:String;
				
				historyEvent = HistoryEvent(Radiate.historyEventsDictionary[change]);
				
				if (historyEvent.action==RadiateEvent.PROPERTY_CHANGE) {
					label = historyEvent.description || historyEvent.properties + " changed";
				}
				else if (historyEvent.action==RadiateEvent.ADD_ITEM) {
					label = historyEvent.description || "Item added";
				}
				else if (historyEvent.action==RadiateEvent.REMOVE_ITEM) {
					label = historyEvent.description || "Item removed";
				}
				else if (historyEvent.action==RadiateEvent.MOVE_ITEM) {
					label = historyEvent.description || "Moved";
				}
				
				if (!historyEvent) return "";
				
				return label;
			}
			
			/**
			 * Show the last item in the list
			 * */
			private function scrollToBottom():void {
				// update the verticalScrollPosition to the end of the List
				// virtual layout may require us to validate a few times
				// code posted by a Flex SDK developer
				var delta:Number = 0;
				var count:int = 0;
				var iterations:int = 10;
				
				while (count++ < iterations) {
					list.validateNow();
					delta = list.layout.getVerticalScrollPositionDelta(NavigationUnit.END);
					list.layout.verticalScrollPosition += delta;
					
					if (delta == 0) {
						break;
					}
				}
			}
			
			protected function list1_clickHandler(event:MouseEvent):void {
				if (list.selectedItem) {
					
				}
			}
			
			/**
			 * 
			 * */
			protected function changeHandler(event:IndexChangeEvent):void
			{
				var newIndex:int = event.newIndex;
				var oldIndex:int = event.oldIndex;
				var length:int;
				
				if (newIndex<oldIndex) {
					length = oldIndex - newIndex;
					for (var i:int;i<length;i++) {
						undo();
					}
				}
				else if (newIndex>oldIndex) {
					length = newIndex - oldIndex;
					for (var j:int;j<length;j++) {
						redo();
					}
				}
				
				ensureIndexIsVisible(newIndex);
			}
			
			/**
			 * 
			 * */
			protected function historyChangeHandler(event:Event):void {
				
			}
			
			/**
			 * 
			 * */
			public function ensureIndexIsVisible(index:int=0):void {
				
				list.ensureIndexIsVisible(index);
				list.validateNow();
				list.ensureIndexIsVisible(index);
			}
			
			/**
			 * 
			 * */
			public function ensureLastItemVisible():void {
				if (list.dataProvider.length>0) {
					ensureIndexIsVisible(list.dataProvider.length-1);
					scrollToBottom();
				}
			}
			
			/**
			 * 
			 * */
			protected function revertHandler(event:MouseEvent):void {
				
				var length:int = list.selectedIndex+1;
				var i:int;
				
				if (length>10) {
					for (i;i<length;i++) {
						undo();
					}
				}
				else {
					for (i;i<length;i++) {
						undo();
					}
				}
				
				list.selectedIndex = -1;
				
				ensureIndexIsVisible(0);
			}
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<fx:Array id="selectFiltersOn">
			<filters:BlackAndWhiteFilter />
			<s:DropShadowFilter distance="1" blurX="3" blurY="3" strength=".8" inner="true" knockout="false"/>
		</fx:Array>
		<fx:Array id="selectFiltersOff">
			<filters:BlackAndWhiteFilter  />
		</fx:Array>
		
	</fx:Declarations>
	
	<s:Group width="100%" height="100%" left="5" right="5" bottom="5">
		
		<s:List id="list" 
				top="14"
				width="100%" height="100%"
				minHeight="20"
				interactionMode="mouse"
				dataProvider="{Radiate.history}" 
				selectedIndex="{Radiate.historyIndex}"
				labelFunction="labelFunction"
				borderVisible="false"
				focusAlpha="0"
				click="list1_clickHandler(event)"
				change="changeHandler(event)">
			
			<s:layout>
				<s:VerticalLayout useVirtualLayout="false" gap="1"/>
			</s:layout>
			
			<s:itemRenderer>
				<fx:Component>
					<s:ItemRenderer width="100%" height="18" 
									autoDrawBackground="false"
									typographicCase="lowercaseToSmallCaps"
									useHandCursor="true"
									buttonMode="true"
									creationComplete="creationCompleteHandler(event)"
									>
						
						<fx:Script>
							<![CDATA[
								import com.flexcapacitor.filters.BlackAndWhiteFilter;
								
								import mx.events.FlexEvent;
								
								import spark.components.List;
								import spark.events.IndexChangeEvent;
								
								[Bindable]
								private static var filtersArray:Array = [new BlackAndWhiteFilter()];
								
								override public function set data(value:Object):void {
									super.data = value;
									updateRow();
								}
								
								protected function creationCompleteHandler(event:FlexEvent):void
								{
									owner.addEventListener(IndexChangeEvent.CHANGE, changeHandler, false, 0, true);
									owner.addEventListener(FlexEvent.VALUE_COMMIT, valueCommitHandler, false, 0, true);
								}
								
								private function updateRow():void {
									var selectedIndex:int = (owner as List).selectedIndex;
									
									if (selectedIndex<itemIndex) {
										rowGroup.enabled = false;
									}
									else {
										rowGroup.enabled = true;
									}
								}
								
								private function changeHandler(event:IndexChangeEvent):void
								{
									var selectedIndex:int = event.newIndex;
									
									if (selectedIndex<itemIndex) {
										rowGroup.enabled = false;
									}
									else {
										rowGroup.enabled = true;
									}
								}
								
								private function valueCommitHandler(event:FlexEvent):void {
									var selectedIndex:int = (owner as List).selectedIndex;
									
									if (selectedIndex<itemIndex) {
										rowGroup.enabled = false;
									}
									else {
										rowGroup.enabled = true;
									}
								}
							]]>
						</fx:Script>
						
						<s:states>
							<s:State name="normal"/>
							<s:State name="selected"/>
							<s:State name="hovered"/>
						</s:states>
						
						<s:HGroup id="rowGroup" width="100%" height="100%" gap="0" verticalAlign="middle">
							  
							<s:Group height="12" width="10" includeIn="selected,hovered">
								<s:Path data="M 0 0 L 0 16 L 16 8 z" width="100%" height="100%">
									<s:fill>
										<s:SolidColor color="#000000" alpha=".5" alpha.hovered=".25"/>
									</s:fill>
									<s:stroke>
										<s:SolidColorStroke weight="0" color="#ffffff" />
									</s:stroke>
								</s:Path>
							</s:Group>
							
							<s:Spacer width="10" includeIn="normal"/>
							
							
							<s:BitmapImage source="{Radii8LibraryAssets.edit}" 
										   filters="{filtersArray}" />
							
							<s:Spacer width="4" />
							
							<s:Label id="labelDisplay" 
									 fontSize="11"
									 width="100%" 
									 paddingTop="2" />
						</s:HGroup>
					</s:ItemRenderer>
				</fx:Component>
			</s:itemRenderer>
		</s:List>
		
		
		<!--- triangle -->
		<s:Group height="14" width="10" >
			<s:Path data="M 0 0 L 0 16 L 16 8 z" width="100%" height="100%"
					visible="{list.selectedIndex==-1 &amp;&amp; list.dataProvider.length>0}">
				<s:fill>
					<s:SolidColor color="#000000" alpha=".25"/>
				</s:fill>
				<s:stroke>
					<s:SolidColorStroke weight="0" color="#ffffff" />
				</s:stroke>
			</s:Path>
			<s:Line width="40" x="13" y="5" >
				<s:stroke>
					<s:SolidColorStroke alpha=".15"/>
				</s:stroke>
			</s:Line>
		</s:Group>
		
		<s:HGroup width="100%" right="0" top="0" verticalAlign="top">
			
			<!--- revert to beginning -->
			<s:Group width="50%" height="8" click="revertHandler(event)" useHandCursor="true" buttonMode="true">
				<s:Rect width="100%" height="8" >
					<s:fill>
						<s:SolidColor alpha="0"/>
					</s:fill>
				</s:Rect>
			</s:Group>
			
			<s:Spacer width="100%"/>
			
			<!--- go back -->
			<s:Group click="undo()" 
					 width="16"
					 height="10"
					 filters="{selectFiltersOff}"
					 enabled="{list.selectedIndex!=-1 &amp;&amp; list.dataProvider.length>0}"
					 useHandCursor="true"
					 buttonMode="true"
					 >
				<s:Path data="M 8 0 L 8 16 L 0 8 Z" height="10" width="10">
					<s:fill>
						<s:SolidColor color="#000000" alpha=".5"/>
					</s:fill>
				</s:Path>
			</s:Group>
			
			
			<!--- go forward -->
			<s:Group click="redo()" 
					 width="16"
					 height="10"
					 filters="{selectFiltersOff}"
					 enabled="{list.dataProvider.length &amp;&amp; list.selectedIndex+1!=list.dataProvider.length}"
					 useHandCursor="true"
					 buttonMode="true">
				<s:Path data="M 0 0 L 0 16 L 16 8 L 0 0 Z" height="10" width="10">
					<s:fill>
						<s:SolidColor color="#000000" alpha=".5"/>
					</s:fill>
				</s:Path>
			</s:Group>
			<!--<controls:ImageButton source="{Radii8LibraryEditAssets.undo}" 
								  height="15"
								  alpha=".8"
								  click="undo()" 
								  filters="{selectFiltersOff}"/>
			<controls:ImageButton source="{Radii8LibraryEditAssets.redo}"
								  height="15"
								  alpha=".8"
								  click="redo()" 
								  filters="{selectFiltersOff}" />-->
		</s:HGroup>
	</s:Group>
	
</s:Group>
