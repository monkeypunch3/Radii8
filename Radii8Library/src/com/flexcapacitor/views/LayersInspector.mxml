<?xml version="1.0" encoding="utf-8"?>
<s:VGroup xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 xmlns:views="com.flexcapacitor.views.*"
		 xmlns:renderers="com.flexcapacitor.views.renderers.*"
		 xmlns:c="com.flexcapacitor.controls.*"
		 xmlns:core="com.flexcapacitor.effects.core.*" 
		 xmlns:panels="com.flexcapacitor.views.panels.*" 
		 
		 width="220" 
		 height="100%"
		 implements="com.flexcapacitor.views.IInspector" 
		 >
	
	<!-- 
	
	UPDATE OCT 2015 
	- might not be as buggy since refactoring the document.componentDescription getter 
	- that function was recreating instances of the componentDescriptions. it no longer recreates them
	
	THIS LAYERS TREE DRAGGING AND DROPPING IS/WAS BUGGY 
	- the branch nodes don't accept items being dragged into them for the most part 
	unless they are open already or have items already in them
	- once an item is added it shows up double. only by switching tabs does the
	layers get back to the right order and right count. 
	
	UPDATE: Fixed by using call later
	or timeout, don't remember, but still hacky
	Added a hgroup to a bordercontainer and this error: 
	
	Error: Unknown Property: '-1'.
	at mx.collections::ListCollectionView/http://www.adobe.com/2006/actionscript/flash/proxy::getProperty()[E:\dev\4.y\frameworks\projects\framework\src\mx\collections\ListCollectionView.as:870]
	at mx.controls.treeClasses::HierarchicalViewCursor/get current()[E:\dev\4.y\frameworks\projects\mx\src\mx\controls\treeClasses\HierarchicalViewCursor.as:212]
	at mx.controls.treeClasses::HierarchicalViewCursor/collectionChangeHandler()[E:\dev\4.y\frameworks\projects\mx\src\mx\controls\treeClasses\HierarchicalViewCursor.as:869]
	at flash.events::EventDispatcher/dispatchEventFunction()
	
	When dragging and dropping using Flex 4.15 getting error: 
	
	TypeError: Error #1010: A term is undefined and has no properties.
	at mx.controls::Tree/updateDropData()[/Users/justinmclean/Documents/ApacheFlex4.15/frameworks/projects/mx/src/mx/controls/Tree.as:2785]
	at mx.controls::Tree/calculateDropIndex()[/Users/justinmclean/Documents/ApacheFlex4.15/frameworks/projects/mx/src/mx/controls/Tree.as:1276]
	at mx.controls::Tree/dragDropHandler()[/Users/justinmclean/Documents/ApacheFlex4.15/frameworks/projects/mx/src/mx/controls/Tree.as:3352]
	at flash.events::EventDispatcher/dispatchEventFunction()
	at flash.events::EventDispatcher/dispatchEvent()
	at mx.core::UIComponent/dispatchEvent()[/Users/justinmclean/Documents/ApacheFlex4.15/frameworks/projects/framework/src/mx/core/UIComponent.as:13688]
	at mx.managers::NativeDragManagerImpl/_dispatchDragEvent()[/Users/justinmclean/Documents/ApacheFlex4.15/frameworks/projects/airframework/src/mx/managers/NativeDragManagerImpl.as:766]
	at mx.managers::NativeDragManagerImpl/nativeDragEventHandler()[/Users/justinmclean/Documents/ApacheFlex4.15/frameworks/projects/airframework/src/mx/managers/NativeDragManagerImpl.as:739]

	drag and drop appears to work but error is thrown. 
	created bug and patch at apache flex bug base
	
	
	-->
	
	<fx:Script>
		<![CDATA[
			import com.flexcapacitor.controller.Radiate;
			import com.flexcapacitor.events.RadiateEvent;
			import com.flexcapacitor.managers.ArrangeLayers;
			import com.flexcapacitor.managers.ViewManager;
			import com.flexcapacitor.model.AccessorMetaData;
			import com.flexcapacitor.model.Document;
			import com.flexcapacitor.model.IDocument;
			import com.flexcapacitor.utils.ClassUtils;
			import com.flexcapacitor.utils.supportClasses.ComponentDefinition;
			import com.flexcapacitor.utils.supportClasses.ComponentDescription;
			import com.flexcapacitor.views.supportClasses.LayersDataDescriptor;
			
			import mx.collections.ArrayCollection;
			import mx.core.DragSource;
			import mx.core.IUIComponent;
			import mx.core.IVisualElement;
			import mx.core.IVisualElementContainer;
			import mx.core.mx_internal;
			import mx.events.DragEvent;
			import mx.events.ListEvent;
			import mx.events.TreeEvent;
			import mx.managers.DragManager;
			import mx.states.AddItems;
			
			import spark.components.Application;
			import spark.components.supportClasses.DisplayLayer;
			import spark.components.supportClasses.GroupBase;
			import spark.events.PopUpEvent;
			
			private var rootDisplayObject:DisplayObject;
			private var displayList:Array = [];
			private var radiate:Radiate;
			private var designDocument:IEventDispatcher;
			
			protected var isBranchDescriptor:LayersDataDescriptor;
			
			[Bindable]
			public var components:ArrayCollection = new ArrayCollection();
			
			private var _target:*;
			
			public function get target():* {
				return _target;
			}
			
			[Bindable]
			public function set target(value:*):void {
				_target = value;
			}
			
			public function activate(selectedTarget:Object = null):void {
				radiate = Radiate.instance;
				
				if (!isBranchDescriptor) {
					isBranchDescriptor = new LayersDataDescriptor();
					componentListTree.dataDescriptor = isBranchDescriptor;
				} 
				
				updateComponentDisplayList();
				
				radiate.addEventListener(RadiateEvent.TARGET_CHANGE, targetChangeHandler, false, 0, true);
				radiate.addEventListener(RadiateEvent.HISTORY_CHANGE, addItemChangeHandler, false, 0, true);
				radiate.addEventListener(RadiateEvent.DOCUMENT_CHANGE, documentChangeHandler, false, 0, true);
				radiate.addEventListener(RadiateEvent.DOCUMENT_UPDATED, documentUpdatedHandler, false, 0, true);
				radiate.addEventListener(RadiateEvent.DOCUMENT_REVERTED, documentChangeHandler, false, 0, true);
				//radiate.addEventListener(RadiateEvent.ADD_ITEM, addItemChangeHandler, false, 0, true);
				//radiate.addEventListener(RadiateEvent.MOVE_ITEM, addItemChangeHandler, false, 0, true);
				//radiate.addEventListener(RadiateEvent.REMOVE_ITEM, addItemChangeHandler, false, 0, true);
				radiate.addEventListener(RadiateEvent.PROPERTY_CHANGED, propertyChangeHandler, false, 0, true);
				
				if (radiate.target) {
					updateTarget(radiate.target);
				}
				
				componentListTree.addEventListener("lock", lockRendererClicked);
			}
			
			public function deactivate():void {
				if (radiate) {
					
					radiate.removeEventListener(RadiateEvent.TARGET_CHANGE, targetChangeHandler);
					radiate.removeEventListener(RadiateEvent.HISTORY_CHANGE, addItemChangeHandler);
					radiate.removeEventListener(RadiateEvent.DOCUMENT_CHANGE, documentChangeHandler);
					radiate.removeEventListener(RadiateEvent.DOCUMENT_UPDATED, documentUpdatedHandler);
					radiate.removeEventListener(RadiateEvent.DOCUMENT_REVERTED, documentChangeHandler);
					//radiate.removeEventListener(RadiateEvent.ADD_ITEM, addItemChangeHandler);
					//radiate.removeEventListener(RadiateEvent.MOVE_ITEM, addItemChangeHandler);
					//radiate.removeEventListener(RadiateEvent.REMOVE_ITEM, addItemChangeHandler);
					radiate.removeEventListener(RadiateEvent.PROPERTY_CHANGED, propertyChangeHandler);
					
					target = null;
				}
			}
			
			/**
			 * Found on blog by Flex SDK developer (source).
			 * Not used. For reference.
			 */
			public function sortDisplayByDepth(item:Object, parentItem:Object = null, depth:int = 0):void {
				
				
				if (displayList.length <= depth) {
					displayList.push(new ArrayCollection());
				}
				
				
				if ("numElements" in item) {
					for (var i:int = 0; i < item.numElements; i++) {
						var child:Object = item.getElementAt(i);
						sortDisplayByDepth(child, parentItem, depth + 1);
						displayList[depth].push(child);
					}
				}
				
			}
			
			
			private function labelFunction(data:Object):String {
				if (!data) return ""; 
				var identity:String =  ClassUtils.getIdentifier(data.instance);
				
				/*if (identity) {
					return data.name + " (" + identity + ")";
				}*/
				
				if (String(data.name).toLowerCase()=="application") {
					return "Document";
				}
				
				return data.name;
			}
			
			/**
			 * When the target changes reselect it 
			 * */
			protected function targetChangeHandler(event:RadiateEvent):void {
				updateTarget(event.selectedItem);
				
				controlsGroup.enabled = event.selectedItem ? true : false;
			}
			
			/**
			 * 
			 * */
			public function updateTarget(selectedItem:Object):void {
				var item:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
				var collection:ArrayCollection = componentListTree.dataProvider as ArrayCollection;
				var rootApplicationDescription:ComponentDescription;
				var targetDescription:ComponentDescription;
				var parent:ComponentDescription;
				var iDocument:IDocument = radiate.selectedDocument;
				
				target = selectedItem;
				
				if (selectedItem==null) {
					collection.removeAll();
					updateComponentDisplayList();
					return;
				}
				
				if (collection.length==0) {
					updateComponentDisplayList();
					collection = componentListTree.dataProvider as ArrayCollection;
				}
				
				if (target && collection.length) {
					iDocument.updateComponentTree();
					rootApplicationDescription = collection.getItemAt(0) as ComponentDescription;
					
					if (rootApplicationDescription) {
						//targetDescription = DisplayObjectUtils.getTargetInComponentDisplayList(target, rootApplicationDescription);
						targetDescription = iDocument.getItemDescription(target);
						
						
						if (targetDescription) {
							
							parent = targetDescription.parent;
							
							while (parent) {
								
								// open item if not open
								if (!componentListTree.isItemOpen(parent)) {
									componentListTree.expandItem(parent, true, false, false);
									componentListTree.validateNow();
								}
								
								parent = parent.parent;
							}
							
							
							// NOTE: IMPORTANT: READ: the open items can't be reassigned references. they have to be actual items
							// ALSO we are resetting the dataProvider so it's not going to find the items
							//for (var i:int;i<numberOfItems;i++) {
								//displayListTree.expandItem(openItems[i], true, false, false);
								//trace("expanding");
							//}
							
							componentListTree.selectedItem = targetDescription;
						}
					}
				}
				
				//openAllItems();
				updateTreeHeight();
				scrollIntoView();
				
				// update alpha
				updateAlphaProperty();
				updateLockedProperty();
				updateMaskedProperty();
				
			}
			
			/**
			 * Open all items
			 * */
			public function openAllItems():void {
				var item:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
				var collection:ArrayCollection = componentListTree.dataProvider as ArrayCollection;
				var rootApplicationDescription:ComponentDescription;
				var targetDescription:ComponentDescription;
				var parent:ComponentDescription;
				
				if (item && target!=item.instance) {
					//updateComponentDisplayList();
				}
				
				if (collection.length==0) {
					collection = componentListTree.dataProvider as ArrayCollection;
				}
				
				if (collection.length<1) return;
				rootApplicationDescription = collection.getItemAt(0) as ComponentDescription;
				
				for (var i:int;i<rootApplicationDescription.children.length;i++) {
					componentListTree.expandChildrenOf(rootApplicationDescription.children[i], true);
					componentListTree.validateNow();
				}
				
			}
			
			/**
			 * Close all items
			 * */
			public function closeAllItems():void {
				var item:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
				var collection:ArrayCollection = componentListTree.dataProvider as ArrayCollection;
				var rootApplicationDescription:ComponentDescription;
				var targetDescription:ComponentDescription;
				var parent:ComponentDescription;
				
				if (item && target!=item.instance) {
					//updateComponentDisplayList();
				}
				
				if (collection.length==0) {
					collection = componentListTree.dataProvider as ArrayCollection;
				}
				
				if (collection.length<1) return;
				rootApplicationDescription = collection.getItemAt(0) as ComponentDescription;
				
				for (var i:int;i<rootApplicationDescription.children.length;i++) {
					componentListTree.expandChildrenOf(rootApplicationDescription.children[i], false);
					componentListTree.validateNow();
				}
				
			}
			
			/**
			 * 
			 * */
			protected function documentChangeHandler(event:Event):void {
				// commented out the check because of document reverted event (which creates new instances)
				//if (designDocument!=radiate.selectedDocument) {
					updateComponentDisplayList(false);
				//}
				
			}
			
			/**
			 * Select target
			 * */
			protected function displayListTree_changeHandler(event:ListEvent):void {
				var item:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
				
				if (item) {
					radiate.setTarget(item.instance as IEventDispatcher, true);
				}
				
				if (item && !(item.instance is Application)) {
					documentItemRenderer.selected = false;
				}
				
				/* 
				if (!preventChange) {
				}
				else {
					displayListTree.selectable
				}
				
				preventChange = false; */
			}
			
			/**
			 * Recreate the display list and open all items.
			 * */
			public function updateComponentDisplayList(preserveOpenItems:Boolean = true):void {
				var openItem:Object;
				var openItems:Object;
				var iDocument:IDocument;
				var rootComponentDescription:Object;
				var numberOfOpenItems:int;
				var selectedItems:Array;
				var selectedItem:Object;
				
				iDocument = radiate.selectedDocument;
				
				if (iDocument is Document) {
					Document(iDocument).updateComponentTree();
				}
				
				if (iDocument) {
					documentItemRenderer.data = iDocument.componentDescription;
				}
				
				if (!iDocument) {
					openItems = [];
					componentListTree.dataProvider = null;
					return;
				}
				
				openItems = componentListTree.openItems;
				
				// we need to create a list of the instances of open items
				// componentDescription.instance not componentDescription
				
				// we could check for the target and update that branch
				rootComponentDescription = iDocument.componentDescription;
				selectedItem = componentListTree.selectedItem;
				//selectedItems = radiate.targets;
				componentListTree.dataProvider = rootComponentDescription;
				
				// 
				//DisplayObjectUtils.walkDownTree(application as IVisualElement, traceTree);
				
				
				if (preserveOpenItems) {
					componentListTree.validateNow();
					
					/* for each (var item:ComponentDescription in openItems) {
						displayListTree.expandItem(item, true, false, false);
						//trace("expanding");
					}
					 */
					numberOfOpenItems = openItems.length;
					
					// NOTE: IMPORTANT: READ: the open items can't be reassigned references. they have to be actual items
					// ALSO we are resetting the dataProvider so it's not going to find the items if we do that
					for (var i:int;i<numberOfOpenItems;i++) {
						openItem = openItems[i];
						if (!componentListTree.isItemOpen(openItem)) {
							componentListTree.expandItem(openItem, true, false, false);
							componentListTree.validateNow();
						}
						//trace("expanding");
					}
				}
				
				// for multiple targets we should loop through radiate.targets, 
				// get the component descriptions and set them here
				componentListTree.selectedItem = selectedItem;
			}
			
			public function traceTree(element:Object):void {
				//trace("element="+NameUtil.getUnqualifiedClassName(element));
			}
			
			/**
			 * 
			 * */
			private function findTargetInDisplayList1(target:Object, parentItem:ComponentDescription, depth:int = 0):ComponentDescription {
				var length:int = parentItem.children ? parentItem.children.length : 0;
				var possibleItem:ComponentDescription;
				var item:ComponentDescription;
				var itemFound:Boolean;
				
				for (var i:int; i < length; i++) {
					item = parentItem.children.getItemAt(i) as ComponentDescription;
					
					if (item && item.instance==target) {
						itemFound = true;
						break;
					}
					
					if (item.children) {
						possibleItem = findTargetInDisplayList1(target, item, depth + 1);
						
						if (possibleItem) {
							itemFound = true;
							item = possibleItem;
							break;
						}
					}
					
				}
				
				if (itemFound) return item;
				
				return null;
			}
			
			/**
			 * Add item handler
			 * */
			protected function addItemChangeHandler(event:RadiateEvent):void {
				updateComponentDisplayList();
			}
			
			/**
			 * Move item handler
			 * */
			protected function moveItemChangeHandler(event:RadiateEvent):void {
				updateComponentDisplayList();
			}
			
			/**
			 * Item open handler
			 * */
			protected function displayListTree_itemOpenHandler(event:TreeEvent):void {
				updateTreeHeight()
			}
			
			/**
			 * 
			 * */
			public function getTotalRowCount(item:ComponentDescription, numberOfRows:int = 0):int {
				
				if (item && item.children && item.children.length>0) {
					// NOTE: IMPORTANT: READ: the open items can't be reassigned references. they have to be actual items
					// ALSO we are resetting the dataProvider so it's not going to find the items if we do that
					for (var i:int;i<item.children.length;i++) {
						numberOfRows++;
						if (componentListTree.isItemOpen(item.children[i])) {
							numberOfRows = getTotalRowCount(item.children[i] as ComponentDescription, numberOfRows);
						}
					}
				}
				
				return numberOfRows;
			}
			
			/**
			 * Resize the tree to be as high as all open items
			 * */
			public function updateTreeHeight():void {
				var newHeight:int = componentListTree.rowCount * componentListTree.rowHeight;
				var numChildren:int = componentListTree.numChildren;
				var openItems:Object = componentListTree.openItems;
				var openItemsLength:int = componentListTree.openItems.length;
				var dataProvider:Object = componentListTree.dataProvider;
				var dataProviderLength:int = componentListTree.dataProvider.length;
				var item:ComponentDescription;
				var count:int = 2; // application plus one for easier drop on last row
				
				var newCount:int = getTotalRowCount(dataProvider[0] as ComponentDescription, count);
				
				newHeight = newCount * componentListTree.rowHeight;
				// ArgumentError: Error #2004: One of the parameters is invalid.
				//	at flash.display::Graphics/drawRect()
				//displayListTree.setActualSize(NaN, newHeight);
				//displayListTree.height = newHeight;
				componentListTree.explicitHeight = newHeight;
			}
			
			// THIS IS ALL TO HANDLE SCROLLING INSIDE ANOTHER SCROLLER THAT HAS TOUCH INTERACTION
			// SPARK COMPONENTS DON'T HAVE THIS PROBLEM
			private var mouseDownLocation:int;
			public var preventChange:Boolean;
			
			protected function displayListTree_mouseDownHandler(event:MouseEvent):void {
				mouseDownLocation = event.stageY;
				stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler, false, 0, true);
				stage.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler, false, 0, true);
			}
			
			protected function mouseMoveHandler(event:MouseEvent):void {
				
				var diff:int = Math.abs(event.stageY - mouseDownLocation);
				
				if (diff>10) {
					componentListTree.selectable = false;
				}
			}
			
			protected function mouseUpHandler(event:MouseEvent):void {
				stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);
				stage.removeEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
				componentListTree.selectable = true;
			}
			
			protected function displayListTree_itemCloseHandler(event:TreeEvent):void {
				updateTreeHeight();
			}
			
			private function scrollIntoView():void {
				
				if (componentListTree.selectedIndex>-1) {
					componentListTree.scrollToIndex(componentListTree.selectedIndex);
				}
			}
			
			/**
			 * 
			 * */
			protected function displayListTree_dragDropHandler(event:DragEvent):void {
				//Radiate.info("Drag drop handler");
				event.draggedItem;
				event.target;
				event.relatedObject;
				
				/*
	            Pay attention at mx_internal namespace :
	            Behaviour could change in the next flex version.
	            Drop data structure.
	            _dropData = { 
	                parent: parent, 
	                index: index, 
	                localX: event.localX, 
	                localY: event.localY, 
	                emptyFolder: emptyFolder, 
	                rowHeight: rowHeight, 
	                rowIndex: rowNum };
	            */
	            var dropData:Object = componentListTree.mx_internal::_dropData;
	            var dropParent:Object = dropData.parent;
	            var dropIndex:int = dropData.index;
	            var rowIndex:int = dropData.rowIndex;
	            var draggedElement:Object = (event.dragSource.dataForFormat("treeItems") as Array)[0];
				var draggedElementParent:Object = draggedElement.parent;
				var canDragOutOfParent:Boolean = !componentListTree.showRoot;
				var currentIndex:int;
				var isSameParent:Boolean = dropParent && dropParent == draggedElementParent;
				
	            if (!canDragOutOfParent && !isSameParent) {
					
	                // element is an item and parent is different => can not drop                                        
	                event.preventDefault();
	                componentListTree.hideDropFeedback(event);
					return;
	            }

	            // you can also play with
	            //var dropIndex:int = displayListTree.calculateDropIndex(event);
	            //var itemIndex:int = displayListTree.getItemIndex(dropIndex);
				
	            // but it is a little more complicated to find 
	            // the real parent because we haven't drop indicator 
	            // information (child or parent position).
	
	            // I did not use xml element id but it is also possible
	            // parent.id != draggedElement.parent().id
				
				// some reason there is a bug when on the application
				// we have to subtract one from the drop index if it's lower than it's current index
				if (dropParent && isSameParent) {
					currentIndex = ComponentDescription(dropParent).children.getItemIndex(draggedElement);
					
					if (dropParent.instance is Application) {
						
						// when dragging to an index after our index we have to subtract one
						if (currentIndex<dropIndex) {
							dropIndex--;
							//Radiate.info("Lowering index");
						}
					}
					else if (currentIndex==0 && (dropIndex==0 || dropIndex==1)) {
						// if same parent and first index
						// and drop is first or second index we don't need to move
						event.preventDefault();
						componentListTree.hideDropFeedback(event);
						return;
					}
				}
				
				if (dropParent && isSameParent) {
					currentIndex = ComponentDescription(dropParent).children.getItemIndex(draggedElement);
					
					// when dragging to an index after our index we have to subtract one
					if (currentIndex<dropIndex) {
						dropIndex--;
						//Radiate.info("Lowering index");
					}
				}
				
				
				// make sure application can't be dropped into itself
				if (draggedElement.instance is Application) {
	                event.preventDefault();
	                componentListTree.hideDropFeedback(event);
					return;
				}
				
				// make sure container can't be dropped into child container
				if (draggedElement.instance is DisplayObjectContainer &&
					dropParent && 
					dropParent.instance is DisplayObjectContainer &&
					DisplayObjectContainer(draggedElement.instance).contains(dropParent.instance)) {
					
	                event.preventDefault();
	                componentListTree.hideDropFeedback(event);
					return;
				}
				
				if (dropParent) {
					/*
					Radiate.info("drop index:"+ dropIndex);
					Radiate.info("row  index:" + rowIndex);
					Radiate.info("item index:" + droppingIndex);*/
					
					Radiate.moveElement2(draggedElement.instance, dropParent.instance, null, null, 
										RadiateEvent.MOVE_ITEM, AddItems.LAST, null, dropIndex);
					
					radiate.setTarget(draggedElement.instance);
					componentListTree.hideDropFeedback(event);
				}
				else {
					
					// if not showing root then allow drop
					if (canDragOutOfParent && dropParent==null) {
						dropParent = ArrayCollection(componentListTree.dataProvider).getItemAt(0);
						currentIndex = ComponentDescription(dropParent).children.getItemIndex(draggedElement);
						
						// when dragging to an index after our index we have to subtract one
						if (currentIndex<dropIndex && dropParent.instance==draggedElement.parent.instance) {
							dropIndex--;
							//Radiate.info("Lowering index");
						}
						
						Radiate.moveElement2(draggedElement.instance, dropParent.instance, null, null, 
										RadiateEvent.MOVE_ITEM, AddItems.LAST, null, dropIndex);
					}
					else {
							
		                // element is an item and parent is different => can not drop                                        
		                event.preventDefault();
		                componentListTree.hideDropFeedback(event);
					}
				}
				
				var refreshesTreeLater:Boolean;
				
				if (refreshesTreeLater) {
					Radiate.callAfter(30, activate);
				}
				
			}
			
			protected function displayListTree_dragCompleteHandler(event:DragEvent):void {
				
			}
			
			/**
			 * Handle when dragging just outside of tree
			 * */
			protected function displayListTree_dragOverHandler(event:DragEvent):void {
				
	            var dropData:Object = componentListTree.mx_internal::_dropData;
				
				// TypeError: Error #1009: Cannot access a property or method of a null object reference.
				// we dragged outside of the design area so dropdata is null
	            var dropParent:Object = dropData ? dropData.parent : null;
				
                // dragging outside of tree                                      
	            if (dropParent==null) {
					// prevents dragging from working after this point
					//event.preventDefault(); 
					//displayListTree.hideDropFeedback(event);
	            }
			}
			
			protected function expandAllNodes_clickHandler(event:MouseEvent):void {
				openAllItems();
			}
			
			protected function closeAllNodes_clickHandler(event:MouseEvent):void {
				closeAllItems();
			}
			
			protected function removeItem_clickHandler(event:MouseEvent):void {
				var selectedIndex:int = componentListTree.selectedIndex;
				
				if (componentListTree.selectedItem) {
					var componentDescription:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
					Radiate.removeElement(componentDescription.instance);
					
					if (selectedIndex>0 && componentListTree.dataProvider && componentListTree.dataProvider.length>0) {
						componentListTree.selectedIndex = selectedIndex-1;
					}
					else if (selectedIndex==0 && componentListTree.dataProvider && componentListTree.dataProvider.length>0) {
						componentListTree.selectedIndex = 0;
					}
				}
			}
			
			public function updateAlphaProperty():void {
				var iDocument:IDocument = radiate.selectedDocument;
				var componentDescription:ComponentDescription = iDocument ? iDocument.getItemDescription(target) : null;
				if (componentDescription==null) return;
				
				var textAccessor:AccessorMetaData = ClassUtils.getMetaDataOfProperty(target, "alpha");

				alphaRenderer.data = textAccessor;
			}
			
			public function updateLockedProperty():void {
				var iDocument:IDocument = radiate.selectedDocument;
				var componentDescription:ComponentDescription = iDocument ? iDocument.getItemDescription(target) : null;
				lockedItem.selected = componentDescription ? componentDescription.locked : false;
			}
			
			public function updateMaskedProperty():void {
				var iDocument:IDocument = radiate.selectedDocument;
				var componentDescription:ComponentDescription = iDocument ? iDocument.getItemDescription(target) : null;
				maskItem.selected = componentDescription ? componentDescription.getIsMask() : null;
			}
			
			protected function propertyChangeHandler(event:RadiateEvent):void {
				callLater(updateAlphaProperty);
			}
			
			protected function lockItem_clickHandler(event:MouseEvent):void {
				var result:Boolean = Radiate.lockComponent(target, lockedItem.selected);
				
				if (!result) {
					Radiate.info("Unable to lock the selected item");
				}
			}
			
			protected function documentItemRenderer_clickHandler(event:MouseEvent):void {
				componentListTree.selectedIndex = -1;
				componentListTree.validateProperties();
				documentItemRenderer.selected = true;
				if (radiate.selectedDocument) {
					radiate.setTarget(radiate.selectedDocument.instance);
				}
			}
			
			protected function removeItem_dragEnterHandler(event:DragEvent):void{
				
				if (event.dragInitiator!=null && event.dragInitiator==componentListTree) {
					DragManager.acceptDragDrop(IUIComponent(event.currentTarget));
				}
			}
			
			protected function removeItem_dragOverHandler(event:DragEvent):void{
				
				if (event.dragInitiator!=null && event.dragInitiator==componentListTree) {
					DragManager.acceptDragDrop(IUIComponent(event.currentTarget));
					removeItem.filters = [glowFilter];
				}
			}
			
			public function removeItem_dragDropHandler(event:DragEvent):void {
				var dragSource:DragSource = event.dragSource;
				var draggedItem:Object = event.draggedItem;
				var dragInitiator:IUIComponent = event.dragInitiator;
				var selectedIndex:int = componentListTree.selectedIndex;
				
				if (componentListTree.selectedItem) {
					var componentDescription:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
					Radiate.removeElement(componentDescription.instance);
					
					if (selectedIndex>0 && componentListTree.dataProvider && componentListTree.dataProvider.length>0) {
						componentListTree.selectedIndex = selectedIndex-1;
					}
					else if (selectedIndex==0 && componentListTree.dataProvider && componentListTree.dataProvider.length>0) {
						componentListTree.selectedIndex = 0;
					}
				}
				
				removeItem.filters = [];
				//radiate.dropItem(event);
			}
			
			protected function duplicateItem_clickHandler(event:MouseEvent):void {
				var selectedTarget:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
				var newItems:Array;
				
				if (selectedTarget) {
					newItems = radiate.duplicateItem(selectedTarget);
				}
				else {
					Radiate.info("No layer selected");
				}
			}
			
			protected function duplicateItem_dragEnterHandler(event:DragEvent):void {
				if (event.dragInitiator!=null && event.dragInitiator==componentListTree) {
					DragManager.acceptDragDrop(IUIComponent(event.currentTarget));
				}
			}
			
			protected function duplicateItem_dragOverHandler(event:DragEvent):void {
				if (event.dragInitiator!=null && event.dragInitiator==componentListTree) {
					DragManager.acceptDragDrop(IUIComponent(event.currentTarget));
					duplicateItem.filters = [glowFilter];
				}
			}
			
			protected function duplicateItem_dragDropHandler(event:DragEvent):void {
				var selectedTarget:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
				
				if (selectedTarget) {
					radiate.duplicateItem(selectedTarget);
				}
				else {
					Radiate.info("No layer selected");
				}
				
				duplicateItem.filters = [];
			}
			
			protected function duplicateItem_dragExitHandler(event:DragEvent):void {
				duplicateItem.filters = [];
			}
			
			protected function refreshTree_clickHandler(event:MouseEvent):void {
				var selectedDocument:Document = radiate.selectedDocument as Document;

				if (selectedDocument) {
					selectedDocument.updateComponentTree();
					updateComponentDisplayList();
					Radiate.info("Layers view updated");
				}
			}
			
			protected function sendBackwardsButton_clickHandler(event:MouseEvent):void {
				var componentDescription:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
				
				if (componentDescription) {
					ArrangeLayers.sendBackwards(componentDescription);
					radiate.setTarget(componentDescription.instance);
					componentListTree.selectedItem = componentDescription;
				}
			}
			
			protected function bringForwardsButton_clickHandler(event:MouseEvent):void {
				var componentDescription:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
				var currentIndex:int;
				var dropIndex:int;
				var parentInstance:Object;
				
				if (componentDescription) {
					ArrangeLayers.bringForwards(componentDescription);
					radiate.setTarget(componentDescription.instance);
					componentListTree.selectedItem = componentDescription;
				}
			}
			
			protected function documentUpdatedHandler(event:Event):void
			{
				updateComponentDisplayList(true);
			}
			
			protected function filtersButton_clickHandler(event:MouseEvent):void
			{
				ViewManager.showFiltersPanel();
			}
			
			protected function maskItem_clickHandler(event:MouseEvent):void {
				var iDocument:IDocument = radiate.selectedDocument;
				var componentDescription:ComponentDescription = iDocument ? iDocument.getItemDescription(target) : null;
				if (componentDescription==null) return;
				var parentComponentDescription:ComponentDescription = componentDescription.parent;
				var parentInstance:Object = parentComponentDescription ? parentComponentDescription.instance : null;
				var mask:Object;
				var elementContainer:IVisualElementContainer;
				
				if (target == iDocument.instance) {
					maskItem.selected = false;
					return;
				}
				
				if (target && target.owner == iDocument.instance) {
					maskItem.selected = false;
					return;
				}
				
				if (parentInstance && "mask" in parentInstance) {
					mask = parentInstance.mask;
					
					// if target is currently a mask then turn it off
					if (mask==target) {
						var selectedIndex:int = componentListTree.selectedIndex;
						var index:int = componentListTree.selectedIndex;
						// could be a better way to do this
						elementContainer = mask.parent as IVisualElementContainer;
						
						if (elementContainer==null) {
							maskItem.selected = false;
							return;
						}
						
						index = elementContainer.getElementIndex(mask as IVisualElement);
						elementContainer.removeElement(mask as IVisualElement);
						
						if ("overlay" in parentInstance && parentInstance.overlay && DisplayLayer(parentInstance.overlay).numDisplayObjects==0) {
							// add it to get past a bug when _objects is null
							//DisplayLayer(parentInstance.overlay).addDisplayObject(mask as DisplayObject);
						}
						
						Radiate.clearProperty(parentInstance, "mask");
						
						elementContainer.addElementAt(mask as IVisualElement, index);
						//ArrayCollection(componentListTree.dataProvider).itemUpdated(parentComponentDescription);
						//ArrayCollection(componentListTree.dataProvider).refresh();
						iDocument.updateComponentTree();
						updateComponentDisplayList();
						componentListTree.selectedIndex = selectedIndex;
						componentDescription = iDocument ? iDocument.getItemDescription(target) : null;
					}
					else if (mask==null) {
						// when switching from alpha mask to luminosity mask nothing changes
						// bc it is cached. turn off cache and it will be turned back on mask change
						if (parentInstance is GroupBase) {
							GroupBase(parentInstance).cacheAsBitmap = false;
							GroupBase(parentInstance).invalidateDisplayList();
						}
						if ("cacheAsBitmap" in target) {
							target.cacheAsBitmap = false;
						}
						
						Radiate.setProperty(parentInstance, "mask", target);
					}
					
					componentDescription.isMask = componentDescription.getIsMask();
				}
				
			}
			
			
			public const MASK:String = "mask";
			protected function maskTypesCallout_closeHandler(event:PopUpEvent):void {
				var maskTypeObject:Object = event.data;
				var componentDefinition:ComponentDefinition;
				var target:Object = radiate.target;
				var currentMaskType:String;
				var selectedMaskType:String;
				var componentTreeCollection:ArrayCollection;
				var selectedItem:ComponentDescription;
				
				selectedItem = componentListTree.selectedItem as ComponentDescription;
				
				if (maskTypeObject && target && MASK in target) {
					selectedMaskType = String(maskTypeObject.name).toLowerCase();
					currentMaskType = target.maskType;
					
					if (currentMaskType!=selectedMaskType) {
						Radiate.setProperty(target, "maskType", selectedMaskType);
						
						componentTreeCollection = componentListTree.dataProvider as ArrayCollection;
						componentTreeCollection.itemUpdated(selectedItem);
					}
				}
			}
			
			protected function removeItem_dragExitHandler(event:DragEvent):void
			{
				removeItem.filters = [];
			}
			
			protected function lockRendererClicked(event:Event):void {
				var componentDescription:ComponentDescription = componentListTree.selectedItem as ComponentDescription;
				
				if (componentDescription) {
					lockedItem.selected = componentDescription.locked;
				}
			}
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<core:CallMethod id="doThingsLater" method="activate" startDelay="50"/>
		<s:GlowFilter id="glowFilter" color="0x0000ff" />
		<panels:MaskTypeCallout id="maskTypesCallout" close="maskTypesCallout_closeHandler(event)"/>
		<panels:LuminosityCallout id="luminosityCallout" />
	</fx:Declarations>
	
	
	<s:HGroup width="100%" height="20" paddingRight="10" verticalAlign="bottom">
		
		<renderers:LayersRenderer id="documentItemRenderer" 
								  click="documentItemRenderer_clickHandler(event)" 
								  autoDrawBackground="true"
								  height="20"
								  width="100%"/>
		
		<s:Spacer width="10"/>
		
		<c:BeveledImageButton id="closeAllNodes" 
							  source="{Radii8LibraryAssets.treeViewClosed}" 
							  toolTip="Close All Layers"
							  click="closeAllNodes_clickHandler(event)"
							  />
		<c:BeveledImageButton id="expandAllNodes" 
							  source="{Radii8LibraryAssets.treeViewOpen}" 
							  toolTip="Expand All Layers"
							  click="expandAllNodes_clickHandler(event)"
							  />
	</s:HGroup>
	
	<c:HorizontalLine  />
	
	<s:Scroller id="scroller" width="100%" height="100%"
				top="0"
				bottom="0">
		<s:Group width="100%" height="100%">
			<c:TreeNoKeyboardHandling id="componentListTree" 
					 width="100%"
					 focusAlpha="0"
					 minHeight="50"
					 itemOpen="displayListTree_itemOpenHandler(event)"
					 itemClose="displayListTree_itemCloseHandler(event)"
					 change="displayListTree_changeHandler(event)"
					 showRoot="false"
					 dataProvider="{components}"
					 labelFunction="labelFunction"
					 verticalScrollPolicy="off"
					 horizontalScrollPolicy="auto"
					 rollOverColor="#ffffff"
					 selectionColor="#d8d8d8"
					 useRollOver="false"
					 borderVisible="false"
					 indentation="16"
					 dragEnabled="true"
					 dropEnabled="true"
					 dragMoveEnabled="true"
					 itemRenderer="com.flexcapacitor.views.renderers.LayersRenderer"
					 mouseDown="displayListTree_mouseDownHandler(event)"
					 dragOver="displayListTree_dragOverHandler(event)"
					 dragDrop="displayListTree_dragDropHandler(event)"
					 dragComplete="displayListTree_dragCompleteHandler(event)"
					 >
			</c:TreeNoKeyboardHandling>
			
			<!--
			<s:Label top="30" visible="{componentListTree.dataProvider==null || componentListTree.dataProvider.length==1}" 
					 textAlign="center" text="No layers" width="100%" color="gray"/>
			-->
		</s:Group>
	</s:Scroller>
	
	
	<c:HorizontalLine  />
	
	<s:HGroup id="controlsGroup" width="100%"
			 height="32"
			 minHeight="28"
			 verticalAlign="middle"
			 paddingRight="8"
			 paddingLeft="2"
			 paddingBottom="14"
			 paddingTop="8"
			 fontSize="10"
			 >
		<views:BlendMode id="blendModeGroup" minWidth="78" toolTip="Blend mode"/>
		<renderers:NumberRenderer id="alphaRenderer" 
								  width="54" 
								  showClearButton="false" 
								  snapInterval="0"
								  toolTip="Alpha"
								  focusAlpha="0"/>
		
		<s:Spacer width="100%"/>
		<c:BeveledImageButton id="refreshTree" 
							  source="{Radii8LibraryAssets.refresh}" 
							  toolTip="Refresh Tree"
							  click="refreshTree_clickHandler(event)"
							  includeInLayout="true"
							  visible="true"
							  />
		<c:BeveledImageToggleButton id="maskItem" 
									source="{Radii8LibraryAssets.mask}"
									toolTip="Mask selection"
									click="maskItem_clickHandler(event)"
									label="Mask"
									width="20"
									height="15"
									showBackgroundWhenSelected="true"
									/>
		<c:BeveledImageToggleButton id="lockedItem" 
									source="{Radii8LibraryAssets.locked}"
									toolTip="Lock position and prevent selection"
									click="lockItem_clickHandler(event)"
									label="Locked"
									showBackgroundWhenSelected="true"
									/>
		<c:BeveledImageButton id="sendBackwardsButton" 
					   source="{Radii8LibraryAssets.sendBackwards}" 
					   toolTip="Send Backward"
					   click="sendBackwardsButton_clickHandler(event)"
					   />
		<c:BeveledImageButton id="bringForwardsButton" 
					   source="{Radii8LibraryAssets.bringForwards}" 
					   toolTip="Bring Forward"
					   click="bringForwardsButton_clickHandler(event)"
					   />
		<c:BeveledImageButton id="filtersButton" 
					   source="{Radii8LibraryAssets.filters}" 
					   toolTip="Show Filters for layers"
					   click="filtersButton_clickHandler(event)"
					   />
		<c:BeveledImageButton id="duplicateItem" 
							  source="{Radii8LibraryAssets.duplicate}" 
							  toolTip="Duplicate"
							  click="duplicateItem_clickHandler(event)"
							  dragEnter="duplicateItem_dragEnterHandler(event)"
							  dragOver="duplicateItem_dragOverHandler(event)"
							  dragDrop="duplicateItem_dragDropHandler(event)"
							  dragExit="duplicateItem_dragExitHandler(event)"
							  />
		<c:BeveledImageButton id="removeItem" 
							  source="{Radii8LibraryAssets.trashCan}" 
							  toolTip="Remove"
							  click="removeItem_clickHandler(event)"
							  dragEnter="removeItem_dragEnterHandler(event)"
							  dragOver="removeItem_dragOverHandler(event)"
							  dragDrop="removeItem_dragDropHandler(event)"
							  dragExit="removeItem_dragExitHandler(event)"
							  />
	</s:HGroup>
	
</s:VGroup>
