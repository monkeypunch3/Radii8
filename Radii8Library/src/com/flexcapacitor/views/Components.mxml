<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 
		 width="400" height="300"
		 creationComplete="creationCompleteHandler(event)"
		 >
	
	<fx:Script>
		<![CDATA[
			import com.flexcapacitor.controller.Radiate;
			import com.flexcapacitor.events.DragDropEvent;
			import com.flexcapacitor.events.RadiateEvent;
			import com.flexcapacitor.utils.DisplayObjectUtils;
			import com.flexcapacitor.utils.DragManagerUtil;
			import com.flexcapacitor.utils.supportClasses.ComponentDescription;
			
			import mx.core.IFlexDisplayObject;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.graphics.SolidColor;
			
			import spark.components.Application;
			import spark.components.ComboBox;
			import spark.components.Group;
			import spark.components.List;
			import spark.components.supportClasses.GroupBase;
			import spark.components.supportClasses.SkinnableTextBase;
			import spark.components.supportClasses.TextBase;
			import spark.primitives.Rect;
			
			private var target:Object;
			private var radiate:Radiate;
			private var dragManagerInstance:DragManagerUtil;
			
			/**
			 *  Get list of component classes from XML and check for definitions
			 * */
			protected function creationCompleteHandler(event:FlexEvent):void {
				radiate = Radiate.getInstance();
				
				components = Radiate.componentDescriptions;
			}
			
			protected function targetChangeHandler(event:RadiateEvent):void
			{
				target = event.selectedItem;
			}
			
			/**
			 * Listen for drag movement and start dragging if drag tolerance is met
			 * */
			public function rowGroupMouseDownHandler(event:MouseEvent, data:Object, itemIndex:int):void {
				var classFactory:ClassFactory;
				var item:ComponentDescription;
				var application:Application;
				var component:Object;
				var rowGroup:Group;
				
				item = ComponentDescription(data);
				
				dropTargetLabel.text = "";
				
				rowGroup = event.currentTarget as Group;
				
				event.stopImmediatePropagation();
				//list.dragEnabled = false;
				
				application = radiate.document as Application || parentApplication as Application;
				
				// Create component to drag
				classFactory = new ClassFactory(item.classType as Class);
				classFactory.properties = item.defaultProperties;
				component = classFactory.newInstance();
				
				if (component is Label) {
					
				}
				
				if (component is Label) {
					
				}
				
				// add fill to rect
				if (component is Rect) {
					var fill:SolidColor = new SolidColor();
					fill.color = 0xFF0000;
					Rect(component).fill = fill;
				}
				
				// we need a custom FlexSprite class to do this
				// do this after drop
				/*if ("eventListeners" in component) {
					component.removeAllEventListeners();
				}*/
				
				// if text based or combo box we need to prevent 
				// interaction with cursor
				if (component is TextBase || component is SkinnableTextBase) {
					component.mouseChildren = false;
					
					if ("textDisplay" in component && component.textDisplay) {
						component.textDisplay.enabled = false;
					}
				}
				
				if (component is IFlexDisplayObject) {
					//component.width = IFlexDisplayObject(component).measuredWidth;
					//component.height = IFlexDisplayObject(component).measuredHeight;
				}
				
				if (component is GroupBase) {
					DisplayObjectUtils.addGroupMouseSupport(component as GroupBase);
				}
				
				if (!dragManagerInstance) {
					dragManagerInstance = new DragManagerUtil();
				}
				
				rowGroup.removeEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
				rowGroup.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler, false, 0, true);
				
				dragManagerInstance.listenForDragBehavior(rowGroup, application, event, component);
				dragManagerInstance.removeEventListener(DragDropEvent.DRAG_DROP, handleDragDrop);
				dragManagerInstance.removeEventListener(DragEvent.DRAG_OVER, handleDragOver);
				dragManagerInstance.removeEventListener(DragDropEvent.DRAG_DROP_COMPLETE, handleDragDropComplete);
				
				dragManagerInstance.addEventListener(DragDropEvent.DRAG_DROP, handleDragDrop);
				dragManagerInstance.addEventListener(DragEvent.DRAG_OVER, handleDragOver);
				dragManagerInstance.addEventListener(DragDropEvent.DRAG_DROP_COMPLETE, handleDragDropComplete);
				
				// DRAG DROP 
				// is continued in 
				// DragManagerUtil.dragDropHandler()
				
				// and then in handleDragDrop() here
			}
			
			/**
			 * Remove mouse handlers from row
			 * */
			protected function mouseUpHandler(event:MouseEvent):void
			{
				// we need a custom FlexSprite class to do this
				/*if (event.currentTarget.eventListeners) {
					event.currentTarget.removeAllEventListeners();
				}*/
				
				//list.dragEnabled = true;
				event.currentTarget.removeEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);
				
			}
			
			/**
			 * Handles drag drop event. This is only the first part of adding to the stage. 
			 * We can prevent automatic adding by calling event.preventDefault().
			 * If we do not call preventDefault dragDropComplete is the next event to be called. 
			 * */
			protected function handleDragDrop(event:DragDropEvent):void
			{
				var component:Object = event.draggedItem;
				
				// if text based or combo box we need to prevent 
				// interaction with cursor
				
				// UPDATE THIS IN DRAG DROP COMPLETE
				
				if (component is TextBase || component is SkinnableTextBase) {
					component.mouseChildren = false;
					
					if ("textDisplay" in component && component.textDisplay) {
						component.textDisplay.enabled = false;
					}
				}
				
				dragManagerInstance.removeEventListener(DragDropEvent.DRAG_DROP, handleDragDrop);
				dropTargetLabel.text = "Drag drop to:" + dragManagerInstance.dropTargetName;
				
				dragManagerInstance.removeEventListener(DragEvent.DRAG_OVER, handleDragOver);
			}
			
			/**
			 * Dispatched after drag drop event. Drag drop can be canceled. If it
			 * is not canceled this event happens. 
			 * */
			protected function handleDragDropComplete(event:DragDropEvent):void
			{
				var component:Object = event.draggedItem;
				
				// if text based or combo box we need to prevent 
				// interaction with cursor
				if (component is TextBase || component is SkinnableTextBase) {
					component.mouseChildren = false;
					
					if ("textDisplay" in component && component.textDisplay) {
						component.textDisplay.enabled = false;
					}
				}
				
				if (component is ComboBox) {
					if ("textInput" in component && component.textInput.textDisplay) {
						component.textInput.textDisplay.enabled = false;
					}
				}
				
				// we need a custom FlexSprite class to do this
				// do this after drop
				if ("eventListeners" in component && !(component is GroupBase)) {
					component.removeAllEventListeners();
				}
				
				dragManagerInstance.removeEventListener(DragDropEvent.DRAG_DROP_COMPLETE, handleDragDropComplete);
				dropTargetLabel.text = "Drag Complete to:" + dragManagerInstance.dropTargetName;
				
				
				dragManagerInstance.removeEventListener(DragEvent.DRAG_OVER, handleDragOver);
			}
			
			protected function addItemHandler(event:RadiateEvent):void {
				//trace("item addedd");
				
				//radiate.target = event.eventTarget;
				
			}
			
			protected function handleDragOver(event:Event):void {
				
				//Radiate.log.info("target: " + dragManagerInstance.lastTargetCandidate);
				dropTargetLabel.text = "Drag over: " + dragManagerInstance.dropTargetName;
			}
			
			protected function list_dragStartHandler(event:DragEvent):void {
				
			}
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<s:ArrayCollection id="components"/>
	</fx:Declarations>
	
	<!--
	<s:Rect>
		<s:fill>
			<s:SolidColor color=""
		</s:fill>
	</s:Rect>-->
	
	<s:layout>
		<s:VerticalLayout gap="6"/>
	</s:layout>
	
	<s:List id="list" 
			width="100%" 
			height="100%"
			labelField="name" 
			dragEnabled="true"
			borderVisible="false"
			interactionMode="mouse"
			dataProvider="{components}"
			dragStart="list_dragStartHandler(event)"
			>
		<s:itemRenderer>
			<fx:Component>
				<s:ItemRenderer width="100%" height="100%" minHeight="22" >
					<fx:Script>
						<![CDATA[
							import com.flexcapacitor.controller.Radiate;
							import com.flexcapacitor.utils.supportClasses.ComponentDescription;
							
							override public function set data(value:Object):void {
								super.data = value;
								var definition:ComponentDescription = value as ComponentDescription;
								var path:String;
								
								
								if (definition) {
									if (definition.icon) {
										iconImage.source = definition.icon;
									}
									else {
										path = "assets/images/components/" + definition.name + ".png";
										iconImage.source = path;
									}
								}
							}
							
							protected function iconImage_ioErrorHandler(event:IOErrorEvent):void {
								iconImage.source = "assets/images/components/BorderContainer.png";
							}
							
							protected function groupMouseDownHandler(event:MouseEvent):void
							{
								outerDocument.rowGroupMouseDownHandler(event, data, itemIndex);
							}
							
						]]>
					</fx:Script>
					<s:HGroup id="rowGroup" 
							  width="100%" 
							  height="100%" 
							  verticalAlign="middle"
							  paddingLeft="5" 
							  mouseDown="groupMouseDownHandler(event)">
						<s:Image id="iconImage"
								 contentLoader="{Radiate.contentCache}"
								 ioError="iconImage_ioErrorHandler(event)"
								 width="16" height="16"/>
						<s:Label id="labelDisplay" 
								 fontSize="11"
								 typographicCase="lowercaseToSmallCaps"/>
					</s:HGroup>
					
				</s:ItemRenderer>
			</fx:Component>
			
		</s:itemRenderer>
	</s:List>
	
	<s:Label id="dropTargetLabel" width="100%" paddingLeft="4"/>
	<s:Spacer height="4"/>
</s:Group>
