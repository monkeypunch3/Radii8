<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 xmlns:c="com.flexcapacitor.controls.*"
		 xmlns:handlers="com.flexcapacitor.handlers.*" 
		 xmlns:clipboard="com.flexcapacitor.effects.clipboard.*" 
		 xmlns:status="com.flexcapacitor.effects.status.*" 
		 
		 minWidth="200" 
		 minHeight="100"
		 creationComplete="group1_creationCompleteHandler(event)">
	
	
	<!-- 
	
	-->
	<fx:Script>
		<![CDATA[
			import com.flexcapacitor.controller.Radiate;
			import com.flexcapacitor.events.HistoryEventItem;
			import com.flexcapacitor.events.HistoryItem;
			import com.flexcapacitor.events.RadiateEvent;
			import com.flexcapacitor.utils.DisplayObjectUtils;
			import com.flexcapacitor.utils.supportClasses.ComponentDescription;
			import com.flexcapacitor.views.supportClasses.Styles;
			
			import mx.collections.ArrayCollection;
			import mx.core.IVisualElement;
			import mx.core.IVisualElementContainer;
			import mx.events.FlexEvent;
			
			import spark.components.Application;
			import spark.components.BorderContainer;
			import spark.components.supportClasses.GroupBase;
			import spark.events.IndexChangeEvent;
			import spark.events.TextOperationEvent;
			import spark.layouts.BasicLayout;
			import spark.layouts.HorizontalLayout;
			import spark.layouts.TileLayout;
			import spark.layouts.VerticalLayout;
			
			public static const HTML:String = "HTML";
			public static const MXML:String = "MXML";
			public static const ANDROID:String = "Android";
			public static const XAML:String = "XAML";
			
			/**
			 * Reference to Radiate
			 * */
			public var radiate:Radiate;

			/**
			 * 
			 * */
			protected function group1_creationCompleteHandler(event:FlexEvent):void {
				radiate = Radiate.getInstance();
				radiate.addEventListener(RadiateEvent.TARGET_CHANGE, handleTargetChange);
				radiate.addEventListener(RadiateEvent.PROPERTY_CHANGE, handlePropertyChange);
				
				if (radiate.target) {
					update();
				}
			}
			
			/**
			 * Handle target change
			 * */
			protected function handleTargetChange(event:RadiateEvent):void {
				
				if (!isCodeModifiedByUser) {
					update();
				}
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
				}
			}
			
			/**
			 * Updates the code when a property change happens. 
			 * If the text has been modified by the user then we don't update the code.
			 * They have to press the resync button. 
			 * */
			protected function handlePropertyChange(event:RadiateEvent):void {
				
				if (!isCodeModifiedByUser) {
					update();
				}
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
				}
			}
			
			/**
			 * Updates the code to reflect the selected language 
			 * */
			protected function codeType_changeHandler(event:IndexChangeEvent):void {
				
				update(true);
				
				// if HTML preview is visible then dispatch an event to 
				// so that preview can be changed else where
				// needs refactoring
				if (radiate.isPreviewVisible && String(codeType.selectedItem)!=HTML) {
					radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
				}
				
			}
			
			/**
			 * Generate the code for the provided target component. 
			 * */
			public function updateTarget(target:Object):void {
				var application:Object = radiate.document || parentApplication;
				var targetDescription:ComponentDescription;
				var display:ComponentDescription;
				var output:String = "";
				var xml:XML;
				
				display = DisplayObjectUtils.getDisplayList(application);
				
				// find target in display list and get it's code
				targetDescription = DisplayObjectUtils.getTargetInComponentDisplayList(target, display);
				
				
				if (targetDescription) {
					getAppliedPropertiesFromHistory(targetDescription);
					
					
					if (codeType.selectedItem==MXML) {
						output = getMXMLOutputString(targetDescription, true);
					}
					else if (codeType.selectedItem==HTML) {
						output = getHTMLOutputString(targetDescription, true, "", true);
						output = output + "\n";
						
						if (stylesheets) {
							output = output + "\n" + stylesheets;
						}
						
						if (css) {
							output = output + "\n" + css;
						}
					}
					else if (codeType.selectedItem==ANDROID) {
						output = getAndroidOutputString(targetDescription, true, "", true);
					}
					
					
					//codeModel.text = output;
					
					
					try {
						xml = new XML(output);
						
						// don't use XML because it converts this:
						// <div ></div>
						// to this:
						// <div />
						// and that breaks the html page
						
						// we can still try it to make sure it's valid
						
						//codeModelTextArea.text = xml.toXMLString();
						codeModelTextArea.text = output;
					}
					catch (error:Error) {
						// Error #1083: The prefix "s" for element "Group" is not bound.
						// <s:Group x="93" y="128">
						//	<s:Button x="66" y="17"/>
						//</s:Group>
						codeModelTextArea.text = output;
					}
					
				}
				else {
					codeModelTextArea.text = "";
				}
			}
			
			
			/**
			 * Get application code
			 * */
			public function getDocumentCode():String {
				updateTarget(radiate.document);
				
				return codeModelTextArea.text;
			}
			
			/**
			 * Gets the formatted MXML output from a component
			 * */
			public function getMXMLOutputString(component:ComponentDescription, addLineBreak:Boolean = false, tabs:String = ""):String {
				var properties:Object = component.properties;
				var styles:Object = component.styles;
				var componentChild:ComponentDescription;
				var name:String = component.name;
				var output:String = "";
				var namespaces:String;
				var value:*;
				
				
				for (var propertyName:String in properties) {
					value = properties[propertyName];
					if (value===undefined) {
						continue;
					}
					output += " ";
					output += propertyName + "=\"" + Object(properties[propertyName]).toString() + "\"";
				}
				
				for (var styleName:String in styles) {
					value = styles[styleName];
					if (value===undefined) {
						continue;
					}
					output += " ";
					output += styleName + "=\"" + Object(styles[styleName]).toString() + "\"";
				}
				
				if (name) {
					if (component.instance is Application) {
						name = "Application";
						namespaces = " xmlns:fx=\"http://ns.adobe.com/mxml/2009\"";
						namespaces += " xmlns:s=\"library://ns.adobe.com/flex/spark\"";
						output = namespaces + " " + output;
					}
					
					output = tabs + "<s:" + name + output;
					
					if (component.children && component.children.length>0) {
						output += ">\n";
						
						for (var i:int;i<component.children.length;i++) {
							componentChild = component.children[i];
							getAppliedPropertiesFromHistory(componentChild);
							output += getMXMLOutputString(componentChild, false, tabs + "\t");
						}
						
						output += tabs + "</s:" + name + ">\n";
					}
					else {
						 output += "/>\n";
					}
				}
				else {
					output = "";
				}
				
				return output;
			}
			
			
			/**
			 * Gets the formatted output from a component.
			 * Needs refactoring.
			 * */
			public function getHTMLOutputString(component:ComponentDescription, addLineBreak:Boolean = false, tabs:String = "", includePreview:Boolean = false):String {
				var property:Object = component.properties;
				var name:String = component.name.toLowerCase();
				var componentChild:ComponentDescription;
				var contentToken:String = "[child_content]";
				var isHorizontalLayout:Boolean;
				var isTileLayout:Boolean;
				var isVerticalLayout:Boolean;
				var isBasicLayout:Boolean;
				var childContent:String = "";
				var wrapperTag:String = "";
				var wrapperTagStyles:String = "";
				var properties:String = "";
				var output:String = "";
				var type:String = "";
				var value:*;
				var index:int;
				var numElements:int;
				var gap:int;
				var instance:Object;
				var styles2:String = "position:absolute";
				var styles:Styles = new Styles();
				var wrapperStyles:Styles = new Styles();
				
				
				
				styles.position = Styles.ABSOLUTE;
				
				// get layout positioning
				if (component.parent && component.parent.instance is IVisualElementContainer) {
					
					if (component.parent.instance.layout is HorizontalLayout) {
						isHorizontalLayout = true;
						styles2 = styles2.replace("absolute", "relative");
						styles.position = Styles.RELATIVE;
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						wrapperTagStyles += "display:inline;";
						wrapperStyles.display = Styles.INLINE_BLOCK;
						gap = HorizontalLayout(component.parent.instance.layout).gap - 4;
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-right:" + gap + "px";
							
						}
						
						wrapperTag = "div";
					}
					else if (component.parent.instance.layout is TileLayout) {
						//isHorizontalLayout = true;
						isTileLayout = true;
						styles = styles.replace("absolute", "relative");
						styles.position = Styles.RELATIVE;
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						wrapperTagStyles += "display:inline;";
						wrapperStyles.display = Styles.INLINE;
						gap = TileLayout(component.parent.instance.layout).horizontalGap - 4;
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-right:" + gap + "px";
							wrapperStyles.paddingRight =  gap + "px";
						}
						
						wrapperTag = "div";
					}
					
					else if (component.parent.instance.layout is VerticalLayout) {
						isVerticalLayout = true;
						styles = styles.replace("absolute", "relative");
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						gap = VerticalLayout(component.parent.instance.layout).gap;
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-bottom:" + gap + "px";
						}
						
						wrapperTag = "div";
					}
					
					else if (component.parent.instance.layout is BasicLayout) {
						isBasicLayout = true;
						styles = styles.replace("absolute", "relative");
						/*index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						gap = BasicLayout(component.parent.instance.layout).gap;*/
						
						/*if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-bottom:" + gap + "px";
						}
						
						wrapperTag = "div";*/
					}
				}
				
				var isXSet:Boolean;
				var isYSet:Boolean;
				// constraints take higher authority
				var isTopSet:Boolean;
				var isLeftSet:Boolean;
				var isRightSet:Boolean;
				
				// loop through assigned properties
				for (var propertyName:String in property) {
					value = property[propertyName];
					
					if (value===undefined || value==null) {
						continue;
					}
					
					
					// if horizontal or vertical layout do not add position
					if (propertyName=="x") {
						if (isLeftSet) continue;
						
						if (!isHorizontalLayout && !isVerticalLayout) {
							styles += "left:" +  Object(property[propertyName]).toString() + "px;";
						}
					}
					else if (propertyName=="left") {
						if (isXSet) {
							styles = styles.replace(/left:\.+px;/, "");
						}
						
						if (!isHorizontalLayout && !isVerticalLayout) {
							styles += "left:" +  Object(property[propertyName]).toString() + "px;";
						}
					}
					else if (propertyName=="y") {
						if (isTopSet) continue;
						
						if (!isHorizontalLayout && !isVerticalLayout) {
							styles += "top:" +  Object(property[propertyName]).toString() + "px;";
						}
					}
					else if (propertyName=="top") {
						if (isYSet) {
							styles = styles.replace(/top:\.+px;/, "");
						}
						
						if (!isHorizontalLayout && !isVerticalLayout) {
							styles += "top:" +  Object(property[propertyName]).toString() + "px;";
						}
					}
					else if (propertyName=="horizontalCenter") {
						if (isXSet || isLeftSet || isRightSet) {
							styles = styles.replace(/left:\.+px;/, "");
						}
						
						if (!isHorizontalLayout && !isVerticalLayout && !isTileLayout) {
							styles += "display:block;margin:0 auto;";
						}
					}
					else {
						// NOT SUPPORTING RANDOM PROPERTIES FOR NOW
						//properties += propertyName + "=\"" + Object(property[propertyName]).toString() + "\"";
						//properties += " ";
					}
				}
				
				
				if (name) {
					
					// create code for element type
					if (name=="application") {
						name = "div";
						
						// container div
						if (includePreview) {
							output = "<div style=\"position:absolute;";
							//output += "width:" + (component.instance.width + 40) + "px;";
							output += "width:100%;";
							output += "height:" + (component.instance.height + 40) + "px;";
							output += "background-color:#666666;\">";
							output += "\n <div " + properties;
							styles = styles.replace("absolute", "relative");
							styles += "width:" + component.instance.width+ "px;";
							styles += "height:" + component.instance.height+ "px;";
							styles += "font-family:" + component.instance.getStyle("fontFamily") + ";";
							styles += "font-size:" + component.instance.getStyle("fontSize") + "px;";
							styles += "margin:0 auto;";
							styles += "top:25px;";
							styles += "background-color:" + DisplayObjectUtils.getColorInHex(component.instance.getStyle("backgroundColor"), true) + ";";
							//output += properties ? " " : "";
							output += "style=\"" + styles + "\">";
							output += contentToken;
							output += "\n </div>\n</div>";
						}
						else {
							//output = "<div style=\"position: absolute;width:100%;height:100%;background-color:#666666;\">";
							output = "<div " + properties;
							styles += "width:" + component.instance.width+ "px;";
							styles += "height:" + component.instance.height+ "px;";
							styles += "border:1px solid black";
							styles += "background-color:" + DisplayObjectUtils.getColorInHex(component.instance.getStyle("backgroundColor"), true) + ";";
							//output += properties ? " " : "";
							output += " style=\"" + styles + "\">";
							output += contentToken;
							output += "\n</div>";
						}
					}
					
					else if (name=="group" || name=="vgroup") {
						name = "div";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<div " + properties;
						output += "name=\"" + component.instance.name + "\"";
						styles += "width:" + component.instance.width+ "px;";
						styles += "height:" + component.instance.height+ "px;";
						output += properties ? " " : "";
						output += " style=\"" + styles + "\">";
						output += contentToken;
						output += "\n" + tabs + "</div>";
						output += getWrapperTag(wrapperTag, true);
					}
					
					else if (name=="bordercontainer") {
						name = "div";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<div " + properties;
						output += "name=\"" + component.instance.name + "\"";
						
						styles += "width:" + component.instance.width+ "px;";
						styles += "height:" + component.instance.height+ "px;";
						styles += getBorderString(component.instance as BorderContainer);
						//styles += component.instance as BorderContainer);
						
						output += properties ? " " : "";
						output += " style=\"" + styles + "\">";
						output += contentToken;
						output += "\n" + tabs + "</div>";
						output += getWrapperTag(wrapperTag, true);
						
					}
					
					else if (name=="hgroup" || name=="tilegroup") {
						name = "div";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<div " + properties;
						output += "name=\"" + component.instance.name + "\"";
						if (component.name=="HGroup") {
							styles += "width:" + Math.max(HGroup(component.instance).contentWidth, component.instance.width)+ "px;";
						}
						else {
							styles += "width:" + component.instance.width+ "px;";
						}
						styles += "height:" + component.instance.height+ "px;";
						
						output += properties ? " " : "";
						output += " style=\"" + styles + "\">";
						output += contentToken;
						output += "\n" + tabs + "</div>";
						output += getWrapperTag(wrapperTag, true);
					}
					else if (name=="button" || name=="togglebutton") {
						name = "button";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<input type=\"" + name.toLowerCase() + "\" "  + properties;
						styles += "width:" + component.instance.width+ "px;";
						styles += "height:" + (component.instance.height+1)+ "px;";
						output += properties ? " " : "";
						styles += "font-family:" + component.instance.getStyle("fontFamily") + ";";
						styles += "font-size:" + component.instance.getStyle("fontSize") + "px;";
						output += "style=\"" + styles + "\"";
						output += " class=\"button\"";
						
						output += " value=\"" + component.instance.label + "\"/>";
						output += getWrapperTag(wrapperTag, true);
					}
					else if (name=="checkbox") {
						if (component.instance.label!="") {
							output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
							output += "<label";
							styles += "width:" + (component.instance.width + 6)+ "px;";
							styles += "height:" + component.instance.height+ "px;";
							styles += "font-family:" + component.instance.getStyle("fontFamily") + ";";
							styles += "font-size:" + component.instance.getStyle("fontSize") + "px;";
							output += " style=\"" + styles + "\">";
							output += "<input type=\"" + name.toLowerCase() + "\">" ;
						}
						else {
							output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
							output += "<input type=\"" + name.toLowerCase() + "\" " + properties;
							output += " style=\"" + styles + "\"/>";
						}
						
						if (component.instance.label!="") {
							output += " " + component.instance.label + "</label>";
						}
						
						output += getWrapperTag(wrapperTag, true);
					}
					else if (name=="radiobutton") {
						name = "radio";
						if (component.instance.label!="") {
							output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
							output += "<label";
							styles += "width:" + (component.instance.width + 8)+ "px;";
							styles += "height:" + component.instance.height+ "px;";
							styles += "font-family:" + component.instance.getStyle("fontFamily") + ";";
							styles += "font-size:" + component.instance.getStyle("fontSize") + "px;";
							output += " style=\"" + styles + "\">";
							output += "<input type=\"radio\"/>" ;
						}
						else {
							output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
							output += "<input type=\"" + name.toLowerCase() + "\" " + properties;
							output += " style=\"" + styles + "\"/>";
						}
						
						if (component.instance.label!="") {
							output += " " + component.instance.label + "</label>";
						}
						
						output += getWrapperTag(wrapperTag, true);
					}
					else if (name=="textinput") {
						name = "input";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<input type=\"input\""  + properties;
						styles += "width:" + component.instance.width+ "px;";
						styles += "height:" + component.instance.height+ "px;";
						styles += "font-family:" + component.instance.getStyle("fontFamily") + ";";
						styles += "font-size:" + component.instance.getStyle("fontSize") + "px;";
						styles += "padding:0;border:1px solid " + DisplayObjectUtils.getColorInHex(component.instance.getStyle("borderColor"), true) + ";margin:0;";
						output += " style=\"" + styles + "\"/>";
						output += getWrapperTag(wrapperTag, true);
					}
					else if (name=="label") {
						name = "label";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<label "  + properties;
						styles += "width:" + component.instance.width+ "px;";
						styles += "height:" + component.instance.height+ "px;";
						styles += "font-family:" + component.instance.getStyle("fontFamily") + ";";
						styles += "font-size:" + component.instance.getStyle("fontSize") + "px;";
						//styles += getBorderString(component.instance as IStyleClient);
						
						output += properties ? " " : "";
						output += "style=\"" + styles + "\">";
						output += component.instance.text;
						output += "</label>";
						output += getWrapperTag(wrapperTag, true);
					}
					else if (name=="image") {
						name = "img";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<img " + properties;
						styles += "width:" + component.instance.width+ "px;";
						styles += "height:" + component.instance.height+ "px;";
						output += " src=\"" + component.instance.source + "\"";
						output += " style=\"" + styles + "\"/>";
						output += getWrapperTag(wrapperTag, true);
					}
					
					else {
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<" + name.toLowerCase()  + " " + properties;
						output += properties ? " " : "";
						output += "style=\"" + styles + "\"/>";
						output += getWrapperTag(wrapperTag, true);
					}
					
					
					// add children
					if (component.children && component.children.length>0) {
						//output += ">\n";
						
						for (var i:int;i<component.children.length;i++) {
							componentChild = component.children[i];
							getAppliedPropertiesFromHistory(componentChild);
							if (i>0) {
								childContent += "\n";
							}
							childContent += getHTMLOutputString(componentChild, false, tabs + "\t");
						}
						
						output = output.replace(contentToken, "\n" + childContent);

					}
					else {
						output = output.replace(contentToken, "\n");
					}
				}
				else {
					output = "";
				}
				
				return output;
			}
			
			/**
			 * Gets the formatted output from a component.
			 * Needs refactoring.
			 * */
			public function getAndroidOutputString(component:ComponentDescription, addLineBreak:Boolean = false, tabs:String = "", includePreview:Boolean = false):String {
				var property:Object = component.properties;
				var name:String = component.name.toLowerCase();
				var componentChild:ComponentDescription;
				var styles:String = "position:absolute;";
				var contentToken:String = "[child_content]";
				var isHorizontalLayout:Boolean;
				var isVerticalLayout:Boolean;
				var childContent:String = "";
				var wrapperTag:String = "";
				var wrapperTagStyles:String = "";
				var properties:String = "";
				var output:String = "";
				var type:String = "";
				var value:*;
				var index:int;
				var numElements:int;
				var gap:int;
				
				// get layout positioning
				if (component.parent && component.parent.instance is GroupBase) {
					
					if (component.parent.instance.layout is HorizontalLayout) {
						isHorizontalLayout = true;
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						wrapperTagStyles += "display:inline;";
						gap = HorizontalLayout(component.parent.instance.layout).gap - 4;
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-right:" + gap + "px";
						}
						
						wrapperTag = "div";
					}
					
					else if (component.parent.instance.layout is VerticalLayout) {
						isVerticalLayout = true;
						styles = styles.replace("absolute", "relative");
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						gap = VerticalLayout(component.parent.instance.layout).gap;
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-bottom:" + gap + "px";
						}
						
						wrapperTag = "div";
					}
				}
				
				
				// loop through assigned properties
				for (var propertyName:String in property) {
					value = property[propertyName];
					
					if (value===undefined || value==null) {
						continue;
					}
					
					
					// if horizontal or vertical layout do not add position
					if (propertyName=="x" || propertyName=="left") {
						
						if (!isHorizontalLayout && !isVerticalLayout) {
							styles += "left:" +  Object(property[propertyName]).toString() + "px;";
						}
					}
					else if (propertyName=="y" || propertyName=="top") {
						
						if (!isHorizontalLayout && !isVerticalLayout) {
							styles += "top:" +  Object(property[propertyName]).toString() + "px;";
						}
					}
					else {
						properties += propertyName + "=\"" + Object(property[propertyName]).toString() + "\"";
						properties += " ";
					}
				}
				
				
				if (name) {
					
					// create code for element type
					if (name=="application") {
						name = "merge";
						output += "<merge";
						output += " xmlns:android=\"http://schemas.android.com/apk/res/android\"";
						output += " xmlns:tools=\"http://schemas.android.com/tools\"";
						output += ">";
						output += contentToken;
						output += "\n</merge>";
						
						// container div
						if (includePreview) {
							
						}
						else {
						}
					}
					
					else if (name=="group") {
						name = "RelativeLayout";
						output = tabs + "<RelativeLayout";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += ">";
						output += contentToken;
						output += "\n" + tabs + "</RelativeLayout>";
					}
					
					
					else if (name=="vgroup" || name=="hgroup") {
						output = tabs + "<LinearLayout";
						
						if (name=="hgroup") {
							output += " android:orientation=\"horizontal\"";
						}
						else {
							output += " android:orientation=\"vertical\"";
						}
						name = "LinearLayout";
						
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += ">";
						output += contentToken;
						output += "\n" + tabs + "</LinearLayout>";
					}
					
					else if (name=="button") {
						/*<Button android:id="@+id/sign_in_button"
		                android:layout_width="wrap_content"
		                android:layout_height="wrap_content"
		                android:layout_marginTop="16dp"
		                android:text="@string/action_sign_in_register"
		                android:paddingLeft="32dp"
		                android:paddingRight="32dp"
		                android:layout_gravity="right" />*/
						output = tabs;
						output += "<Button";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						
						/*if (component.parent.name=="group") {
							output += " android:layout_marginLeft=\"" + getAndroidEquivalentPosition(component) + "\"";
							output += " android:layout_marginTop=\"" + getAndroidEquivalentPosition(component, false) + "\"";
						}
						else {
							
						}*/
						
						output += " android:text=\"" + component.instance.label + "\"";
						output += "/>";
					}
					else if (name=="checkbox") {
						name = "CheckBox";
						output = tabs;
						output += "<CheckBox";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += " android:text=\"" + component.instance.label + "\"/>";
						
						//output += getWrapperTag(wrapperTag, true);
					}
					else if (name=="textinput") {
						/*				
				            <EditText
				                android:id="@+id/password"
				                android:singleLine="true"
				                android:maxLines="1"
				                android:layout_width="match_parent"
				                android:layout_height="wrap_content"
				                android:hint="@string/prompt_password"
				                android:inputType="textPassword"
				                android:imeActionLabel="@string/action_sign_in_short"
				                android:imeActionId="@+id/login"
				                android:imeOptions="actionUnspecified" />*/
						name = "EditText";
						output = tabs;
						output += "<EditText";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += " android:singleLine=\"true\"";
						output += " android:maxLines=\"1\"";
						output += " android:fontFamily=\"" + component.instance.inheritingStyles.fontFamily + "\"";
						output += " android:hint=\""+ component.instance.prompt +"\"";
						
						if (component.instance.displayAsPassword) {
							output += " android:inputType=\"textPassword\"";
						}
						else {
							output += " android:inputType=\"text\"";
						}
						
						output += "/>";
					}
					else if (name=="label") {
						/* <TextView
			            android:id="@+id/login_status_message"
			            android:textAppearance="?android:attr/textAppearanceMedium"
			            android:fontFamily="sans-serif-light"
			            android:layout_width="wrap_content"
			            android:layout_height="wrap_content"
			            android:layout_marginBottom="16dp"
			            android:text="@string/login_progress_signing_in" />*/
						name = "TextView";
						output = tabs;
						output += "<TextView";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += " android:fontFamily=\"" + component.instance.inheritingStyles.fontFamily + "\"";
						output += " android:text=\""+ component.instance.text+"\"";
						output += "/>";
					}
					else if (name=="image") {
						name = "ImageView";
						output = tabs;
						output += "<ImageView " + properties;
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += " android:src=\"@drawable/" + component.instance.source + "\"";
						output += "/>";
					}
					
					else {
						output = tabs;
						output += "<!--<" + name.toLowerCase()  + " " + properties;
						output += properties ? " " : "";
						output += "style=\"" + styles + "\"/>-->";
						//output += getWrapperTag(wrapperTag, true);
					}
					
					
					// add children
					if (component.children && component.children.length>0) {
						//output += ">\n";
						
						for (var i:int;i<component.children.length;i++) {
							componentChild = component.children[i];
							getAppliedPropertiesFromHistory(componentChild);
							
							if (i>0) {
								childContent += "\n";
							}
							
							childContent += getAndroidOutputString(componentChild, false, tabs + "\t");
						}
						
						output = output.replace(contentToken, "\n" + childContent);

					}
					else {
						output = output.replace(contentToken, "\n");
					}
				}
				else {
					output = "";
				}
				
				return output;
			}
			
			/**
			 * Get Android equivalent size. 
			 * Android has fill_parent, match_parent and wrap_content.
			 * It also has numeric value, like "55dp".
			 * */
			public function getAndroidEquivalentSize(element:IVisualElement, width:Boolean = true):String {
				var isPercent:Boolean;
				var output:String;
				
				// get width
				if (width) {
					isPercent = Boolean(element.percentWidth);
					
					if (isPercent) {
						if (element.percentWidth==100) {
							output = "fill_parent";
						}
						else {
							output = String(element.width) + "dp"; // absolute value
						}
					}
					else {
						if ("explicitWidth" in element && element.width==Object(element).explicitWidth) {
							output = String(element.width) + "dp";
						}
						else {
							output = "wrap_content";
						}
					}
					
					return output;
				}
				
				// get height
				isPercent = Boolean(element.percentHeight);
				
				
				if (isPercent) {
					if (element.percentHeight==100) {
						output = "fill_parent";
					}
					else {
						output = String(element.height) + "dp"; // absolute value
					}
				}
				else {
					if ("explicitHeight" in element && element.height==Object(element).percentHeight) {
						output = String(element.height) + "dp";
					}
					else {
						output = "wrap_content";
					}
				}
				
				return output;
			}
			
			/**
			 * Get Android equivalent position
			 * */
			public function getAndroidEquivalentPosition(componentDescription:ComponentDescription, x:Boolean = true):String {
				var element:Object = componentDescription.instance;
				var isPercent:Boolean;
				var output:String;
				
				// get width
				if (x) {
					isPercent = Boolean(element.percentWidth);
					
					
					if (isPercent) {
						if (element.percentWidth==100) {
							output = "fill_parent";
						}
						else {
							output = String(element.width) + "dp"; // absolute value
						}
					}
					else {
						if ("explicitWidth" in element && element.width==Object(element).explicitWidth) {
							output = String(element.width) + "dp";
						}
						else {
							output = "wrap_content";
						}
					}
					
					return output;
				}
				
				// get height
				isPercent = Boolean(element.percentHeight);
				
				
				if (isPercent) {
					if (element.percentHeight==100) {
						output = "fill_parent";
					}
					else {
						output = String(element.height) + "dp"; // absolute value
					}
				}
				else {
					if ("explicitHeight" in element && element.height==Object(element).percentHeight) {
						output = String(element.height) + "dp";
					}
					else {
						output = "wrap_content";
					}
				}
				
				return output;
			}
			
			/**
			 * Get border and background styles of a border container
			 * */
			public function getBorderString(borderContainer:IStyleClient):String {
				var value:String = "";
				
				if (borderContainer.getStyle("backgroundAlpha")!=0) {
					value += "background-color:" + DisplayObjectUtils.getColorInHex(borderContainer.getStyle("backgroundColor"), true) + ";";
					value += "background-alpha:" + borderContainer.getStyle("backgroundAlpha") + ";";
				}
				
				if (borderContainer.getStyle("borderVisible")) {
					value += "border-weight:" + borderContainer.getStyle("borderWeight") + "px;";
					
					if (borderContainer.getStyle("borderColor")) {
						value += "border-color:" + DisplayObjectUtils.getColorInHex(borderContainer.getStyle("borderColor"), true) + ";";
					}
				}
				
				return value;
				
			}
			
			/**
			 * Get an object that contains the properties that have been set on the component.
			 * This does this by going through the history events and checking the changes.
			 * */
			public function getAppliedPropertiesFromHistory(component:ComponentDescription, addToProperties:Boolean = true):Object {
				//var display:ComponentDescription;
				//var length:int;
				var history:ArrayCollection;
				//var output:String = "";
				var historyEvent:HistoryEventItem;
				var historyEvents:Array;
				var historyItem:HistoryItem;
				//var targetsLength:int;
				var eventsLength:int;
				//var targets:Array;
				var propertiesObject:Object = {};
				var stylesObject:Object = {};
				//var changes:Array;
				//var change:PropertyChanges;
				var historyIndex:int = Radiate.getHistoryIndex();
				//var value:*;
				var properties:Array;
				var styles:Array;
				
				history = Radiate.history;
				//length = Radiate.history.length;
				
				for (var i:int=historyIndex+1;i--;) {
					historyItem = history.getItemAt(i) as HistoryItem;
					historyEvents = historyItem.historyEvents;
					eventsLength = historyEvents.length;
					
					for (var j:int=0;j<eventsLength;j++) {
						historyEvent = historyEvents[j] as HistoryEventItem;
						properties = historyEvent.properties;
						styles = historyEvent.styles;
			
						if (historyEvent.targets.indexOf(component.instance)!=-1) {
							for each (var property:String in properties) {
								
								if (property in propertiesObject) {
									continue;
								}
								else {
									propertiesObject[property] = historyEvent.propertyChanges.end[property];
								}
							}
							
							for each (var style:String in styles) {
								
								if (style in stylesObject) {
									continue;
								}
								else {
									stylesObject[style] = historyEvent.propertyChanges.end[style];
								}
							}
						}
						
					}
				}
				/*
				for (;historyIndex>=0;historyIndex--) {
					historyArray = history.getItemAt(historyIndex) as Array;
					j = 0;
					
					for (var j:int;j<historyArray.length;j++) {
						change = historyArray[j] as PropertyChanges;
						
						if (change) {
							//targets = change.target;
							targetsLength = 1;//targets.length; not supporting multiple targets yet
							j = 0;
							
							for (var j:int;j<targetsLength;j++) {
								if (component.instance==change.target) {
									historyEvent = Radiate.historyEventsDictionary[change];
									
									for each (var property:String in historyEvent.properties) {
										
										if (property in propertiesObject) {
											continue;
										}
										else {
											propertiesObject[property] = historyEvent.propertyChanges.end[property];
										}
									}
								}
							}
						}
					}
				}*/
				
				component.properties = propertiesObject;
				component.styles = stylesObject;
				
				return propertiesObject;
			}
			
			/**
			 * Get the document code and dispatch a preview event.
			 * */
			protected function previewButton_clickHandler(event:MouseEvent):void {
				
				if (!isCodeModifiedByUser) {
					getDocumentCode(); // puts document code into text area
				}
				
				// allow to swap between preview and non preview
				if (!radiate.isPreviewVisible) {
					radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
				}
				else {
					radiate.dispatchPreviewEvent(codeModelTextArea.text, "");
				}
			}
			
			
			/**
			 * 
			 * */
			protected function codeModelTextArea_changeHandler(event:TextOperationEvent):void {
				//Radiate.log.info("Text area code changed");
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
				}
				
				if (codeType.selectedItem == HTML) {
					isCodeModifiedByUser = true;
				}
				
			}
			
			/**
			 * 
			 * */
			protected function showSelection_clickHandler(event:MouseEvent):void {
				update(true);
			}
			
			/**
			 * Indicates when the user has typed in the text area
			 * */
			[Bindable]
			public var isCodeModifiedByUser:Boolean;
			
			/**
			 * 
			 * */
			protected function resynceButton_clickHandler(event:MouseEvent):void {
				isCodeModifiedByUser = false;
				update(true);
			}
			
			/**
			 * Updates the code to show the selected item or document
			 * */
			public function update(dispatchCodeUpdatedEvent:Boolean = false):void {
			
				if (showSelection.selected) {
					updateTarget(radiate.target);
				}
				else {
					updateTarget(radiate.document);
				}
				
				if (dispatchCodeUpdatedEvent) {
					radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
				}
			}
				
				
			/**
			 * Get a tag with less than or greater than wrapped around it. 
			 * */
			private function getWrapperTag(wrapperTag:String = "", end:Boolean = false, styles:String = ""):String {
				var output:String = "";
				
				if (wrapperTag=="") return "";
				
				if (end) {
					output = "</" + wrapperTag + ">";
					return output;
				}
				
				output += "<" + wrapperTag;
				
				if (styles) {
					output += " style=\"" + styles + "\"" ;
				}
				
				output += ">";
				
				return output;
			}
			
			/**
			 * Enable or disable live updating as on target change, property change and
			 * user code changes. 
			 * 
			 * If user unchecks and is modified then do not update. 
			 * Resync button will visible for them to update themselves. 
			 * */
			protected function updateCodeLive_changeHandler(event:Event):void {
				
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
				}
				else {
					if (!isCodeModifiedByUser) {
						radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
					}
				}
			}
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		
		<handlers:EventHandler eventName="click" target="{copyIcon}" setTriggerEvent="true">
			
			<clipboard:CopyToClipboard data="{codeModelTextArea.text}" 
									   targetAncestor="{this}" 
									   allowNullData="true">
				<clipboard:successEffect>
					<status:ShowStatusMessage message="Code copied to the clipboard"/>
				</clipboard:successEffect>
				<clipboard:noDataEffect>
					<status:ShowStatusMessage message="Nothing to copy to the clipboard"/>
				</clipboard:noDataEffect>
				<clipboard:errorEffect>
					<status:ShowStatusMessage message="An error occurred while attempting to copy to the clipboard"/>
				</clipboard:errorEffect>
			</clipboard:CopyToClipboard>
			
		</handlers:EventHandler>
		
		<fx:String id="stylesheets">
			<![CDATA[<link rel="stylesheet" href="css/normalize/2.1.2/normalize.css"/>]]>
		</fx:String>
		<fx:String id="css">
			<![CDATA[]]>
		</fx:String>
		<fx:String id="buttonCSS">
			<![CDATA[
<style>
.button {
	position: absolute;
	background: url(assets/svg/button_skin_up.svg) 0 0 no-repeat;
	border: 0px;
}

.button:hover {
	background: url(assets/svg/button_skin_over.svg) 0 0 no-repeat;
}

.button:active {
	background: url(assets/svg/button_skin_down.svg) 0 0 no-repeat;
}
</style>]]>
		</fx:String>
	</fx:Declarations>
	
	<s:TextArea id="codeModelTextArea" 
				top="28"
				focusColor="#585858"
				width="100%" height="100%" 
				fontFamily="Courier New"
				borderVisible="false"
				paddingTop="8"
				change="codeModelTextArea_changeHandler(event)">
		<s:keyFocusChange>
			event.preventDefault();
			event.currentTarget.insertText("\t");
        </s:keyFocusChange>
	</s:TextArea>
	
	<s:HGroup left="0" right="0" 
			  width="100%"
			  clipAndEnableScrolling="true" 
			  paddingLeft="6" 
			  paddingRight="10"
			  >
		
		<s:Button id="resynceButton" 
				  label="Sync Up" 
				  visible="{isCodeModifiedByUser}" 
				  click="resynceButton_clickHandler(event)"
				  />
		
		<s:Spacer width="100%"/>
		
		<s:CheckBox id="updateCodeLive" 
					selected="true"
					label="Update Live"
					visible="{codeType.selectedItem==HTML}" 
					includeInLayout="{codeType.selectedItem==HTML}" 
					change="updateCodeLive_changeHandler(event)"/>
		
		
		<s:CheckBox id="showSelection" 
					selected="false"
					label="Show Selection"
					click="showSelection_clickHandler(event)"/>
		
		<s:Button label="Preview" 
				  visible="{codeType.selectedItem==HTML}" 
				  includeInLayout="{codeType.selectedItem==HTML}" 
				  click="previewButton_clickHandler(event)"/>
		
		<s:ButtonBar id="codeType" 
						selectedIndex="1"
						change="codeType_changeHandler(event)">
			<s:dataProvider>
				<s:ArrayList>
					<fx:String>{MXML}</fx:String>
					<fx:String>{HTML}</fx:String>
					<fx:String>{ANDROID}</fx:String>
				</s:ArrayList>
			</s:dataProvider>
		</s:ButtonBar>
		
		<c:ImageButton id="copyIcon" 
					   height="100%"
					   source="{Radii8LibraryAssets.copy}" 
					   toolTip="Copy the code to the Clipboard"
					   />
	</s:HGroup>
	
	
</s:Group>