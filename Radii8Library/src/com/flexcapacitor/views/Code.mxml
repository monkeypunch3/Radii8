<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 xmlns:c="com.flexcapacitor.controls.*"
		 xmlns:handlers="com.flexcapacitor.handlers.*" 
		 xmlns:clipboard="com.flexcapacitor.effects.clipboard.*" 
		 xmlns:status="com.flexcapacitor.effects.status.*" 
		 xmlns:flexiframe="com.google.code.flexiframe.*"
		 
		 minWidth="200" 
		 minHeight="100"
		 creationComplete="creationCompleteHandler(event)" 
		 resize="editor_resizeHandler(event)"
		 >
	
	
	<!-- 
	
	*******************************
	Code highlighting 
	*******************************
	Currently there are 3 editors, a spark textarea with no 
	syntax highlighting, a mx text area with syntax highlighting
	but some redraw issues and no undo or redo support and 
	an html based editor called ace editor that is awesome
	but has a bug in firefox where the code cannot be edited. 
	when it becomes uneditable you have to click on the flex 
	application and then click back into the editor. 
	it also does not resize correctly but that may be a 
	flex issue. it also is being erased when hidden and revealed.
	
	
	*******************************
	Writing code 
	*******************************
	the code editor only shows the code of the selection or document.
	it is not yet tied to the component to allow the user to enter 
	code and have it be retained. 
	
	in the future there may be a second code window to show or edit the 
	code of the selected event. this would listen for an event like 
	the property or style selected event that the metadata panel uses.
	and / or there may be a option to show all document code or 
	only event code. 
	
	what most likely will happen is that this panel will be used to show
	the selected objects generated code and or the event code. 
	then there would be full sized editors that open up in new 
	tabs that show the complete document code. or for purposes of 
	split view this would continue to server both purposes. 
	
	
	*******************************
	Generating Code: 
	*******************************
	this is the second or third iteration of generating source code
	but it is inadequate.  
	there is code already started in the ComponentDecription class that
	should be better. the component description would have a static 
	property called exporter. this would be a class that would be 
	used to generate the code. it would return the correct code through 
	the componentDescription.toString() method. 
	
	There would be a HTML exporter, MXML exporter and so on. 
	
	Currently the properties and the styles are not set on the 
	componentDescription instance. This is why we are using the current 
	method. 
	-->
	
	<fx:Script>
		<![CDATA[
			import com.flexcapacitor.controller.Radiate;
			import com.flexcapacitor.events.HistoryEvent;
			import com.flexcapacitor.events.HistoryEventItem;
			import com.flexcapacitor.events.RadiateEvent;
			import com.flexcapacitor.model.IDocument;
			import com.flexcapacitor.utils.ClassUtils;
			import com.flexcapacitor.utils.DisplayObjectUtils;
			import com.flexcapacitor.utils.SyntaxHighlighter;
			import com.flexcapacitor.utils.supportClasses.ComponentDescription;
			import com.flexcapacitor.views.supportClasses.Styles;
			import com.google.code.flexiframe.IFrame;
			
			import flash.utils.getTimer;
			
			import mx.collections.ArrayCollection;
			import mx.core.IVisualElement;
			import mx.core.IVisualElementContainer;
			import mx.events.FlexEvent;
			import mx.events.ResizeEvent;
			
			import spark.components.Application;
			import spark.components.BorderContainer;
			import spark.components.supportClasses.GroupBase;
			import spark.events.IndexChangeEvent;
			import spark.events.TextOperationEvent;
			import spark.layouts.BasicLayout;
			import spark.layouts.HorizontalLayout;
			import spark.layouts.TileLayout;
			import spark.layouts.VerticalLayout;
			
			public static const HTML:String = "HTML";
			public static const MXML:String = "MXML";
			public static const ANDROID:String = "Android";
			public static const XAML:String = "XAML";
			
			/**
			 * Reference to Radiate
			 * */
			public var radiate:Radiate;

			/**
			 * 
			 * */
			protected function creationCompleteHandler(event:FlexEvent):void {
				radiate = Radiate.getInstance();
				radiate.addEventListener(RadiateEvent.TARGET_CHANGE, handleTargetChange);
				radiate.addEventListener(RadiateEvent.PROPERTY_CHANGE, handlePropertyChange);
				
				if (radiate.target) {
					update();
				}
			}
			
			/**
			 * Handle target change
			 * */
			protected function handleTargetChange(event:RadiateEvent):void {

				if (!isCodeModifiedByUser) {
					update();
				}
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(sourceCode, HTML);
				}
			}
			
			/**
			 * Updates the code when a property change happens. 
			 * If the text has been modified by the user then we don't update the code.
			 * They have to press the resync button. 
			 * */
			protected function handlePropertyChange(event:RadiateEvent):void {
				
				if (!isCodeModifiedByUser) {
					update();
				}
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(sourceCode, HTML);
				}
			}
			
			/**
			 * Updates the code to reflect the selected language 
			 * */
			protected function codeType_changeHandler(event:IndexChangeEvent):void {
				
				update(true);
				
				// if HTML preview is visible then dispatch an event to 
				// so that preview can be changed else where
				// needs refactoring
				if (radiate.isPreviewVisible && String(codeType.selectedItem)!=HTML) {
					radiate.dispatchPreviewEvent(sourceCode, String(codeType.selectedItem));
				}
				
			}
			
			/**
			 * Generate the code for the provided target component. 
			 * */
			public function updateTarget(target:Object):void {
				var document:IDocument = radiate.document;
				var application:Object = document ? document.instance : null;
				var targetDescription:ComponentDescription;
				var componentTree:ComponentDescription;
				var output:String = "";
				var xml:XML;
				
				componentTree = document.description;
				
				
				
				//return;
				
				// OLD CODE
				
				//componentTree = DisplayObjectUtils.getComponentDisplayList(application);
				
				// find target in display list and get it's code
				targetDescription = DisplayObjectUtils.getTargetInComponentDisplayList(target, componentTree);
				
				
				if (targetDescription) {
					
					// see the top of this document on how to generate source code
					getAppliedPropertiesFromHistory(targetDescription);
					
					
					if (codeType.selectedItem==MXML) {
						output = getMXMLOutputString(targetDescription, true);
					}
					else if (codeType.selectedItem==HTML) {
						var includePreviewCode:Boolean = true;
						
						output = getHTMLOutputString(targetDescription, true, "", includePreviewCode);
						output = output + "\n";
						
						if (stylesheets) {
							output = output + "\n" + stylesheets;
						}
						
						if (css) {
							output = output + "\n" + css;
						}
						
						if (useSVGButtonClass) {
							output = output + "\n" + buttonCSS2;
						}
						
						if (showFullHTMLPageSource) {
							output = html5boilerplate.replace("<!--content-->", output);
						}
							
						
					}
					else if (codeType.selectedItem==ANDROID) {
						output = getAndroidOutputString(targetDescription, true, "", true);
					}
					
					
					//codeModel.text = output;
					
					/*if (currentState=="iframe" && createdEditor) {
						var functionName:String = "setEditorText";
						var result:String = ExternalInterface.call(functionName, output);
					}*/
					
					if (codeType.selectedItem==HTML) {
							
						try {
							// don't use XML for HTML output because it converts this:
							// <div ></div>
							// to this:
							// <div />
							// and that breaks the html page
							
							// we can still try it to make sure it's valid
							xml = new XML(output); // check if valid
							
							sourceCode = output;
							// passing the raw string not the xml
							setTextareaCode(output);
						}
						catch (error:Error) {
							// Error #1083: The prefix "s" for element "Group" is not bound.
							// <s:Group x="93" y="128">
							//	<s:Button x="66" y="17"/>
							//</s:Group>
							sourceCode = output;
							setTextareaCode(output);
						}
					}
					else {
						sourceCode = output;
						setTextareaCode(output);
					}
					
				}
				else {
					sourceCode = "";
					setTextareaCode("");
				}
			}
			
			
			/**
			 * Get application code
			 * */
			public function getDocumentCode():String {
				updateTarget(radiate.document.instance);
				
				return sourceCode;
			}
			
			/**
			 * Get the vertical position string for HTML
			 * */
			public function getVerticalPositionHTML(instance:IVisualElement, propertyModel:Styles, stylesValue:String = "", isBasicLayout:Boolean = true):String {
				
				if (!isBasicLayout) return stylesValue;
				
				if (instance.verticalCenter!=null) {
					stylesValue += "display:block;margin:" + instance.verticalCenter + " auto;";
					stylesValue = stylesValue.replace("absolute", "relative");
					
					propertyModel.display = Styles.BLOCK;
					propertyModel.position = Styles.RELATIVE;
					propertyModel.margin = instance.verticalCenter + " auto;";
					
					return stylesValue;
				}
				else if (instance.top!=null || instance.bottom!=null) {
					stylesValue += instance.top!=null ? "top:" + instance.top + "px;" : "";
					stylesValue += instance.bottom!=null ? "bottom:" + instance.bottom + "px;" : "";
					if (instance.top!=null) propertyModel.top = instance.top + "px";
					if (instance.bottom!=null) propertyModel.bottom = instance.bottom + "px";
					return stylesValue;
				}
				else {
					stylesValue += "top:" + instance.y + "px;";
					propertyModel.top = instance.y + "px;";
				}
				
				return stylesValue;
			}
			
			/**
			 * Gets if horizontal or vertical centered
			 * */
			public function getCentered(instance:IVisualElement):Boolean {
				
				if (instance.horizontalCenter!=null) {
					return true;
				}
				
				return false;
			}
			
			/**
			 * Get the horizontal position string for HTML
			 * */
			public function getHorizontalPositionHTML(instance:IVisualElement, propertyModel:Styles, stylesValue:String = "", isBasicLayout:Boolean = true):String {
				
				if (!isBasicLayout) return stylesValue;
				
				if (instance.horizontalCenter!=null) {
					stylesValue += "display:block;margin:" + instance.horizontalCenter + " auto;";
					stylesValue = stylesValue.replace("absolute", "relative");
					
					propertyModel.display = Styles.BLOCK;
					propertyModel.position = Styles.RELATIVE;
					propertyModel.margin = instance.horizontalCenter + " auto;";
					
					return stylesValue;
				}
				else if (instance.left!=null || instance.right!=null) {
					stylesValue += instance.left!=null ? "left:" + instance.left + "px;" : "";
					stylesValue += instance.right!=null ? "right:" + instance.right + "px;" : "";
					if (instance.left!=null) propertyModel.left = instance.left + "px";
					if (instance.right!=null) propertyModel.right = instance.right + "px";
					return stylesValue;
				}
				else {
					stylesValue += "left:" + instance.x + "px;";
					propertyModel.left = instance.x + "px;";
				}
				
				return stylesValue;
			}
			
			/**
			 * Gets the formatted MXML output from a component
			 * */
			public function getMXMLOutputString(component:ComponentDescription, addLineBreak:Boolean = false, tabs:String = ""):String {
				var properties:Object = component.properties;
				var styles:Object = component.styles;
				var componentChild:ComponentDescription;
				var name:String = component.name;
				var output:String = "";
				var namespaces:String;
				var value:*;
				
				
				for (var propertyName:String in properties) {
					value = properties[propertyName];
					if (value===undefined || value==null) {
						continue;
					}
					output += " ";
					output += propertyName + "=\"" + Object(properties[propertyName]).toString() + "\"";
				}
				
				for (var styleName:String in styles) {
					value = styles[styleName];
					if (value===undefined || value==null) {
						continue;
					}
					output += " ";
					output += styleName + "=\"" + Object(styles[styleName]).toString() + "\"";
				}
				
				if (name) {
					if (component.instance is Application) {
						name = "Application";
						namespaces = " xmlns:fx=\"http://ns.adobe.com/mxml/2009\"";
						namespaces += " xmlns:s=\"library://ns.adobe.com/flex/spark\"";
						output = namespaces + " " + output;
					}
					
					output = tabs + "<s:" + name + output;
					
					if (component.children && component.children.length>0) {
						output += ">\n";
						
						for (var i:int;i<component.children.length;i++) {
							componentChild = component.children[i];
							getAppliedPropertiesFromHistory(componentChild);
							output += getMXMLOutputString(componentChild, false, tabs + "\t");
						}
						
						output += tabs + "</s:" + name + ">\n";
					}
					else {
						 output += "/>\n";
					}
				}
				else {
					output = "";
				}
				
				return output;
			}
			
			
			/**
			 * Gets the formatted output from a component.
			 * Needs refactoring.
			 * */
			public function getHTMLOutputString(component:ComponentDescription, addLineBreak:Boolean = false, tabs:String = "", includePreview:Boolean = false):String {
				var property:Object = component.properties;
				var componentName:String = component.name;
				var htmlName:String = componentName.toLowerCase();
				var componentChild:ComponentDescription;
				var contentToken:String = "[child_content]";
				var styleValue:String = "position:absolute;";
				var styles:Styles = new Styles();
				var wrapperStyles:Styles = new Styles();
				var isHorizontalLayout:Boolean;
				var isVerticalLayout:Boolean;
				var isBasicLayout:Boolean;
				var isTileLayout:Boolean;
				var childContent:String = "";
				var wrapperTag:String = "";
				var wrapperTagStyles:String = "";
				var properties:String = "";
				var outlineStyle:String;
				var output:String = "";
				var type:String = "";
				var instance:Object;
				var numElements:int;
				var index:int;
				var value:*;
				var gap:int;
				
				
				styles.position = Styles.ABSOLUTE;
				outlineStyle = "outline:1px solid red;";
				
				// get layout positioning
				if (component.parent && component.parent.instance is IVisualElementContainer) {
					
					if (component.parent.instance.layout is HorizontalLayout) {
						isHorizontalLayout = true;
						styleValue = styleValue.replace("absolute", "relative");
						styleValue += "vertical-align:middle;";
						styles.position = Styles.RELATIVE;
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						wrapperTagStyles += hasExplicitSizeSet(component.instance as IVisualElement) ? "display:inline-block;" : "display:inline;";
						wrapperStyles.display = hasExplicitSizeSet(component.instance as IVisualElement) ? Styles.INLINE_BLOCK : Styles.INLINE;
						gap = HorizontalLayout(component.parent.instance.layout).gap - 4;
						
						if (showBorders) {
							styleValue += outlineStyle;
						}
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-right:" + gap + "px";
							wrapperStyles.paddingRight =  gap + "px";
							
						}
						
						wrapperTag = "div";
					}
					else if (component.parent.instance.layout is TileLayout) {
						//isHorizontalLayout = true;
						isTileLayout = true;
						styleValue = styleValue.replace("absolute", "relative");
						styles.position = Styles.RELATIVE;
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						wrapperTagStyles += hasExplicitSizeSet(component.instance as IVisualElement) ? "display:inline-block;" : "display:inline;";
						wrapperStyles.display = hasExplicitSizeSet(component.instance as IVisualElement) ? Styles.INLINE_BLOCK : Styles.INLINE;
						gap = TileLayout(component.parent.instance.layout).horizontalGap - 4;
						
						if (showBorders) {
							styleValue += outlineStyle;
						}
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-right:" + gap + "px";
							wrapperStyles.paddingRight =  gap + "px";
						}
						
						wrapperTag = "div";
					}
					
					else if (component.parent.instance.layout is VerticalLayout) {
						isVerticalLayout = true;
						styleValue = styleValue.replace("absolute", "relative");
						styles.position = Styles.RELATIVE;
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						gap = VerticalLayout(component.parent.instance.layout).gap;
						
						if (showBorders) {
							styleValue += outlineStyle;
						}
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-bottom:" + gap + "px";
							wrapperStyles.paddingBottom =  gap + "px";
						}
						
						wrapperTag = "div";
					}
					
					else if (component.parent.instance.layout is BasicLayout) {
						isBasicLayout = true;
						
						
						if (showBorders) {
							styleValue += outlineStyle;
						}
						//styleValue = styleValue.replace("absolute", "relative");
						//styles.position = Styles.RELATIVE;
						/*index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						gap = BasicLayout(component.parent.instance.layout).gap;*/
						
						/*if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-bottom:" + gap + "px";
						}
						
						wrapperTag = "div";*/
					}
				}
				
				// constraints take higher authority
				var isHorizontalSet:Boolean;
				var isVerticalSet:Boolean;
				
				// loop through assigned properties
				for (var propertyName:String in property) {
					value = property[propertyName];
					
					if (value===undefined || value==null) {
						continue;
					}
					
					
					if (verticalPositions.indexOf(propertyName)!=-1 && !isVerticalSet) {
						styleValue = getVerticalPositionHTML(component.instance as IVisualElement, styles, styleValue, isBasicLayout);
						isVerticalSet = true;
					}
					else if (horizontalPositions.indexOf(propertyName)!=-1 && !isHorizontalSet) {
						styleValue = getHorizontalPositionHTML(component.instance as IVisualElement, styles, styleValue, isBasicLayout);
						isHorizontalSet = true;
					}
					
				}
				
				
				if (htmlName) {
					
					// create code for element type
					if (htmlName=="application") {
						htmlName = "div";
						
						// container div
						if (includePreview) {
							/*output = "<div style=\"position:absolute;";
							//output += "width:" + (component.instance.width + 40) + "px;";
							output += "width:100%;";
							output += "height:" + (component.instance.height + 40) + "px;";
							output += "background-color:#666666;\">";*/
							output += "<div " + properties;
							//output = getNameString(component.instance, output);
							output += properties ? " " : "";
							styleValue = styleValue.replace("absolute", "relative");
							styles.position = Styles.ABSOLUTE;
							styleValue += "width:" + component.instance.width+ "px;";
							styleValue += "height:" + component.instance.height+ "px;";
							styleValue += "font-family:" + component.instance.getStyle("fontFamily") + ";";
							styleValue += "font-size:" + component.instance.getStyle("fontSize") + "px;";
							styleValue += "margin:0 auto;";
							styleValue += "left:8px;top:14px;";
							styleValue += "background-color:" + DisplayObjectUtils.getColorInHex(component.instance.getStyle("backgroundColor"), true) + ";";
							//output += properties ? " " : "";
							output += " style=\"" + styleValue + "\">";
							output += contentToken;
							//output += "\n </div>\n</div>";
							output += "\n</div>";
						}
						else {
							//output = "<div style=\"position: absolute;width:100%;height:100%;background-color:#666666;\">";
							output = "<div " + properties;
							//output = getNameString(component.instance, output);
							output += properties ? " " : "";
							styleValue += "width:" + component.instance.width+ "px;";
							styleValue += "height:" + component.instance.height+ "px;";
							styleValue += "border:1px solid black";
							styleValue += "background-color:" + DisplayObjectUtils.getColorInHex(component.instance.getStyle("backgroundColor"), true) + ";";
							//output += properties ? " " : "";
							output += " style=\"" + styleValue + "\">";
							output += contentToken;
							output += "\n</div>";
						}
					}
					
					else if (htmlName=="group" || htmlName=="vgroup") {
						htmlName = "div";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<div " + properties;
						output = getNameString(component.instance, output);
						output += properties ? " " : "";
						styleValue = getSizeString(component.instance as IVisualElement, styleValue);
						
						//styleValue += "width:" + component.instance.width+ "px;";
						//styleValue += "height:" + component.instance.height+ "px;";
						output += " style=\"" + styleValue + "\">";
						output += contentToken;
						output += "\n" + tabs + "</div>";
						output += getWrapperTag(wrapperTag, true);
					}
					
					else if (htmlName=="bordercontainer") {
						htmlName = "div";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<div " + properties;
						output = getNameString(component.instance, output);
						output += properties ? " " : "";
						styleValue = getSizeString(component.instance as IVisualElement, styleValue);
						styleValue += getBorderString(component.instance as BorderContainer);
						//styleValue += getColorString(component.instance as BorderContainer);
						//styles += component.instance as BorderContainer);
						
						output += " style=\"" + styleValue + "\">";
						output += contentToken;
						output += "\n" + tabs + "</div>";
						output += getWrapperTag(wrapperTag, true);
						
					}
					
					else if (htmlName=="hgroup" || htmlName=="tilegroup") {
						htmlName = "div";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<div " + properties;
						output = getNameString(component.instance, output);
						
						//styleValue = getSizeString(component.instance as IVisualElement, styleValue);
						if (component.name=="HGroup") {
							styleValue += "width:" + Math.max(HGroup(component.instance).contentWidth, component.instance.width)+ "px;";
						}
						else {
							styleValue += "width:" + component.instance.width+ "px;";
						}
						styleValue += "height:" + component.instance.height+ "px;";
						
						output += properties ? " " : "";
						output += " style=\"" + styleValue + "\">";
						output += contentToken;
						output += "\n" + tabs + "</div>";
						output += getWrapperTag(wrapperTag, true);
					}
					else if (htmlName=="button" || htmlName=="togglebutton") {
						htmlName = "button";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<input " + properties;
						output = getNameString(component.instance, output);
						output += " type=\"" + htmlName.toLowerCase() + "\" "  + properties;
						output += properties ? " " : "";
						styleValue = getSizeString(component.instance as IVisualElement, styleValue);
						styleValue += "font-family:" + component.instance.getStyle("fontFamily") + ";";
						styleValue += "font-size:" + component.instance.getStyle("fontSize") + "px;";
						output += " style=\"" + styleValue + "\"";
						output += " class=\"buttonSkin\"";
						
						output += " value=\"" + component.instance.label + "\"/>";
						output += getWrapperTag(wrapperTag, true);
					}
					else if (htmlName=="checkbox") {
						if (component.instance.label!="") {
							output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
							output += "<label ";
							output = getNameString(component.instance, output) + "_Label";
							styleValue = getSizeString(component.instance as IVisualElement, styleValue);
							//styleValue += "width:" + (component.instance.width + 6)+ "px;";
							//styleValue += "height:" + component.instance.height+ "px;";
							styleValue += "font-family:" + component.instance.getStyle("fontFamily") + ";";
							styleValue += "font-size:" + component.instance.getStyle("fontSize") + "px;";
							output += " style=\"" + styleValue + "\">";
							output += "<input ";
							output = getNameString(component.instance, output);
							output += " type=\"" + htmlName.toLowerCase() + "\" ";
							output += "/>" ;
						}
						else {
							output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
							output += "<input " + properties;
							output = getNameString(component.instance, output);
							output += " type=\"" + htmlName.toLowerCase() + "\" " + properties;
							//styleValue = getSizeString(component.instance as IVisualElement, styleValue);
							output += " style=\"" + styles + "\"/>";
						}
						
						if (component.instance.label!="") {
							output += " " + component.instance.label + "</label>";
						}
						
						output += getWrapperTag(wrapperTag, true);
					}
					else if (htmlName=="radiobutton") {
						htmlName = "radio";
						if (component.instance.label!="") {
							output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
							output += "<label";
							//styleValue += "width:" + (component.instance.width + 8)+ "px;";
							//styleValue += "height:" + component.instance.height+ "px;";
							styleValue = getSizeString(component.instance as IVisualElement, styleValue);
							styleValue += "font-family:" + component.instance.getStyle("fontFamily") + ";";
							styleValue += "font-size:" + component.instance.getStyle("fontSize") + "px;";
							output += " style=\"" + styleValue + "\">";
							output += "<input type=\"radio\" " ;
							output = getNameString(component.instance, output);
							//styleValue = getSizeString(component.instance as IVisualElement, styleValue);
							output += "/>" ;
						}
						else {
							output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
							output += "<input type=\"" + htmlName.toLowerCase() + "\" " + properties;
							output = getNameString(component.instance, output);
							styleValue = getSizeString(component.instance as IVisualElement, styleValue);
							//styleValue = getSizeString(component.instance as IVisualElement, styleValue);
							output += " style=\"" + styleValue + "\"/>";
						}
						
						if (component.instance.label!="") {
							output += " " + component.instance.label + "</label>";
						}
						
						output += getWrapperTag(wrapperTag, true);
					}
					else if (htmlName=="textinput") {
						htmlName = "input";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<input ";
						output = getNameString(component.instance, output);
						output += " type=\"input\" "  + properties;
						//styleValue += "width:" + component.instance.width+ "px;";
						//styleValue += "height:" + component.instance.height+ "px;";
						styleValue = getSizeString(component.instance as IVisualElement, styleValue);
						styleValue += "font-family:" + component.instance.getStyle("fontFamily") + ";";
						styleValue += "font-size:" + component.instance.getStyle("fontSize") + "px;";
						styleValue += "padding:0;border:1px solid " + DisplayObjectUtils.getColorInHex(component.instance.getStyle("borderColor"), true) + ";";
						output += " style=\"" + styleValue + "\"/>";
						output += getWrapperTag(wrapperTag, true);
					}
					else if (htmlName=="linkbutton") {
						htmlName = "a";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<a "  + properties;
						output = getNameString(component.instance, output);
						//styleValue += "width:" + component.instance.width+ "px;";
						//styleValue += "height:" + component.instance.height+ "px;";
						styleValue = getSizeString(component.instance as IVisualElement, styleValue);
						styleValue += "font-family:" + component.instance.getStyle("fontFamily") + ";";
						styleValue += "font-size:" + component.instance.getStyle("fontSize") + "px;";
						//styles += getBorderString(component.instance as IStyleClient);
						
						output += properties ? " " : "";
						output += " style=\"" + styleValue + "\">";
						output += component.instance.label;
						output += "</a>";
						output += getWrapperTag(wrapperTag, true);
					}
					else if (htmlName=="label") {
						htmlName = "label";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<label "  + properties;
						output = getNameString(component.instance, output);
						//styleValue += "width:" + component.instance.width+ "px;";
						//styleValue += "height:" + component.instance.height+ "px;";
						styleValue = getSizeString(component.instance as IVisualElement, styleValue);
						//styleValue += wrapperTagStyles;
						styleValue += "font-family:" + component.instance.getStyle("fontFamily") + ";";
						styleValue += "font-size:" + component.instance.getStyle("fontSize") + "px;";
						//styles += getBorderString(component.instance as IStyleClient);
						
						output += properties ? " " : "";
						output += " style=\"" + styleValue + "\">";
						output += component.instance.text;
						output += "</label>";
						output += getWrapperTag(wrapperTag, true);
					}
					else if (htmlName=="image") {
						htmlName = "img";
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<img " + properties;
						output = getNameString(component.instance, output);
						//styleValue += "width:" + component.instance.width+ "px;";
						//styleValue += "height:" + component.instance.height+ "px;";
						styleValue = getSizeString(component.instance as IVisualElement, styleValue);
						output += properties ? " " : "";
						output += " src=\"" + component.instance.source + "\"";
						output += " style=\"" + styleValue + "\"/>";
						output += getWrapperTag(wrapperTag, true);
					}
					
					else {
						output = tabs + getWrapperTag(wrapperTag, false, wrapperTagStyles);
						output += "<" + htmlName.toLowerCase()  + " " + properties;
						output = getNameString(component.instance, output);
						styleValue = getSizeString(component.instance as IVisualElement, styleValue);
						output += properties ? " " : "";
						output += " style=\"" + styleValue + "\"/>";
						output += getWrapperTag(wrapperTag, true);
					}
					
					
					// add children
					if (component.children && component.children.length>0) {
						//output += ">\n";
						
						for (var i:int;i<component.children.length;i++) {
							componentChild = component.children[i];
							getAppliedPropertiesFromHistory(componentChild);
							if (i>0) {
								childContent += "\n";
							}
							childContent += getHTMLOutputString(componentChild, false, tabs + "\t");
						}
						
						output = output.replace(contentToken, "\n" + childContent);

					}
					else {
						output = output.replace(contentToken, "\n");
					}
				}
				else {
					output = "";
				}
				
				return output;
			}
			
			/**
			 * Gets the formatted output from a component.
			 * Needs refactoring.
			 * */
			public function getAndroidOutputString(component:ComponentDescription, addLineBreak:Boolean = false, tabs:String = "", includePreview:Boolean = false):String {
				var property:Object = component.properties;
				var name:String = component.name.toLowerCase();
				var componentChild:ComponentDescription;
				var styles:String = "position:absolute;";
				var contentToken:String = "[child_content]";
				var isHorizontalLayout:Boolean;
				var isVerticalLayout:Boolean;
				var childContent:String = "";
				var wrapperTag:String = "";
				var wrapperTagStyles:String = "";
				var properties:String = "";
				var output:String = "";
				var type:String = "";
				var value:*;
				var index:int;
				var numElements:int;
				var gap:int;
				
				// get layout positioning
				if (component.parent && component.parent.instance is GroupBase) {
					
					if (component.parent.instance.layout is HorizontalLayout) {
						isHorizontalLayout = true;
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						wrapperTagStyles += "display:inline;";
						gap = HorizontalLayout(component.parent.instance.layout).gap - 4;
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-right:" + gap + "px";
						}
						
						wrapperTag = "div";
					}
					
					else if (component.parent.instance.layout is VerticalLayout) {
						isVerticalLayout = true;
						styles = styles.replace("absolute", "relative");
						index = GroupBase(component.parent.instance).getElementIndex(component.instance as IVisualElement);
						numElements = GroupBase(component.parent.instance).numElements;
						gap = VerticalLayout(component.parent.instance.layout).gap;
						
						if (index<numElements-1 && numElements>1) {
							wrapperTagStyles += "padding-bottom:" + gap + "px";
						}
						
						wrapperTag = "div";
					}
				}
				
				
				// loop through assigned properties
				for (var propertyName:String in property) {
					value = property[propertyName];
					
					if (value===undefined || value==null) {
						continue;
					}
					
					
					// if horizontal or vertical layout do not add position
					if (propertyName=="x" || propertyName=="left") {
						
						if (!isHorizontalLayout && !isVerticalLayout) {
							styles += "left:" +  Object(property[propertyName]).toString() + "px;";
						}
					}
					else if (propertyName=="y" || propertyName=="top") {
						
						if (!isHorizontalLayout && !isVerticalLayout) {
							styles += "top:" +  Object(property[propertyName]).toString() + "px;";
						}
					}
					else {
						properties += propertyName + "=\"" + Object(property[propertyName]).toString() + "\"";
						properties += " ";
					}
				}
				
				
				if (name) {
					
					// create code for element type
					if (name=="application") {
						name = "merge";
						output += "<merge";
						output += " xmlns:android=\"http://schemas.android.com/apk/res/android\"";
						output += " xmlns:tools=\"http://schemas.android.com/tools\"";
						output += ">";
						output += contentToken;
						output += "\n</merge>";
						
						// container div
						if (includePreview) {
							
						}
						else {
						}
					}
					
					else if (name=="group") {
						name = "RelativeLayout";
						output = tabs + "<RelativeLayout";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += ">";
						output += contentToken;
						output += "\n" + tabs + "</RelativeLayout>";
					}
					
					
					else if (name=="vgroup" || name=="hgroup") {
						output = tabs + "<LinearLayout";
						
						if (name=="hgroup") {
							output += " android:orientation=\"horizontal\"";
						}
						else {
							output += " android:orientation=\"vertical\"";
						}
						name = "LinearLayout";
						
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += ">";
						output += contentToken;
						output += "\n" + tabs + "</LinearLayout>";
					}
					
					else if (name=="button") {
						/*<Button android:id="@+id/sign_in_button"
		                android:layout_width="wrap_content"
		                android:layout_height="wrap_content"
		                android:layout_marginTop="16dp"
		                android:text="@string/action_sign_in_register"
		                android:paddingLeft="32dp"
		                android:paddingRight="32dp"
		                android:layout_gravity="right" />*/
						output = tabs;
						output += "<Button";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						
						/*if (component.parent.name=="group") {
							output += " android:layout_marginLeft=\"" + getAndroidEquivalentPosition(component) + "\"";
							output += " android:layout_marginTop=\"" + getAndroidEquivalentPosition(component, false) + "\"";
						}
						else {
							
						}*/
						
						output += " android:text=\"" + component.instance.label + "\"";
						output += "/>";
					}
					else if (name=="checkbox") {
						name = "CheckBox";
						output = tabs;
						output += "<CheckBox";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += " android:text=\"" + component.instance.label + "\"/>";
						
						//output += getWrapperTag(wrapperTag, true);
					}
					else if (name=="textinput") {
						/*				
				            <EditText
				                android:id="@+id/password"
				                android:singleLine="true"
				                android:maxLines="1"
				                android:layout_width="match_parent"
				                android:layout_height="wrap_content"
				                android:hint="@string/prompt_password"
				                android:inputType="textPassword"
				                android:imeActionLabel="@string/action_sign_in_short"
				                android:imeActionId="@+id/login"
				                android:imeOptions="actionUnspecified" />*/
						name = "EditText";
						output = tabs;
						output += "<EditText";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += " android:singleLine=\"true\"";
						output += " android:maxLines=\"1\"";
						output += " android:fontFamily=\"" + component.instance.inheritingStyles.fontFamily + "\"";
						output += " android:hint=\""+ component.instance.prompt +"\"";
						
						if (component.instance.displayAsPassword) {
							output += " android:inputType=\"textPassword\"";
						}
						else {
							output += " android:inputType=\"text\"";
						}
						
						output += "/>";
					}
					else if (name=="label") {
						/* <TextView
			            android:id="@+id/login_status_message"
			            android:textAppearance="?android:attr/textAppearanceMedium"
			            android:fontFamily="sans-serif-light"
			            android:layout_width="wrap_content"
			            android:layout_height="wrap_content"
			            android:layout_marginBottom="16dp"
			            android:text="@string/login_progress_signing_in" />*/
						name = "TextView";
						output = tabs;
						output += "<TextView";
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += " android:fontFamily=\"" + component.instance.inheritingStyles.fontFamily + "\"";
						output += " android:text=\""+ component.instance.text+"\"";
						output += "/>";
					}
					else if (name=="image") {
						name = "ImageView";
						output = tabs;
						output += "<ImageView " + properties;
						output += " android:layout_width=\"" + getAndroidEquivalentSize(component.instance as IVisualElement) + "\"";
						output += " android:layout_height=\"" + getAndroidEquivalentSize(component.instance as IVisualElement, false) + "\"";
						output += " android:src=\"@drawable/" + component.instance.source + "\"";
						output += "/>";
					}
					
					else {
						output = tabs;
						output += "<!--<" + name.toLowerCase()  + " " + properties;
						output += properties ? " " : "";
						output += "style=\"" + styles + "\"/>-->";
						//output += getWrapperTag(wrapperTag, true);
					}
					
					
					// add children
					if (component.children && component.children.length>0) {
						//output += ">\n";
						
						for (var i:int;i<component.children.length;i++) {
							componentChild = component.children[i];
							getAppliedPropertiesFromHistory(componentChild);
							
							if (i>0) {
								childContent += "\n";
							}
							
							childContent += getAndroidOutputString(componentChild, false, tabs + "\t");
						}
						
						output = output.replace(contentToken, "\n" + childContent);

					}
					else {
						output = output.replace(contentToken, "\n");
					}
				}
				else {
					output = "";
				}
				
				return output;
			}
			
			/**
			 * Get Android equivalent size. 
			 * Android has fill_parent, match_parent and wrap_content.
			 * It also has numeric value, like "55dp".
			 * */
			public function getAndroidEquivalentSize(element:IVisualElement, width:Boolean = true):String {
				var isPercent:Boolean;
				var output:String;
				
				// get width
				if (width) {
					isPercent = Boolean(element.percentWidth);
					
					if (isPercent) {
						if (element.percentWidth==100) {
							output = "fill_parent";
						}
						else {
							output = String(element.width) + "dp"; // absolute value
						}
					}
					else {
						if ("explicitWidth" in element && element.width==Object(element).explicitWidth) {
							output = String(element.width) + "dp";
						}
						else {
							output = "wrap_content";
						}
					}
					
					return output;
				}
				
				// get height
				isPercent = Boolean(element.percentHeight);
				
				
				if (isPercent) {
					if (element.percentHeight==100) {
						output = "fill_parent";
					}
					else {
						output = String(element.height) + "dp"; // absolute value
					}
				}
				else {
					if ("explicitHeight" in element && element.height==Object(element).percentHeight) {
						output = String(element.height) + "dp";
					}
					else {
						output = "wrap_content";
					}
				}
				
				return output;
			}
			
			/**
			 * Get Android equivalent position
			 * */
			public function getAndroidEquivalentPosition(componentDescription:ComponentDescription, x:Boolean = true):String {
				var element:Object = componentDescription.instance;
				var isPercent:Boolean;
				var output:String;
				
				// get width
				if (x) {
					isPercent = Boolean(element.percentWidth);
					
					
					if (isPercent) {
						if (element.percentWidth==100) {
							output = "fill_parent";
						}
						else {
							output = String(element.width) + "dp"; // absolute value
						}
					}
					else {
						if ("explicitWidth" in element && element.width==Object(element).explicitWidth) {
							output = String(element.width) + "dp";
						}
						else {
							output = "wrap_content";
						}
					}
					
					return output;
				}
				
				// get height
				isPercent = Boolean(element.percentHeight);
				
				
				if (isPercent) {
					if (element.percentHeight==100) {
						output = "fill_parent";
					}
					else {
						output = String(element.height) + "dp"; // absolute value
					}
				}
				else {
					if ("explicitHeight" in element && element.height==Object(element).percentHeight) {
						output = String(element.height) + "dp";
					}
					else {
						output = "wrap_content";
					}
				}
				
				return output;
			}
			
			/**
			 * Get border and background styles of a border container
			 * */
			public function getBorderString(element:IStyleClient):String {
				var value:String = "";
				
				if (element.getStyle("backgroundAlpha")!=0) {
					value += "background-color:" + DisplayObjectUtils.getColorInHex(element.getStyle("backgroundColor"), true) + ";";
					value += "background-alpha:" + element.getStyle("backgroundAlpha") + ";";
				}
				
				if (element.getStyle("borderVisible")) {
					value += "border-width:" + element.getStyle("borderWeight") + "px;";
					value += "border-style:solid;";
					
					if (element.getStyle("borderColor")!==undefined) {
						value += "border-color:" + DisplayObjectUtils.getColorInHex(element.getStyle("borderColor"), true) + ";";
					}
				}
				
				if (element.getStyle("color")!==undefined) {
					value += "color:" + DisplayObjectUtils.getColorInHex(element.getStyle("color"), true) + ";";
				}
				
				return value;
				
			}
			
			/**
			 * Get color styles of an element
			 * */
			public function getColorString(element:IStyleClient):String {
				var value:String = "";
				
				if (element.getStyle("color")!==undefined) {
					value += "color:" + DisplayObjectUtils.getColorInHex(element.getStyle("color"), true) + ";";
				}
				
				return value;
				
			}
			
			
			/**
			 * Get name and ID
			 * */
			public function getNameString(instance:Object, propertyValue:String = ""):String {
				
				if ("id" in instance && instance.id) {
					propertyValue += "id=\"" + instance.id + "\"";
				}
				else if ("name" in instance && instance.name) {
					propertyValue += "name=\"" + instance.name + "\"";
				}
				
				return propertyValue;
			}
			
			/**
			 * Checks if size is explicitly set
			 * If explicit width is set then we should use inline-block 
			 * because inline does not respect width and height
			 * */
			public function hasExplicitSizeSet(instance:IVisualElement):Boolean {
				
				if ("explicitWidth" in instance && Object(instance).explicitWidth!=null) {
					return true;
				}
				else if ("explicitHeight" in instance && Object(instance).explicitHeight!=null) {
					return true;
				}
				
				return false;
			}
			
			/**
			 * Get width and height styles
			 * If explicit width is set then we should use inline-block 
			 * because inline does not respect width and height
			 * */
			public function getSizeString(instance:IVisualElement, styleValue:String = ""):String {
				var hasExplicitSize:Boolean;
				var hasBorder:Boolean;
				var border:int;
				
				if (instance is IStyleClient && IStyleClient(instance).getStyle("borderWeight")) {
					
				}
				
				if (!isNaN(instance.percentWidth)) {
					styleValue += "width:" + instance.percentWidth + "%;";
				}
				else if ("explicitWidth" in instance && Object(instance).explicitWidth!=null) {
					styleValue += "width:" + instance.width + "px;";
					hasExplicitSize = true;
				}
				else {
					//styleValue += "width:" + instance.width + "px;";
				}
				
				if (!isNaN(instance.percentHeight)) {
					styleValue += "height:" + instance.percentHeight + "%;";
				}
				else if ("explicitHeight" in instance && Object(instance).explicitHeight!=null) {
					styleValue += "height:" + instance.height + "px;";
					hasExplicitSize = true;
				}
				else {
					//styleValue += "height:" + instance.height + "px;";
				}
				
				if (hasExplicitSize) {
					styleValue += "display:" + Styles.INLINE_BLOCK + ";";
				}
				
				return styleValue;
				
			}
			
			/**
			 * Get an object that contains the properties that have been set on the component.
			 * This does this by going through the history events and checking the changes.
			 * */
			public function getAppliedPropertiesFromHistory(component:ComponentDescription, addToProperties:Boolean = true):Object {
				//var display:ComponentDescription;
				//var length:int;
				var history:ArrayCollection;
				//var output:String = "";
				var historyEvent:HistoryEventItem;
				var historyEvents:Array;
				var historyItem:HistoryEvent;
				//var targetsLength:int;
				var eventsLength:int;
				//var targets:Array;
				var propertiesObject:Object = {};
				var stylesObject:Object = {};
				//var changes:Array;
				//var change:PropertyChanges;
				var historyIndex:int = Radiate.getHistoryIndex();
				//var value:*;
				var properties:Array;
				var styles:Array;
				
				history = Radiate.history;
				//length = Radiate.history.length;
				
				// go back through the history of changes and 
				// add the properties that have been set to an object
				for (var i:int=historyIndex+1;i--;) {
					historyItem = history.getItemAt(i) as HistoryEvent;
					historyEvents = historyItem.historyEventItems;
					eventsLength = historyEvents.length;
					
					for (var j:int=0;j<eventsLength;j++) {
						historyEvent = historyEvents[j] as HistoryEventItem;
						properties = historyEvent.properties;
						styles = historyEvent.styles;
			
						if (historyEvent.targets.indexOf(component.instance)!=-1) {
							for each (var property:String in properties) {
								
								if (property in propertiesObject) {
									continue;
								}
								else {
									propertiesObject[property] = historyEvent.propertyChanges.end[property];
								}
							}
							
							for each (var style:String in styles) {
								
								if (style in stylesObject) {
									continue;
								}
								else {
									stylesObject[style] = historyEvent.propertyChanges.end[style];
								}
							}
						}
						
					}
				}
				/*
				for (;historyIndex>=0;historyIndex--) {
					historyArray = history.getItemAt(historyIndex) as Array;
					j = 0;
					
					for (var j:int;j<historyArray.length;j++) {
						change = historyArray[j] as PropertyChanges;
						
						if (change) {
							//targets = change.target;
							targetsLength = 1;//targets.length; not supporting multiple targets yet
							j = 0;
							
							for (var j:int;j<targetsLength;j++) {
								if (component.instance==change.target) {
									historyEvent = Radiate.historyEventsDictionary[change];
									
									for each (var property:String in historyEvent.properties) {
										
										if (property in propertiesObject) {
											continue;
										}
										else {
											propertiesObject[property] = historyEvent.propertyChanges.end[property];
										}
									}
								}
							}
						}
					}
				}*/
				
				component.properties = propertiesObject;
				component.styles = stylesObject;
				
				return propertiesObject;
			}
			
			public var horizontalPositions:Array = ["x","left","right","horizontalCenter"];
			public var verticalPositions:Array = ["y","top","bottom","verticalCenter"];
			public var sizesPositions:Array = ["width","height"];
			
			/**
			 * Get the document code and dispatch a preview event.
			 * */
			protected function previewButton_clickHandler(event:MouseEvent):void {
				var document:Object;
				
				if (!radiate.document) return;
				
				if (!isCodeModifiedByUser) {
					var code:String = getDocumentCode(); // puts document code into text area
				}
				
				// allow to swap between preview and non preview
				if (!radiate.isPreviewDocumentVisible()) {
					radiate.openDocument(radiate.document, true, null, false);
					document = radiate.getDocumentPreview(radiate.document);
					
					if (document is IFrame) {
						document.content = wrapInPreview(sourceCode);
					}
					
					//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
				}
				else {
					radiate.openDocument(radiate.document);
					//radiate.dispatchPreviewEvent(codeModelTextArea.text, "");
				}
			}
			
			
			/**
			 * Text has changed in the textarea. Update preview if visible
			 * */
			protected function textArea_changeHandler(event:TextOperationEvent = null):void {
				//Radiate.log.info("Text area code changed");
				
				if (updateCodeLive.selected) {
					
					if (radiate.isPreviewDocumentVisible()) {
						var preview:Object = radiate.getDocumentPreview(radiate.document);
						
						if (preview is IFrame) {
							preview.content = wrapInPreview(getTextAreaCode());
						}
						
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					}
					//radiate.dispatchCodeUpdatedEvent(codeModelTextArea.text, HTML);
				}
				
				if (codeType.selectedItem == HTML) {
					isCodeModifiedByUser = true;
				}
				
			}
			
			/**
			 * 
			 * */
			protected function showSelection_clickHandler(event:MouseEvent):void {
				update(true);
			}
			
			/**
			 * Indicates when the user has typed in the text area
			 * */
			[Bindable]
			public var isCodeModifiedByUser:Boolean;
			
			/**
			 * Show borders around HTML elements
			 * */
			[Bindable]
			public var showBorders:Boolean;
			
			/**
			 * Use SVG button class
			 * */
			[Bindable]
			public var useSVGButtonClass:Boolean = true;
			
			/**
			 * Show full HTML page source
			 * */
			[Bindable]
			public var showFullHTMLPageSource:Boolean = false;
			
			/**
			 * 
			 * */
			protected function resyncButton_clickHandler(event:MouseEvent):void {
				isCodeModifiedByUser = false;
				update(true);
			}
			
			/**
			 * Updates the code to show the selected item or document
			 * */
			public function update(dispatchCodeUpdatedEvent:Boolean = false):void {
			
				if (!radiate.target && !radiate.document) return;
				
				if (showSelection.selected) {
					updateTarget(radiate.target);
				}
				else {
					updateTarget(radiate.document.instance);
				}
				
				if (dispatchCodeUpdatedEvent) {
					
					//if (radiate.isPreviewDocumentVisible()) {
					document = radiate.getDocumentPreview(radiate.document);
					
					if (document is IFrame) {
						document.content = wrapInPreview(sourceCode);
					}
						
						//radiate.dispatchPreviewEvent(codeModelTextArea.text, String(codeType.selectedItem));
					//}
					
					radiate.dispatchCodeUpdatedEvent(sourceCode, HTML, openInSeparateWindow.selected);
				}
				
				if (radiate.target is Application) {
					targetNameLabel.text = "Application";
				}
				else {
					targetNameLabel.text = ClassUtils.getIdentifierOrName(radiate.target, true, true);
				}
				/*
				var functionName:String = "createEditor";
				var result:Object;
				if (currentState=="iframe" && !createdEditor) {
					editor.content = "<div id='editor' style='display:block;position:absolute;top:0px;left:0px;right:0px;bottom:0px;height:100%;'></div>";
					editor.validateNow();
					result = ExternalInterface.call(functionName);
					result = ExternalInterface.call("setEditorText", codeModelTextArea.text);
                	createdEditor = true;
				}*/
				
				return;
				
			}
			
			private function callback():void {
				trace("CALLBACK");
			}
			
			private var aceEditorCreated:Boolean;
			private var aceEditorVisible:Boolean;
				
			/**
			 * Get a tag with less than or greater than wrapped around it. 
			 * */
			private function getWrapperTag(wrapperTag:String = "", end:Boolean = false, styles:String = ""):String {
				var output:String = "";
				
				if (wrapperTag=="") return "";
				
				if (end) {
					output = "</" + wrapperTag + ">";
					return output;
				}
				
				output += "<" + wrapperTag;
				
				if (styles) {
					output += " style=\"" + styles + "\"" ;
				}
				
				output += ">";
				
				return output;
			}
			
			/**
			 * Enable or disable live updating as on target change, property change and
			 * user code changes. 
			 * 
			 * If user unchecks and is modified then do not update. 
			 * Resync button will visible for them to update themselves. 
			 * */
			protected function updateCodeLive_changeHandler(event:Event):void {
				
				
				if (updateCodeLive.selected) {
					radiate.dispatchCodeUpdatedEvent(sourceCode, HTML);
				}
				else {
					if (!isCodeModifiedByUser) {
						radiate.dispatchCodeUpdatedEvent(sourceCode, HTML);
					}
				}
			}
			
			
			protected function openInSeparateWindow_changeHandler(event:Event):void {
				
				update();
			}
			
			protected function editor_updateCompleteHandler(event:FlexEvent):void {
				
				var result:Object = ExternalInterface.call("updateHeight", editor.height);
				//trace(result);
			}
			
			private var dataArray:Array= new Array();
              
			private var currentData:int;
			
			private function saveData():void {
			
				if (dataArray.length<10) {
				    dataArray.push(mxTextArea.text);
				}
				else {
					dataArray.splice(0,1);
					dataArray.push(mxTextArea.text);
				}
				
				currentData= dataArray.length-1;
			}

			private function undo():void {
				
				if (currentData>0) {
					mxTextArea.text=dataArray[currentData-1];
					currentData=currentData-1;
				}
			}
			
			private function redo():void {
				if (currentData<dataArray.length-1){
					mxTextArea.text=dataArray[currentData+1];
					currentData=currentData+1;
				}
			}
			
			private function mxTextAreaChangeHandler():void {
				textArea_changeHandler();
				syntaxHighlighter.highlightCode();
				saveData();
			}
			
			/**
			 * Last source code
			 * */
			[Bindable]
			public var sourceCode:String;
			
			public var lastMXTextAreaValue:String;
			
			public var syntaxHighlighter:SyntaxHighlighter;
			
			public function getTextAreaCode():String {
				
				if (currentState=="normal") {
					return sparkTextArea.text;
				}
				else if (currentState=="highlight") {
					return mxTextArea.text;
				}
				else if (currentState=="editor") {
					var result:String = ExternalInterface.call("getEditorText");
					return result;
				}
				
				return null;
			}
			
			/**
			 * Put the generated code into a text area
			 * */
			public function setTextareaCode(value:String):void {
				var createEditor:String = "createEditor";
				var result:Object;
				
				if (currentState=="normal") {
					sparkTextArea.text = value;
					aceEditorVisible = false; // temp for now
				}
				else if (currentState=="highlight") {
					
					if (lastMXTextAreaValue==value) {
						return;
					}
					
					mxTextArea.text = value;
					lastMXTextAreaValue = value;

					if (!syntaxHighlighter) {
						syntaxHighlighter = new SyntaxHighlighter(mxTextArea);
						syntaxHighlighter.timerInterval = 20;
						syntaxHighlighter.cssString = SyntaxHighlighter.CRIMSON_EDITOR_CSS;
					}
					
					syntaxHighlighter.highlightCode();
					aceEditorVisible = false; // temp for now
				}
				else if (currentState=="editor") {
					
					if (!aceEditorCreated) {
						editor.content = "<div id='editor1' style='display:block;position:absolute;top:0px;left:0px;right:0px;bottom:0px;height:100%;width:100%'></div>";
						//editor.content = " ";
						editor.validateNow();
						result = ExternalInterface.call(createEditor, "editor0", ExternalInterface.objectID);
						ExternalInterface.addCallback("editorChange", editorChange);
						ExternalInterface.addCallback("cursorChange", cursorChange);
	                	aceEditorCreated = true;
					}
					
					settingEditorText = true;
					result = ExternalInterface.call("setEditorText", value);
					settingEditorText = false;
					
				}
				
			}
			
			protected function editorType_changeHandler(event:IndexChangeEvent):void {
				currentState = event.currentTarget.selectedItem.name;
				setTextareaCode(sourceCode);
			}
			
			public function editorChange(value:String = ""):void {
				if (settingEditorText || value==sourceCode) return;
				textArea_changeHandler();
			}
			
			public function cursorChange(value:String = ""):void {
				//trace("cursor change:" + getTimer());
			}
			
			protected function editor_resizeHandler(event:ResizeEvent):void {
				//trace("resize from : " + event.currentTarget);
				ExternalInterface.call("resizeEditor");
			}
			
			public var settingEditorText:Boolean;
			
			private function wrapInPreview(source:String):String {
				var componentTree:ComponentDescription = radiate.document.description;
				var targetDescription:ComponentDescription;
				
				if (showSelection.selected) {
					targetDescription = DisplayObjectUtils.getTargetInComponentDisplayList(radiate.target, componentTree);
				}
				else {
					targetDescription = DisplayObjectUtils.getTargetInComponentDisplayList(radiate.document.instance, componentTree);
				}
				
				if (targetDescription==null || radiate.target == componentTree.instance) {
					targetDescription = componentTree;
				}
				
				var output:String = "<div style=\"position:absolute;";
				//output += "width:" + (component.instance.width + 40) + "px;";
				output += "width:100%;";
				output += "height:" + (targetDescription.instance.height + 40) + "px;";
				output += "background-color:#666666;\">" + source + "</div>";
				
				return output;
			}
			
			protected function mxTextArea_keyUpHandler(event:KeyboardEvent):void {
				if (event.keyCode==Keyboard.Z) {
					if (event.ctrlKey && !event.shiftKey) {
						undo();
					}
					if (event.ctrlKey && event.shiftKey) {
						redo();
					}
				}
			}
			
			protected function getHTMLButton_clickHandler(event:MouseEvent):void {
				var htmlText:String = mxTextArea.htmlText;
				trace(htmlText);
			}
			
			protected function showBorders_clickHandler(event:MouseEvent):void {
				showBorders = showBordersCheckbox.selected;
				update(true);
			}
			
			protected function useSVGButtonClassCheckbox_changeHandler(event:Event):void {
				useSVGButtonClass = useSVGButtonClassCheckbox.selected;
				update(true);
			}
			
			protected function showFullHTMLCheckbox_clickHandler(event:MouseEvent):void {
				showFullHTMLPageSource = showFullHTMLCheckbox.selected;
				update(true);
			}
			
		]]>
	</fx:Script>
	
	<fx:Declarations>
		
		<handlers:EventHandler eventName="click" target="{copyIcon}" setTriggerEvent="true">
			
			<clipboard:CopyToClipboard data="{sourceCode}" 
									   targetAncestor="{this}" 
									   allowNullData="true">
				<clipboard:successEffect>
					<status:ShowStatusMessage message="Code copied to the clipboard"/>
				</clipboard:successEffect>
				<clipboard:noDataEffect>
					<status:ShowStatusMessage message="Nothing to copy to the clipboard"/>
				</clipboard:noDataEffect>
				<clipboard:errorEffect>
					<status:ShowStatusMessage message="An error occurred while attempting to copy to the clipboard"/>
				</clipboard:errorEffect>
			</clipboard:CopyToClipboard>
			
		</handlers:EventHandler>
		
		<fx:String id="html5boilerplate">
<![CDATA[<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

        <link rel="stylesheet" href="css/normalize.css">
        <link rel="stylesheet" href="css/main.css">
        <script src="js/vendor/modernizr-2.6.2.min.js"></script>
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->

        <!--content-->

        <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
        <script>window.jQuery || document.write('<script src="js/vendor/jquery-1.10.2.min.js"><\/script>')</script>
        <script src="js/plugins.js"></script>
        <script src="js/main.js"></script>

        <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
        <script>
            (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
            function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
            e=o.createElement(i);r=o.getElementsByTagName(i)[0];
            e.src='//www.google-analytics.com/analytics.js';
            r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
            ga('create','UA-XXXXX-X');ga('send','pageview');
        </script>
    </body>
</html>
]]>
		</fx:String>
		
			<!--<![CDATA[<link rel="stylesheet" href="css/normalize/2.1.2/normalize.css"/>]]>-->
		<fx:String id="stylesheets">
			<![CDATA[]]>
		</fx:String>
		<fx:String id="css">
			<![CDATA[
<style>
*, *:before, *:after {
  -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;
 }

</style>]]>
		</fx:String>
		
		<!--- cause all padding and borders to be inside width and height 
		http://www.paulirish.com/2012/box-sizing-border-box-ftw/
		-->
		<fx:String id="borderBoxCSS">
			<![CDATA[
<style>
*, *:before, *:after {
  -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;
 }

</style>]]>
		</fx:String>
		
		
		<!-- If you use .button it causes sizing issues where the size of the button is 0 
		Firefox: 
		Paste the following code into the editor after all other html code (from style tag to style tag).
		And the class of the HTML button is set to class="button"
		
		Fix: 
		Rename "button" to "buttonSkin" and set class="buttonSkin". In time this will point to actual skins and defined styles.
		Look at buttonCSS2. 
		-->
		<fx:String id="buttonCSS">
			<![CDATA[
<style>
.button {
	position: absolute;
	background: url(assets/svg/button_skin_up.svg) 0 0 no-repeat;
	border: 0px;
}

.button:hover {
	background: url(assets/svg/button_skin_over.svg) 0 0 no-repeat;
}

.button:active {
	background: url(assets/svg/button_skin_down.svg) 0 0 no-repeat;
}
</style>]]>
		</fx:String>
		
		
		<fx:String id="buttonCSS2">
			<![CDATA[
<style>
.buttonSkin {
	background: url(assets/svg/button_skin_up.svg) 0 0 no-repeat;
	border: 0px;
}

.buttonSkin:hover {
	background: url(assets/svg/button_skin_over.svg) 0 0 no-repeat;
	border: 0px;
}

.buttonSkin:active {
	background: url(assets/svg/button_skin_down.svg) 0 0 no-repeat;
	border: 0px;
}
</style>]]>
		</fx:String>
	</fx:Declarations>
	
	<s:states>
		<s:State name="highlight"/>
		<s:State name="editor"/>
		<s:State name="normal"/>
	</s:states>
	
	
	<s:TextArea id="sparkTextArea" 
				top="55"
				focusColor="#585858"
				width="100%" height="100%" 
				fontFamily="Monaco,Menlo,Ubuntu Mono,Consolas,source-code-pro,monospace"
				borderVisible="false"
				paddingTop="8"
				fontSize="12"
				includeIn="normal"
				change="textArea_changeHandler(event)"
				>
		<s:keyFocusChange>
			event.preventDefault();
			event.currentTarget.insertText("\t");
        </s:keyFocusChange>
	</s:TextArea>
	
	<mx:TextArea id="mxTextArea"  
				 top="50"
				 focusAlpha="0"
				 fontFamily="Monaco,Menlo,Ubuntu Mono,Consolas,source-code-pro,monospace"
				 borderVisible="false"
				 paddingTop="8"
				 fontSize="12"
				 width="100%" height="100%"
				 keyUp="mxTextArea_keyUpHandler(event)"
				 change="mxTextAreaChangeHandler()"
				 editable="true"
				 includeIn="highlight"
				 leading="0"
				 />
	
	
	<flexiframe:IFrame id="editor" 
					   top="50" left="0"
					   width="100%" height="100%" 
					   includeIn="editor"
					   resize="editor_resizeHandler(event)"
					   overlayDetection="true"
					   >
	</flexiframe:IFrame>
	
	<s:HGroup left="0" right="0" 
			  width="100%"
			  clipAndEnableScrolling="true" 
			  paddingLeft="6" 
			  paddingRight="10"
			  verticalAlign="baseline"
			  >

		<s:Label id="targetNameLabel" 
				 minWidth="150"
				 color="#A6a5a5" 
				 />
		
		<s:Button id="getHTMLButton" 
				  label="GetHTML" 
				  click="getHTMLButton_clickHandler(event)"
				  includeInLayout="false"
				  />
		
		<s:Spacer width="100%"/>
		
		<s:CheckBox id="openInSeparateWindow" 
					label="Open in Window" 
					visible="{codeType.selectedItem=='htmll'}" 
					includeInLayout="{codeType.selectedItem=='htmll'}" 
					change="openInSeparateWindow_changeHandler(event)"/>
		
		<s:CheckBox id="useSVGButtonClassCheckbox" 
					label="Use SVG Button" 
					visible="{codeType.selectedItem=='htmll'}" 
					includeInLayout="{codeType.selectedItem=='htmll'}" 
					change="useSVGButtonClassCheckbox_changeHandler(event)"/>
		
		<s:CheckBox id="updateCodeLive" 
					selected="true"
					label="Update Live"
					visible="{codeType.selectedItem==HTML}" 
					includeInLayout="{codeType.selectedItem==HTML}" 
					change="updateCodeLive_changeHandler(event)"/>
	
		<s:CheckBox id="showSelection" 
					selected="false"
					label="Show Selected Item"
					visible="false"
					includeInLayout="false"
					click="showSelection_clickHandler(event)"/>
		
		<s:CheckBox id="showFullHTMLCheckbox" 
					selected="false"
					label="Show Full HTML"
					visible="true"
					includeInLayout="true"
					click="showFullHTMLCheckbox_clickHandler(event)"/>
		
		<s:CheckBox id="showBordersCheckbox" 
					selected="false"
					label="Show Outlines"
					click="showBorders_clickHandler(event)"/>
		
		<s:Button id="resyncButton" 
				  label="Resync" 
				  enabled="{isCodeModifiedByUser}" 
				  click="resyncButton_clickHandler(event)"
				  />
		
		<s:Button label="Preview HTML" 
				  enabled="{codeType.selectedItem==HTML}" 
				  click="previewButton_clickHandler(event)"/>
		
		<c:ImageButton id="copyIcon" 
					   source="{Radii8LibraryAssets.copy}" 
					   toolTip="Copy the code to the Clipboard"
					   verticalAlign="middle"
					   useHandCursor="true"
					   />
	</s:HGroup>
	
	
	
	<s:HGroup left="0" right="0" 
			  top="28"
			  width="100%"
			  clipAndEnableScrolling="true" 
			  paddingLeft="6" 
			  paddingRight="10"
			  verticalAlign="baseline"
			  >
		
		
		<s:Label minWidth="150"
				 color="#A6a5a5"
				 includeIn="editor"
				 text="This editor cannot edit in Firefox"
				 />
		
		<s:Label minWidth="150"
				 color="#A6a5a5"
				 includeIn="highlight"
				 text="This editor has no undo or redo"
				 />
		
		
		<s:Label minWidth="150"
				 color="#A6a5a5"
				 includeIn="normal"
				 text="This editor has no syntax highlighting"
				 />
		
		<s:Spacer width="100%"/>
		
		<s:Label text="Editor type:"
				 color="#A6a5a5" 
				 />
		
		<s:ButtonBar id="editorType" 
					 requireSelection="true"
					 selectedIndex="0"
					 labelField="name"
					 initialize="editorType.dataProvider = new ArrayList(states);editorType.selectedIndex = 0;"
					 change="editorType_changeHandler(event)">
		</s:ButtonBar>
		
		<s:Label text="Language type:"
				 color="#A6a5a5" 
				 />
		
		
		<s:ButtonBar id="codeType" 
						selectedIndex="0"
						change="codeType_changeHandler(event)">
			<s:dataProvider>
				<s:ArrayList>
					<fx:String>{MXML}</fx:String>
					<fx:String>{HTML}</fx:String>
					<fx:String>{ANDROID}</fx:String>
				</s:ArrayList>
			</s:dataProvider>
		</s:ButtonBar>
	</s:HGroup>
	
</s:Group>