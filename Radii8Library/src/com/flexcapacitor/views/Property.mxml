<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 minWidth="200" 
		 minHeight="100"
		 xmlns:c="com.flexcapacitor.controls.*"
		 creationComplete="group1_creationCompleteHandler(event)">
	
	
	<!-- 
	TODO:
	
	- update on radiate property change event (only update specific property?)
	- add refresh button
	- add sort 
	- add styles
	- notify of read only property
	- update search skin (clear button)
	- typed in search lingers on null target
	
	-->
	<fx:Script>
		<![CDATA[
			import com.flexcapacitor.controller.Radiate;
			import com.flexcapacitor.events.RadiateEvent;
			import com.flexcapacitor.utils.InspectorUtils;
			import com.flexcapacitor.utils.TypeUtils;
			
			import mx.collections.XMLListCollection;
			import mx.core.IDataRenderer;
			import mx.core.UIComponent;
			import mx.events.FlexEvent;
			import mx.utils.ObjectUtil;
			
			import spark.collections.Sort;
			import spark.collections.SortField;
			import spark.components.gridClasses.DefaultGridItemEditor;
			import spark.events.GridItemEditorEvent;
			import spark.events.TextOperationEvent;
			
			
			private var fontInfoCollection:XMLListCollection = new XMLListCollection();
			private var allItems:XMLListCollection = new XMLListCollection();
			private var inheritingStylesList:XMLListCollection = new XMLListCollection();
			private var nonInheritingStylesList:XMLListCollection = new XMLListCollection();
			private var objectPropertiesList:XMLListCollection = new XMLListCollection();
			private var _dataProviderProperties:XMLListCollection;
			
			public var describedType:XML;
			
			
			public var CUSTOM_ITEM_SORT_CHARACTER:String = "~";
			
			public function get dataProviderProperties():XMLListCollection {
				return _dataProviderProperties;
			}
			
			[Bindable]
			public function set dataProviderProperties(value:XMLListCollection):void {
				if (_dataProviderProperties) {
					_dataProviderProperties = new XMLListCollection(new XMLList());
				}
				
				value.sort = new Sort();
				value.sort.fields = [ new SortField("@name", true)];
				value.refresh();
				_dataProviderProperties = value;
			}
			
			/**
			 * Get Name or ID of target object
			 * */
			public function getName(element:Object):String {
				var id:String;
				
				if (element is UIComponent && element.id != null) {
					id = UIComponent(element).id;
				}
				else if (element.hasOwnProperty("id") && element.id != null) {
					id = element.id;
				}
				else if (element.hasOwnProperty("name") && element.name != null) {
					id = element.name;
				}
				else {
					id = "";
				}
				return id;
			}
			
			/**
			 * Populates the datagrid with all the properties that describe type returns for the given object
			 * */
			public function populatePropertiesGrid(target:Object):void {
				var accessorList:XMLListCollection;
				var propertyName:String;
				var fontLookup:String;
				var fontFamily:String;
				var renderingMode:String;
				var properties:String;
				var inheritingStyles:Object;
				var nonInheritingStyles:Object;
				var property:String;
				var item:XML;
				
				if (target != null) {
					describedType = describeType(target);
					accessorList = new XMLListCollection(describedType.accessor);
					
					// ADD ACCESSORS LIST
					allItems.addAll(accessorList);
					
					// if item is an object enumerate 
					if (describedType.@name=="Object") {
						for (property in target) {
							item = createXMLItem(property, target[property], true, true);
							objectPropertiesList.addItem(item); // we could use allItems.addItem();
						}
					}
					
					allItems.addAll(objectPropertiesList);
					
					/* var blah:Object = getMemberNames(this, true);
					blah = getMemberNames(this);
					blah = nonInheritingStyles;
					blah = styleDeclaration;
					blah = styleName;
					blah = styleManager.inheritingStyles;
					blah = styleManager.qualifiedTypeSelectors;
					blah = styleManager.selectors;
					blah = styleManager.stylesRoot;
					blah = styleManager.typeHierarchyCache;
					blah = styleManager.typeSelectorCache;
					blah = styleManager.hasAdvancedSelectors(); */
					
					if (searchPropertyInput) searchPropertyInput.text = "";
					
					// we check for the text flow property so we can see if fonts are embedded
					if (target.hasOwnProperty("textFlow")) {
						/* if (target.textFlow.computedFormat) {
							fontLookup = target.textFlow.computedFormat.fontLookup;
							fontFamily = target.textFlow.computedFormat.fontFamily;
							renderingMode = target.textFlow.computedFormat.renderingMode;
							fontLookup = "<accessor name='fontLookup' value='" + fontLookup + "'/>";
							fontFamily = "<accessor name='fontFamily' value='" + fontFamily + "'/>";
							renderingMode = "<accessor name='renderingMode' value='" + renderingMode + "'/>";
							properties = fontLookup + fontFamily + renderingMode + propertiesList.toString();
							propertiesList = new XMLList(properties);
						} */
					}
					
					//allItems.addAll(propertiesList);
					
					// attempts to get the values of the properties on the current target
					for each (var node:XML in allItems) {
						propertyName = node.@name;
						
						if (node.@access != "writeonly") {
							
							if (propertyName in target) {
								
								try {
									node.@value = target[propertyName];
									node.@isObject = (target[propertyName] is Object);
								}
								catch (error:Error) {
									node.@value = error.message;
									node.@valueError = true;
								}
							}
						}
					}
					
					// Add in inheriting styles
					if ("inheritingStyles" in target) {
						inheritingStyles = target.inheritingStyles as Object;
						
						for (property in inheritingStyles) {
							item = createXMLItem(property, inheritingStyles[property], true, true);
							inheritingStylesList.addItem(item);
						}
						
						//trace("Inheriting style count", inheritingStylesList.length);
						
						//allItems.addAll(inheritingStylesList);
					}
					
					// Add in non inheriting styles - 
					if (target.hasOwnProperty("nonInheritingStyles")) {
						nonInheritingStyles = target.nonInheritingStyles as Object;
						
						for (property in nonInheritingStyles) {
							item = createXMLItem(property, nonInheritingStyles[property], true, false);
							nonInheritingStylesList.addItem(item);
						}
						
						//trace("Non-Inheriting style count", nonInheritingStylesList.length);
						
						//allItems.addAll(nonInheritingStylesList);
					}
					
					// create an item for unnamed style
					var customItem:XML = createXMLItem(CUSTOM_ITEM_SORT_CHARACTER, "");
					customItem.@search = true;
					allItems.addItem(customItem);
					
					dataProviderProperties = allItems;
				}
				else {
					dataProviderProperties = new XMLListCollection();
				}
			}
			
			private var _target:Object;
			
			public function get target():Object {
				return _target;
			}
			
			[Bindable]
			public function set target(value:Object):void {
				
				_target = value;
				
				if (_target) {
					clear();
					populatePropertiesGrid(_target);
				}
				else {
					clear();
				}
			}
			
			public function createXMLItem(name:String, value:*, style:Boolean=false, inheriting:Boolean=false):XML {
				var xml:XML = <accessor />;
				xml.@name = name;
				xml.@style = style;
				xml.@inheriting = inheriting;
				xml.@access = "readwrite";
				xml.@type = InspectorUtils.getValueType(value);
				xml.@value = String(value);
				return xml;
			}
			
			protected function filterDisplayObjectChangeHandler(item:XML):Boolean {
				var itemName:String = item.attribute("name") ? item.attribute("name") : "";
				var value:String = searchPropertyInput.text;
				
				if (itemName.toLowerCase().indexOf(value) != -1) {
					return true;
				}
				return false;
			}
			
			/**
			 * Filters the property list
			 * if we type a period or a space at the end of the word then 
			 * the value and the name have to match exactly (case-insensitive)
			 * */
			protected function filterPropertyChangeHandler(item:XML):Boolean {
				var itemName:String = item.attribute("name") ? item.attribute("name") : "";
				var value:String = searchPropertyInput.text;
				var valueLength:int = value.length;
				var itemNameLength:int = itemName.length;
				var valueLowerCase:String = value.toLowerCase();
				var itemNameLowerCase:String = itemName.toLowerCase();
				
				// show all items if search is empty
				if (valueLength==0) {
					return true;
				}
				
				// show custom item in case of style
				if (item.@search=="true") {
					item.@name = CUSTOM_ITEM_SORT_CHARACTER + value;
					filteredPropertiesCollection.enableAutoUpdate();
					return true;
				}
				else {
					filteredPropertiesCollection.disableAutoUpdate();
				}
				
				// if we type a period or a space at the end of the word then 
				// the value and the name have to match exactly (case-insensitive)
				if (value.lastIndexOf(".")==valueLength-1 || value.lastIndexOf(" ")==valueLength-1) {
					if (itemNameLowerCase+"."==valueLowerCase || itemNameLowerCase+" "==valueLowerCase) {
						return true;
					}
					else {
						return false;
					}
				}
				
				// we filter from any index
				if (itemNameLowerCase.indexOf(valueLowerCase) != -1) {
					return true;
				}
				
				return false;
			}
			
			protected function findPropertyChangeHandler(event:TextOperationEvent):void {
				filteredPropertiesCollection.refresh();
			}
			
			/**
			 * Attempts to drill into the selected property
			 * */
			protected function gridDoubleClickHandler(event:MouseEvent):void {
				// if the user switches applications and the editor is not closed
				// we get the text control of the editor. we don't want that so return
				if (!(event.target is IDataRenderer)) return;
				
				var instance:Object = event.currentTarget;
				var itemRenderer:IDataRenderer = IDataRenderer(event.target);
				var data:XML = itemRenderer.data as XML;
				
				// this is a check for double click on dataGridColumn
				if (data==null) return;
				var currentValue:String = String(data.@value);
				var propertyName:String = data.@name;
				var type:String = String(data.@type);
				var something:*;
				
				if (propertyName in target) {
					something = target[propertyName];
					
					// if object set new target
					if (!ObjectUtil.isSimple(something)) {
						target = something;
						radiate.dispatchTargetChangeEvent(something);
						//InspectorUtils.dispatchTargetChangeEvent(something, this);
					}
				}
			}
			
			protected function propertiesGrid_itemEditEndHandler(oldValue:Object, newValue:Object, editor:DefaultGridItemEditor):void {
				throw new Error("Is this used?");
				var instance:Object = editor.column.itemEditor;
				if (instance==null) return;
				var data:XML = editor.column.grid.selectedItem as XML; //event.itemRenderer.data as XML;
				var currentValue:String = String(data[editor.column.dataField]);
				var propertyName:String = data.@name;
				var searchField:String = data.@search;
				var isSearchField:Boolean = searchField=="" || searchField==null ? false : searchField as Boolean;;
				var type:String = String(data.@type);
				var styleAttribute:String = data.@style;
				var isStyle:Boolean = styleAttribute=="" || styleAttribute==null ? false : styleAttribute as Boolean;
				var newAssignedValue:*;
				var isChanged:Boolean;
				
				if (isSearchField) {
					propertyName = propertyName.replace(CUSTOM_ITEM_SORT_CHARACTER, "");
					isStyle = true;
				}
				
				if (target) {
					newAssignedValue = TypeUtils.getTypedValue(newValue, type)
					
					InspectorUtils.setTargetProperty(target, propertyName, newAssignedValue, type, isStyle);
					
				}
				
				callLater(maintainFocus);
			}
			
			private function maintainFocus():void {
				//propertiesGrid.editedItemPosition = null;
			}

			protected function searchPropertyInput_enterHandler(event:FlexEvent):void {
				var searchText:String = searchPropertyInput.text;
				var item:XML;
				
				if (filteredPropertiesCollection.length==1) {
					item = filteredPropertiesCollection.getItemAt(0) as XML;
					if (item) {
						item.@value = target is UIComponent ? UIComponent(target).getStyle(searchText) : "";
						filteredPropertiesCollection.itemUpdated(item, "@value");
						filteredPropertiesCollection.refresh();
					}
				}
			}

			/**
			 * Called when... 
			 * */
			protected function changeHandler(event:GridItemEditorEvent):void {
				
				// This could probably all be rewritten
				// we could use inspector utils setProperty
				// ... 
				//trace("");
				var column:GridColumn = event.column;
				if (column.grid.dataGrid.itemEditorInstance==null) return;
				var data:XML = event.currentTarget.selectedItem as XML; //event.itemRenderer.data as XML;
				var currentValue:String = String(data[column.dataField]);
				var propertyName:String = data.@name;
				var searchField:String = data.@search;
				var isSearchField:Boolean = searchField=="" || searchField==null ? false : searchField as Boolean;;
				var type:String = String(data.@type);
				var styleAttribute:String = data.@style;
				var isStyle:Boolean = styleAttribute=="" || styleAttribute==null ? false : styleAttribute as Boolean;
				var newValue:* = DefaultGridItemEditor(column.grid.dataGrid.itemEditorInstance).value;
				
				if (isSearchField) {
					propertyName = propertyName.replace(CUSTOM_ITEM_SORT_CHARACTER, "");
					isStyle = true;
				}
				
				if (target) {
					newValue = TypeUtils.getTypedValue(newValue, type)
					
					InspectorUtils.setTargetProperty(target, propertyName, newValue, type, isStyle);
				}
				
			}
			
			[Bindable]
			public var showSearchBox:Boolean = true;
			
			[Bindable]
			public var showValueBox:Boolean = true;
			
			[Bindable]
			public var showHeader:Boolean = false;
			
			/**
			 * Reference to Radiate
			 * */
			public var radiate:Radiate = Radiate.instance;
			
			/**
			 * Height of the header when not show (to allow resizing of columns)
			 * */
			public var hiddenHeaderHeight:uint = 8;

			protected function group1_creationCompleteHandler(event:FlexEvent):void {
				
				if (!showHeader) {
					//propertiesGrid.columnHeaderGroup.visible = showHeader;
					propertiesGrid.columnHeaderGroup.height = hiddenHeaderHeight;
				}
				
				radiate.addEventListener(RadiateEvent.TARGET_CHANGE, handleTargetChange);
				radiate.addEventListener(RadiateEvent.PROPERTY_CHANGE, propertyChangeHandler);
			}
			
			protected function handleTargetChange(event:RadiateEvent):void {
				target = event.selectedItem;
			}
			
			/**
			 * 
			 * */
			public function clear():void {
				inheritingStylesList.removeAll();
				nonInheritingStylesList.removeAll();
				objectPropertiesList.removeAll();
				allItems.removeAll();
				searchPropertyInput.text = "";
				targetValueText.text = "";
				dataProviderProperties = new XMLListCollection();
			}
			
			protected function saveSessionHandler(event:GridItemEditorEvent):void {
				//trace("Save session");
				var item:XML = propertiesGrid.dataProvider.getItemAt(event.rowIndex) as XML;
				var value:String = String(item.@value);
				var property:String = String(item.@name);
				
				//trace("New Value= ", value);
				Radiate.setProperty(target, property, value);
			}
			
			protected function startSessionHandler(event:GridItemEditorEvent):void {
				//trace("Start session");
			}
			
			protected function savingSessionHandler(event:GridItemEditorEvent):void
			{
				//trace("Saving session");
			}
			
			protected function startingSessionHandler(event:GridItemEditorEvent):void
			{
				//trace("Starting session");
				var item:XML = propertiesGrid.dataProvider.getItemAt(event.rowIndex) as XML;
				if (String(item.@access).indexOf("write")<0) {
					// event.preventDefault();
					// NOTIFY OF READ ONLY 
				}
			}
			
			protected function propertyChangeHandler(event:Event):void
			{
				// radiate property change event
			}
			
		]]>
	</fx:Script>
	
	
	<fx:Declarations>
		
		<s:NumberFormatter id="formatter" 
						   useGrouping="false"/>
		
		<s:ArrayCollection id="filteredPropertiesCollection"
						   filterFunction="filterPropertyChangeHandler"
						   list="{dataProviderProperties}"/>
		
	</fx:Declarations>
	
	
	<s:VGroup id="verticalContainer" width="100%" height="100%"
			  paddingLeft="10" paddingRight="10">
		
		<s:HGroup verticalAlign="middle" 
				  width="100%" height="10%" 
				  visible="{showSearchBox}"
				  includeInLayout="{showSearchBox}">
			
			<s:TextInput id="searchPropertyInput"
						 prompt="Search"
						 minWidth="60"
						 borderAlpha=".3"
						 focusAlpha="0"
						 color="#2F3030" 
						 fontWeight="normal"
						 width="100%" 
						 skinClass="com.flexcapacitor.skins.SearchTextInputSkin"
						 enter="searchPropertyInput_enterHandler(event)"
						 change="findPropertyChangeHandler(event)"/>
		</s:HGroup>
		
		<c:DataGrid id="propertiesGrid"
					borderAlpha=".2"
					height="100%" 
					width="100%"
					minWidth="80"
					minHeight="48"
					rowHeight="18"
					variableRowHeight="true"
					dataProvider="{filteredPropertiesCollection}"
					doubleClickEnabled="true" 
					interactionMode="mouse"
					editable="true"
					doubleClick="gridDoubleClickHandler(event)"
					skinClass="com.flexcapacitor.views.skins.PropertiesDataGridSkin"
					gridItemEditorSessionStart="startSessionHandler(event)"
					gridItemEditorSessionSave="saveSessionHandler(event)"
					gridItemEditorSessionSaving="savingSessionHandler(event)"
					gridItemEditorSessionStarting="startingSessionHandler(event)">
			
			<c:columns>
				<s:ArrayCollection>
					
					<s:GridColumn dataField="@name" 
								  minWidth="50"
								  editable="false" 
								  resizable="true"
								  headerText="PROPERTY">
						<s:itemRenderer>
							<fx:Component className="defaultItemRenderer">
								<s:GridItemRenderer minHeight="14">
									<s:Label id="labelDisplay"
											 verticalCenter="1" left="0" right="0" top="0" bottom="0"
											 fontSize="12"
											 paddingTop="3"
											 paddingBottom="3"
											 paddingLeft="3"
											 paddingRight="3"
											 textAlign="start"
											 verticalAlign="middle"
											 width="100%" 
											 maxDisplayedLines="1"
											 showTruncationTip="true"/>
								</s:GridItemRenderer>
							</fx:Component>
						</s:itemRenderer>
					</s:GridColumn>
					
					<s:GridColumn dataField="@value" 
								  minWidth="50"
								  editable="true" 
								  resizable="true"
								  headerText="VALUE">
						<s:itemRenderer>
							<fx:Component >
								<s:GridItemRenderer minHeight="14">
									<s:Label id="labelDisplay" 
											 verticalCenter="1" left="0" right="0" top="0" bottom="0"
											 fontSize="12"
											 paddingTop="3"
											 paddingBottom="3"
											 paddingLeft="3"
											 paddingRight="3"
											 textAlign="start"
											 verticalAlign="middle"
											 maxDisplayedLines="1"
											 showTruncationTip="true" />
								</s:GridItemRenderer>
							</fx:Component>
						</s:itemRenderer>
					</s:GridColumn>
					
					<s:GridColumn headerText="" 
								  minWidth="30"
								  width="30"
								  editable="false"
								  labelFunction="{function(data:Object, column:GridColumn):String{return'...';}}">
					</s:GridColumn>
					
					
					<!--<s:GridColumn width="50"
									   dataField="@type" editable="false"
									   headerText="type"/>
					<s:GridColumn width="35"
									   dataField="@style" editable="false"
									   headerText="Style"/>
					<s:GridColumn width="35"
									   dataField="@inheriting" editable="false"
									   headerText="Inheriting"/>-->
					
				</s:ArrayCollection>
			</c:columns>
		</c:DataGrid>
		
		<s:TextArea id="targetValueText" 
					text="{XML(propertiesGrid.selectedItem).@value}"
					width="100%" 
					heightInLines="1" 
					skinClass="spark.skins.spark.TextAreaSkin"
					minHeight="10" 
					visible="{propertiesGrid.selectedIndex>=0}"
					includeInLayout="{propertiesGrid.selectedIndex>=0}">
		</s:TextArea>
		
	</s:VGroup>
	
</s:Group>
